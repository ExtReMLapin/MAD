--[=[
 o-----------------------------------------------------------------------------o
 |
 | Generic utility module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide a set of generic utilities

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local ffi = require 'ffi'
local bit = require 'bit'

local type, tostring = type, tostring

local option, fun, _C in MAD

local band, bor, rol, rshift in bit
local totable, iter          in fun
local abs, min, max          in math

local is_nil, is_boolean, is_number, is_string, is_table, is_emptytable,
      is_value, is_integer, is_iterable, is_mappable, is_callable,
      is_stringable, is_tablable, is_copiable, is_sameable,
      get_metatable, get_metamethod, wprotect,
      set_concept, concept                                         in MAD.typeid

local not_mappable, not_extendable, not_mutable                    in concept

-- implementation -------------------------------------------------------------o

-- operators

local operator = {

  -- bits operators (see http://bitop.luajit.org/api.html)
  tobit   = bit.tobit,
  tohex   = bit.tohex,
  bnot    = bit.bnot,
  bor     = bit.bor,
  band    = bit.band,
  bxor    = bit.bxor,
  lshift  = bit.lshift,
  rshift  = bit.rshift,
  arshift = bit.arshift,
  rol     = bit.rol,
  ror     = bit.ror,
  bswap   = bit.bswap,

  bset    = \x,n -> bor (x, rol( 1, n)),
  btst    = \x,n -> band(x, rol( 1, n)) ~= 0,
  bclr    = \x,n -> band(x, rol(-2, n)),

  -- logical operators
  lfalse  = \    -> false,
  ltrue   = \    -> true,
  lbool   = \x   -> not not x,
  lnot    = \x   -> not x,
  land    = \x,y -> x and y,
  lor     = \x,y -> x or y,
  eq      = \x,y -> x == y,
  ne      = \x,y -> x ~= y,
  lt      = \x,y -> x <  y,
  le      = \x,y -> x <= y,
  gt      = \x,y -> x >  y,
  ge      = \x,y -> x >= y,

  -- math operators
  unm     = \x   ->  -x,
  sqr     = \x   -> x * x,
  add     = \x,y -> x + y,
  sub     = \x,y -> x - y,
  mul     = \x,y -> x * y,
  div     = \x,y -> x / y,
  mod     = \x,y -> x % y,
  pow     = \x,y -> x ^ y,
  emul    = \x,y -> x:emul(y), -- .*
  ediv    = \x,y -> x:ediv(y), -- ./
  emod    = \x,y -> x:emod(y), -- .%
  epow    = \x,y -> x:epow(y), -- .^

  -- object operators
  get     = \x,k   -> x[k],
  set     = \x,k,v => x[k]=v end,
  len     = \x     -> #x,
  cat     = \x,y   -> x..y,
  call    = \x,... -> x(...),
}

operator.opstr = {
  ['~' ] = operator.unm,
  ['+' ] = operator.add,
  ['-' ] = operator.sub,
  ['*' ] = operator.mul,
  ['/' ] = operator.div,
  ['%' ] = operator.mod,
  ['^' ] = operator.pow,
  ['.*'] = operator.emul,
  ['./'] = operator.ediv,
  ['.%'] = operator.emod,
  ['.^'] = operator.epow,
  ['#' ] = operator.len,
  ['..'] = operator.cat,
  ['<' ] = operator.lt,
  ['>' ] = operator.gt,
  ['<='] = operator.le,
  ['>='] = operator.ge,
  ['~='] = operator.ne,
  ['!='] = operator.ne,
  ['=='] = operator.eq,
  ['!' ] = operator.lnot,
  ['&&'] = operator.land,
  ['||'] = operator.lor,
  ['!!'] = operator.lbool,
}

local function toboolean (str)
  if str == 'true' then
    return true
  elseif str == 'false' then
    return false
  else
    return nil
  end
end

-- utilities ------------------------------------------------------------------o

local utility = {}

-- pause, sleep

ffi.cdef[[
void Sleep(int ms);
int poll(struct pollfd *fds, unsigned long nfds, int timeout);
]]

local sleep

if ffi.os == "Windows"
then sleep = \s -> ffi.C.Sleep(s)
else sleep = \s -> ffi.C.poll(nil, 0, s)
end

function utility.pause (val)
  if is_number(val) then return sleep(val) end
  if val then
    assert(is_string(val), "invalid argument #1 (string expected)")
    io.write("press return to continue or type '"..val.."' to exit... ")
  else
    io.write("press return to continue... ")
  end
  local str = assert(io.read())
  if str == val then os.exit() end
end

-- repeater

local _repx, _repn = {}, {}

local rep_it = \s,i => if i < s[_repn] then return i+1, s[_repx] end end
local rep_mt = set_concept({
  __len      = \s   -> s[_repn],
  __index    = \s,i => if 1 <= i and i <= s[_repn] then return s[_repx] end end,
  __ipairs   = \s   -> (rep_it, s, 0),
  __tostring = \s   -> string.format("repeater: %p", s)
}, not_mappable + not_extendable + not_mutable)

function utility.rep (x, n_) -- repeater
  return setmetatable({[_repx]=x, [_repn]=n_ or 2^30}, rep_mt)
end

-- run once

local runonce_ = setmetatable({}, {__mode='k'})

function utility.runonce (f, ...)
  if runonce_[f] ~= true then
    assert(is_callable(f), "invalid argument #1 (callable expected)")
    runonce_[f]=true
    return f(...)
  end
end

-- iterator: pairs = ipairs + kpairs

local function kpairs_iter (tbl, key)
  local k, v = key
  repeat k, v = tbl.nxt(tbl.dat, k)                -- discard ipairs indexes
  until type(k) ~= 'number' or (k%1) ~= 0 or k > tbl.lst or k < 1
  return k, v
end

function utility.kpairs (tbl, lst_)
  assert(is_mappable(tbl), "invalid argument #1 (mappable expected)")
  local nxt, dat, ini = pairs(tbl)
  local lst = lst_
  if not lst and is_iterable(tbl) then
    for i in ipairs(tbl) do lst = i end
  end
  if not lst then return nxt, dat, ini end
  return kpairs_iter, { nxt=nxt, dat=dat, lst=lst }, ini
end

-- key/indexes set

local kpairs in utility

function utility.clearkeys (a, p_)
  assert(is_mappable(a), "invalid argument #1 (mappable expected)")
  if not p_ then
    for k in kpairs(a) do a[k] = nil end
  else
    assert(is_callable(p_), "invalid argument #2 (callable expected)")
    for k in kpairs(a) do if p_(k) == true then a[k] = nil end end
  end
  return a
end

function utility.clearidxs (a, i_, j_)
  assert(is_iterable(a), "invalid argument #1 (iterable expected)")
  i_, j_ = i_ or 1, j_ or #a
  assert(is_integer(i_)  , "invalid argument #2 (integer expected)")
  assert(is_integer(j_)  , "invalid argument #3 (integer expected)")
  for i=i_,j_ do a[i] = nil end
  return a
end

function utility.setkeys (a, k_, i_, j_)
  if is_number(k_) and is_nil(j_) then
    k_, i_, j_ = nil, k_, i_  -- right shift
  end
  k_ = k_ or a
  assert(is_iterable(a ), "invalid argument #1 (iterable expected)")
  assert(is_iterable(k_), "invalid argument #2 (iterable expected)")
  i_, j_ = i_ or 1, j_ or #a
  assert(is_integer(i_)   , "invalid argument #3 (integer expected)")
  assert(is_integer(j_)   , "invalid argument #4 (integer expected)")
  for i=i_,j_ do a[k_[i-i_+1]] = a[i] end
  return a
end

function utility.setidxs (a, k, i_, j_)
  assert(is_iterable(a), "invalid argument #1 (iterable expected)")
  assert(is_iterable(k), "invalid argument #2 (iterable expected)")
  i_, j_ = i_ or 1, j_ or #a
  assert(is_integer(i_)  , "invalid argument #3 (integer expected)")
  assert(is_integer(j_)  , "invalid argument #4 (integer expected)")
  for i=i_,j_ do a[i] = a[k[i-i_+1]] end
  return a
end

function utility.countkeys (a)
  assert(is_mappable(a), "invalid argument #1 (mappable expected)")
  local n = 0
  for _ in pairs(a) do n = n+1 end
  return n
end

-- files

local filemode = { -- see fopen in ISO/IEC 9899:2011 7.21.5.3 (C11 standard)
  ['r'  ]='r', ['w'  ]='w', ['wx'  ]='w', ['a'  ]='w',
  ['r+' ]='w', ['w+' ]='w', ['w+x' ]='w', ['a+' ]='w',
  ['rb' ]='r', ['wb' ]='w', ['wbx' ]='w', ['ab' ]='w',
  ['r+b']='w', ['w+b']='w', ['w+bx']='w', ['a+b']='w',
  ['rb+']='w', ['wb+']='w', ['wb+x']='w', ['ab+']='w',
}

function utility.openfile (fname_, mode_, ext_)
  if filemode[fname_] and is_nil(ext_) then
    fname_, mode_, ext_ = nil, fname_, mode_ -- right shift
  end
  if is_string(mode_) and not filemode[mode_] and is_nil(ext_) then
    mode_, ext_ = nil, mode_                 -- right shift
  end

  assert(is_nil(mode_) or filemode[mode_], "invalid argument #2 (file mode expected)")
  assert(is_nil(ext_ ) or is_string(ext_), "invalid argument #3 (string expected)")

  local file
  if is_string(fname_) then
    if ext_ and #ext_ > 0 and string.sub(fname_,-#ext_) ~= ext_ then
      fname_ = fname_ .. ext_ -- e.g. '.tfs', '.dat', '.mad', etc...
    end
    file = assert(io.open(fname_, mode_ or 'r'))
    assert(io.type(file) == 'file', "invalid argument #1 (unable to open file)")
  else
    file = fname_ or filemode[mode_] == 'w' and io.stdout or io.stdin
    assert(io.type(file) == 'file', "invalid argument #1 (open file expected)")
  end
  return file
end

function utility.fileexists (fname)
  assert(is_string(fname), "invalid argument #1 (string expected)")
  local file = io.open(fname)
  if is_nil(file) then return false end
  io.close(file)
  return true
end

-- string formating

function utility.printf (str, ...)
  return io.write(str:format(...))
end

function utility.fprintf (fp, str, ...)
  return fp:write(str:format(...))
end

function utility.errorf (str, ...)
  error(str:format(...), 2)
end

function utility.assertf (cond, str, ...)
  if not cond then error(str:format(...), 2) end
  return cond
end

getmetatable(io.stdout).printf = utility.fprintf

-- table copy

function utility.tblicpy (a, mt_, na_)
  if is_table(mt_) and is_nil(na_) then
    mt_, na_ = nil, mt_ -- right shift
  end
  local na = na_ or table.new(#a, 0)
  for i,v in ipairs(a) do na[i] = v end -- shallow copy
  if mt_ == true then setmetatable(na, getmetatable(a)) end
  return na
end

function utility.tblcpy (a, mt_, na_)
  if is_table(mt_) and is_nil(na_) then
    mt_, na_ = nil, mt_ -- right shift
  end
  local na = na_ or table.new(#a, 1)
  for k,v in pairs(a) do na[k] = v end -- shallow copy
  if mt_ == true then setmetatable(na, getmetatable(a)) end
  return na
end

function utility.tbldeepcpy (a, mt_, xr_, na_)
  local na = na_ or table.new(#a, 1)
  xr_ = xr_ or {}
  xr_[a] = na
  for k,v in pairs(a) do -- deep copy, keep track of self-xref
    na[xr_[k] or k] = xr_[v] or utility.copy(v, mt_, xr_)
  end
  if mt_ == true then setmetatable(na, getmetatable(a)) end
  return na
end

-- table concat

function utility.tblcat (a, b, mt_, c_)
  if is_table(mt_) and is_nil(c_) then
    mt_, c_ = nil, mt_ -- right shift
  end
  local c = c_ or table.new(#a + #b, 1)
  local k = 0
  for i,v in ipairs(a) do c[  i], k = v, i end -- shallow copy
  for i,v in ipairs(b) do c[k+i]    = v    end -- shallow copy
  if mt_ == true then
    setmetatable(c, getmetatable(a) or getmetatable(b))
  end
  return c
end

-- extensions (conversion, factory)

local tostring_ -- forward ref

function utility.num2str (a)
  return string.format(option.format, a)
end

function utility.tbl2str (tbl, sep_)
  assert(is_mappable(tbl), "invalid argument #1 (mappable expected)")
  if is_emptytable(tbl) then return '{}' end
  local r = {}
  for i,v in ipairs(tbl) do
    r[i] = tostring_(v)
  end
  local ir = #r+1
  for k,v in kpairs(tbl) do
    r[ir], ir = '['..tostring_(k)..']='..tostring_(v), ir+1
  end
  return '{'..table.concat(r, sep_ or ', ')..'}'
end

function utility.str2tbl (str, match_, ini_)
  assert(is_string(str), "invalid argument #1 (string expected)")
  if is_string(match_) then
    local r, n = {}, 0
    for s in string.gmatch(str, match_, ini_) do
      r[n+1], n = s, n+1
    end
    return r, n
  else
    return {str}, 1
  end
end

function tostring_ (a, ...)      -- to review
  if     is_string(a)     then return a
  elseif is_value(a)      then return (tostring(a))
  elseif is_stringable(a) then return (get_metamethod(a,'__tostring')(a, ...))
  elseif is_mappable(a)   then return  utility.tbl2str(a,...) -- table.concat
  else                         return (tostring(a)) -- builtin tail call...
  end
end

local function totable_ (a, ...) -- to review
  if     is_table(a)      then return a
  elseif is_value(a)      then return {a}
  elseif is_tablable(a)   then return get_metamethod(a,'__totable')(a, ...)
  elseif is_iterable(a)   then return totable(iter(a,...)) -- iterator from lfun
  else                         return {a}
  end
end

function utility.same (a, ...)   -- to review
  if     is_value(a)      then return a
  elseif is_sameable(a)   then return get_metamethod(a,'__same')(a, ...)
  elseif is_table(a)      then return setmetatable({}, getmetatable(a))
  else                         return a -- safe? should try more complex copy?
  end
end

function utility.copy (a, ...)   -- to review
  if     is_value(a)      then return a
  elseif is_copiable(a)   then return get_metamethod(a,'__copy')(a, ...)
  elseif is_table(a)      then return utility.tbldeepcpy(a, ...)
  else                         return a -- safe? should try more complex copy?
  end
end

-- string interpolation

local function interp_fun (arg, tag)
  local key = tag:sub( 3,-2)
  if key == '' then return '$' end -- ${} -> $
  local lst = key:sub(-1,-1)
  if lst == '-' or lst == '+' or lst == '=' then -- policy
    key = key:sub(1,-2)
  else
    lst = nil
  end
  local sub = tonumber(key) or (key:gsub('%$%b{}', arg.fun))
  local val = arg.var[sub]
  if is_nil(val) then
    if (not lst and arg.policy) == '=' then
      return key ~= sub and string.format("${%s}",sub) or nil   -- unchanged
    elseif (lst or  arg.policy) == '-' then
      return ''                                                 -- removed
    elseif (lst or  arg.policy) == '+' then
      error(string.format("Undefined key: '%s'", sub), 2)       -- substituted!
    else
      error(string.format("Invalid policy: '%s'", lst or arg.policy), 2)
    end
  end
  return tostring(val)
end

local bind1st in MAD.gfunc

function utility.strinterp (str, var, policy_)
  policy_ = policy_ or '+'   -- valid policy: [+-=] (see interp_fun)
  assert(is_string  (str)  , "invalid argument #1 (string expected)")
  assert(is_mappable(var)  , "invalid argument #2 (mappable expected)")
  assert(is_string(policy_), "invalid argument #3 (string expected)")
  local arg = { var=var, policy=policy_} ; arg.fun = bind1st(interp_fun, arg)
  return (str:gsub('%$%b{}', arg.fun))
end

getmetatable("").__mod = utility.strinterp

-- strings fast specialized manipulation

local sarg = ffi.new 'ssz_t[6]'

local function tostr (str, ptr, sarg, escq_)
      if sarg[1] == 0    then str = ''  -- empty
  elseif sarg[1] == #str then           -- unchanged
  else str = ffi.string(ptr+sarg[0], sarg[1])
  end
  if escq_ and sarg[4] > 0 then -- remove escaped quotes
    local cnt ; str, cnt = str:gsub('\\"', '"')
    if cnt ~= sarg[4] then
      error("unexpected escaped quote outside quoted string", 2)
    end
  end
  return str
end

local function qsplit (str, seps, sarg)                          -- sarg_in: [0]=ini, [1]=len, [2]=#seps
  local len, lsep = #str, sarg[2]
  local ptr = _C.mad_str_split(str, sarg, seps)                  -- scan for seps
  local ini, qcnt = sarg[0], 0                                   -- backup ini, esc quotes
  while sarg[2] >= 0 and sarg[3] < 2 do                          -- sep is a quote
    sarg[0], sarg[1] = sarg[2], len-sarg[2]                      -- sarg_in: [0]=ini, [1]=len
    local qptr = _C.mad_str_quote(str, sarg)                     -- scan for quotes
    assert(qptr ~= nil, "invalid pair of quotes")
    qcnt = qcnt + sarg[4]                                        -- count esc quotes
    sarg[0], sarg[1], sarg[2] = sarg[2]+1, len-(sarg[2]+1), lsep -- sarg_in: [0]=ini, [1]=len, [2]=#seps
    _C.mad_str_split(str, sarg, seps)                            -- scan for seps
  end
  sarg[0], sarg[1], sarg[4] = ini, sarg[0]+sarg[1]-ini, qcnt     -- adjust length and esc quotes
  return ptr
end

function utility.strtrim (str, ini_) -- remove leading and trailing spaces
  ini_ = ini_ or 1
  assert(is_string(str ), "invalid argument #1 (string expected)")
  assert(is_number(ini_), "invalid argument #2 (number expected)")
  sarg[0], sarg[1] = ini_-1, #str-(ini_-1)                     -- sarg_in: [0]=ini, [1]=len
  local ptr = _C.mad_str_trim(str, sarg)                       -- [0]: index  of str (trimmed)
  -- trimmed str, length                                       -- [1]: length of str (trimmed)
  return tostr(str, ptr, sarg), sarg[1]
end

function utility.strnum (str, ini_) -- parse number
  ini_ = ini_ or 1
  assert(is_string(str ), "invalid argument #1 (string expected)")
  assert(is_number(ini_), "invalid argument #2 (number expected)")
  sarg[0], sarg[1] = ini_-1, #str-(ini_-1)                     -- sarg_in: [0]=ini, [1]=len
  local ptr = _C.mad_str_num(str, sarg)                        -- [0]: index  of str (trimmed)
  -- number str, length, index of char closing num             -- [1]: length of num ([1]=[2]-[0])
  return tostr(str, ptr, sarg), sarg[1], sarg[2]+1             -- [2]: index  of closing char or -1
end                                                            -- [3]: index  of decimal  '.' or -1
                                                               -- [4]: index  of exponent 'e' or -1
function utility.strquote (str, ini_) -- remove surrounding quotes (if any)
  ini_ = ini_ or 1
  assert(is_string(str ), "invalid argument #1 (string expected)")
  assert(is_number(ini_), "invalid argument #2 (number expected)")
  sarg[0], sarg[1] = ini_-1,  #str-(ini_-1)                    -- sarg: [0]=ini, [1]=len
  local ptr = _C.mad_str_quote(str, sarg)                      -- [0]: index  of str (trimmed)
  assert(ptr ~= nil, "invalid pair of quotes")                 -- [1]: length of str
  -- unquoted str, index of closing quote or 0, type of quotes -- [2]: index  of closing quote or -1
  return tostr(str, ptr, sarg, true), sarg[2]+1, sarg[3]       -- [3]: type   of quotes 0: none, 1: "", 2: ''
end                                                            -- [4]: number of escaped quotes

function utility.strsplit (str, seps, ini_) -- split at seps (if any)
  ini_ = ini_ or 1
  assert(is_string(str ), "invalid argument #1 (string expected)")
  assert(is_string(seps), "invalid argument #2 (string expected)")
  assert(is_number(ini_), "invalid argument #3 (number expected)")
  sarg[0], sarg[1], sarg[2] = ini_-1, #str-(ini_-1), #seps     -- sarg_in: [0]=ini, [1]=len, [2]=#seps
  local ptr = _C.mad_str_split(str, sarg, seps)                -- [0]: index  of str (trimmed)
  -- trimmed str, index of sep or 0, index of sep in seps or 0 -- [1]: length of str (trimmed if sep)
  return tostr(str, ptr, sarg), sarg[2]+1, sarg[3]+1           -- [2]: index  of sep or -1
end                                                            -- [3]: index  of sep in seps or -1

function utility.strqsplit (str, seps, ini_) -- split at seps (if any outside quoted strings)
  ini_ = ini_ or 1
  assert(is_string(str ), "invalid argument #1 (string expected)")
  assert(is_string(seps), "invalid argument #2 (string expected)")
  assert(is_number(ini_), "invalid argument #3 (number expected)")
  seps = '"'.."'"..seps                                        -- add quotes to seps
  sarg[0], sarg[1], sarg[2] = ini_-1, #str-(ini_-1), #seps     -- sarg_in: [0]=ini, [1]=len, [2]=#seps
  local ptr = qsplit(str, seps, sarg)                          -- [0]: index  of str (trimmed)
  -- trimmed str, index of sep or 0, index of sep in seps or 0 -- [1]: length of str (trimmed if sep)
  return tostr(str, ptr, sarg), sarg[2]+1, sarg[3]+1           -- [2]: index  of sep or -1
end                                                            -- [3]: index  of sep in seps or -1
                                                               -- [4]: number of escaped quotes
function utility.strsplitall (str, seps, ini_, res_)
  ini_, res_ = ini_ or 1, res_ or {}
  assert(is_string  (str ), "invalid argument #1 (string expected)")
  assert(is_string  (seps), "invalid argument #2 (string expected)")
  assert(is_number  (ini_), "invalid argument #3 (number expected)")
  assert(is_iterable(res_), "invalid argument #4 (iterable expected)")
  seps = '"'.."'"..seps                            -- add quotes to seps
  local len, lsep, ns = #str, #seps, 0
  sarg[0], sarg[1] = ini_-1, len-(ini_-1)          -- sarg_in: [0]=ini, [1]=len
  _C.mad_str_trim(str, sarg)
  if sarg[1] == 0 then return res_, 0 end
  while true do
    sarg[2], ns = lsep, ns+1                       -- see strqsplit above
    local ptr = qsplit(str, seps, sarg)            -- sarg_in: [0]=ini, [1]=len, [2]=#seps
    res_[ns] = tostr(str, ptr, sarg)               -- process esc quotes
    if sarg[2] == -1 then return res_, ns end      -- no more sep
    sarg[0], sarg[1] = sarg[2]+1, len-(sarg[2]+1)  -- sarg_in: [0]=ini, [1]=len
    _C.mad_str_trim(str, sarg)
  end
  error("unexpected error in utility.strsplitall")
end

function utility.strbracket (str, ini_) -- split name[cnt] or name{cnt} (if any)
  ini_ = ini_ or 1
  assert(is_string(str ), "invalid argument #1 (string expected)")
  assert(is_number(ini_), "invalid argument #2 (number expected)")
  sarg[0], sarg[1] = ini_-1, #str-(ini_-1)       -- sarg_in: [0]=ini, [1]=len
  local ptr = _C.mad_str_bracket(str, sarg)      -- [0]: index  of name (trimmed)
  assert(ptr ~= nil, "invalid pair of brackets") -- [1]: length of name (trimmed if brackets)
  local cnt                                      -- [2]: index  of closing bracket or -1
  if sarg[2] > 0 then                            -- [3]: index  of count (trimmed)
    if sarg[4] == 0                              -- [4]: length of count (trimmed)
    then cnt = '' -- empty                       -- [5]: type   of brackets 0: none, 1: [], 2: {}
    else cnt = ffi.string(ptr+sarg[3], sarg[4])
    end
  end
  -- trimmed name, trimmed count, index of closing bracket or 0, type of brackets
  return tostr(str, ptr, sarg), cnt, sarg[2]+1, sarg[5]
end

-- searching

function utility.bsearch (tbl, val, cmp_, low_, high_)
  assert(is_iterable(tbl), "invalid argument #1 (iterable expected)")
  if is_number(cmp_) and is_nil(high_) then
    cmp_, low_, high_ = nil, cmp_, low_ -- right shift
  end
  if not (is_nil(cmp_) or is_callable(cmp_)) then
    error("invalid argument #3 (callable expected)")
  end
  local cmp  = cmp_ or operator.lt -- cmp must be the same used by table.sort
  local low  = is_number(low_ ) and max(low_ , 1   ) or 1
  local high = is_number(high_) and min(high_, #tbl) or #tbl
  local cnt, mid, stp, tst = high-low+1
  while cnt > 0 do
    stp = rshift(cnt,1)
    mid = low+stp
    tst = cmp(tbl[mid], val)
    low = tst and mid+1 or low
    cnt = tst and rshift(cnt-1,1) or stp
  end
  return low -- tbl[low] <= val
end

function utility.lsearch (tbl, val, equ_, low_, high_)
  assert(is_iterable(tbl), "invalid argument #1 (iterable expected)")
  if is_number(equ_) and is_nil(high_) then
    equ_, low_, high_ = nil, equ_, low_ -- right shift
  end
  if not (is_nil(equ_) or is_callable(equ_)) then
    error("invalid argument #3 (callable expected)")
  end
  local equ  = equ_ or operator.eq
  local low  = is_number(low_ ) and max(low_ , 1   ) or 1
  local high = is_number(high_) and min(high_, #tbl) or #tbl
  for idx=low,high do
    if equ(tbl[idx], val) == true then return idx end
  end
  return nil
end

-- end ------------------------------------------------------------------------o
return {
  operator  = wprotect(operator),
  utility   = wprotect(utility),
  totable   = totable_,
  tostring  = tostring_,
  toboolean = toboolean,
}
