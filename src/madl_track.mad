--[=[
 o-----------------------------------------------------------------------------o
 |
 | Track module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local is_sequence, is_beam, is_boolean, is_number, is_integer,
      is_table, is_implicit, is_observed, isa_damap, is_tpsa,
      is_callable, is_mappable                                  in MAD.typeid
local element, mtable, command, damap, symint                   in MAD
local fnone                                                     in MAD.gfunc
local errorf, assertf                                           in MAD.utility
local minlen                                                    in MAD.constant

local max in math

-- integrator schemes ---------------------------------------------------------o

local thinonly, thickonly                                       in MAD.symint

-- dynamic maps ---------------------------------------------------------------o

local drift, rbend_drift, quad_drift, solenoid_drift,
      polar_drift, sbend_drift, combi_drift                     in MAD.dynmap

local kick, rbend_kick, quad_kick, rfcavity_kick,
      polar_kick, sbend_kick, combi_kick                        in MAD.dynmap

local fringe, polar_fringe, solenoid_fringe                     in MAD.dynmap

local xrotation, yrotation, srotation, translate,
      changeref, changedir, changenrj                           in MAD.dynmap

-- strengths and phases -------------------------------------------------------o

local function get_mult (elm, m)
  local knl, dknl = elm.knl or {}, elm.dknl or {}
  local ksl, dksl = elm.ksl or {}, elm.dksl or {}
  local nmul = max(#knl, #ksl, #dknl, #dksl)

  if nmul >= 1 then
    for i=1,nmul do
      m.knl[i] = (knl[i] or 0) + (dknl[i] or 0)
      m.ksl[i] = (ksl[i] or 0) + (dksl[i] or 0)
    end
  else
    m.knl[1], m.ksl[1], m.knl[2] = 0, 0, 0
  end
  m.nmul = nmul
end

local function get_phas (elm, m)
  local pnl, dpnl = elm.pnl or {}, elm.dpnl or {}
  local psl, dpsl = elm.psl or {}, elm.dpsl or {}
  local npha = max(#pnl, #psl, #dpnl, #dpsl)

  for i=1,npha do
    m.pnl[i] = (pnl[i] or 0) + (dpnl[i] or 0)
    m.psl[i] = (psl[i] or 0) + (dpsl[i] or 0)
  end
  m.npha = npha
end

-- sub element tracking -------------------------------------------------------o

local function subtrack_drift (elm, mflw)
  error("NYI")
end

local function subtrack_thick (elm, mflw)
  error("NYI")
end

-- kinds ----------------------------------------------------------------------o

local function track_thin (elm, mflw)
  get_mult (elm, mflw)
  if mflw.nmul == 0 then return end

  local sdir in mflw

  changeref(elm, mflw,  sdir)
   thinonly(elm, mflw,   1  , nil, kick)
  changeref(elm, mflw, -sdir)
end

local function track_drift (elm, mflw)
  if #elm ~= 0 then subtrack_drift(elm, mflw) end

  local sdir in mflw

  changeref(elm, mflw,  sdir)
  thickonly(elm, mflw,   1  , drift, nil)
  changeref(elm, mflw, -sdir)
end

local function track_thick (elm, mflw)
  if #elm ~= 0 then subtrack_thick(elm, mflw) end

  get_mult(elm, mflw)
  if mflw.nmul == 0 then return end

  local sdir   in mflw
  local method in elm
  local integr = method and symint[method] or mflw.integr

  changeref(elm, mflw,  sdir)
--   fringe(elm, mflw,  sdir)
     integr(elm, mflw,   1  , drift, kick)
--   fringe(elm, mflw, -sdir)
  changeref(elm, mflw, -sdir)
end

local function track_sbend (elm, mflw)
  -- sbend_drift, polar_kick, sbend_fringe
end

local function track_combined (elm, mflw)
  -- combined_drift, combined_kick, sbend_fringe
end

local function track_rbend (elm, mflw)
  -- rbend_drift, rfcavity_kick, straight_fringe
end

local function track_quadrupole (elm, mflw)
  -- quad_drift, quad_kick, straight_fringe
end

local function track_solenoid (elm, mflw)
  -- solenoid_drift, rfcavity_kick, solenoid_fringe
end

local function track_rfcavity (elm, mflw)
  -- solenoid_drift, rfcavity_kick, rfcavity_fringe
end

local function track_twcavity (elm, mflw)
  -- twcavity_drift, twcavity_kick, twcavity_fringe
end

-- load maps into elements ----------------------------------------------------o

local invalid_track = \e ->
  errorf("invalid element %s of kind %s with length %s", e.name, e.kind, e.l)

local E = element

-- kind maps

E. thin_element :set_functors { track = track_thin  }
E.drift_element :set_functors { track = track_drift }
E.thick_element :set_functors { track = track_thick }
E.extra_element :set_functors { track = invalid }

-- specialized maps

-- E.sbend      :set_functors { track = track_sbend      } -- polar   , k0
-- E.combined   :set_functors { track = track_combined   } -- polar   , k0+k1
-- E.rbend      :set_functors { track = track_rbend      } -- straight, k0
-- E.quadrupole :set_functors { track = track_quadrupole } -- straight, k0+k1
-- E.solenoid   :set_functors { track = track_solenoid   } -- straight, ks+ksi
-- E.rfcavity   :set_functors { track = track_rfcavity   }
-- E.twcavity   :set_functors { track = track_twcavity   }

-- special maps

E.patch     :set_functors { track = invalid   }
E.special   :set_functors { track = fnone     }
E.xrotation :set_functors { track = xrotation }
E.yrotation :set_functors { track = yrotation }
E.srotation :set_functors { track = srotation }
E.translate :set_functors { track = translate }
E.changeref :set_functors { track = changeref }
E.changedir :set_functors { track = changedir }
E.changenrj :set_functors { track = changenrj }

-- track mtable ---------------------------------------------------------------o

local function save_all (elm, mflw, lw_)
  local name, kind, l in elm
  local npar, sdir, tdir, spos, mtbl, atfill, mapsave in mflw
  local lw = lw_ or 1

  -- keep order!
  for i=1,npar do
    local x, px, y, py, t, pt in mflw[i]
    local damap
    if is_tpsa(x) then
      x,px,y,py,t,pt = x:get0(),px:get0(),y:get0(),py:get0(),t:get0(),pt:get0()
      damap = mapsave and mflw[i]:copy()
    end
    mtbl = mtbl + { name, kind, spos, l*lw*sdir, x, px, y, py, t, pt, tdir, i, damap }
  end
  atfill(elm, mflw, lw)
end

local function save_imp (elm, mflw, lw_)
  if is_implicit(elm) then else save_all(elm, mflw, lw_) end
end

local function save_obs (elm, mflw, lw_)
  if is_observed(elm) then      save_all(elm, mflw, lw_) end
end

local function make_mtable (self)
  local range, nturn, sdir, implicit, title, mapsave in self
  local sequ = self.sequence
  local nrow = sequ:length_of(range, nturn)*(implicit and 2 or 1)

  -- keep order!
  return mtable 'track' {
    type='track', title=title or sequ.name, sdir=sdir, reserve=nrow,
    {'name'}, 'kind', 's', 'l', 'x', 'px', 'y', 'py', 't', 'pt',
    'tdir',                    -- t-direction of the tracking: sdir * seqdir
    'id',                      -- particle or damap id
    mapsave and 'damap' or nil -- extra optional column to save the entire damap
  }
end

-- track mflow ----------------------------------------------------------------o

local _id = {} -- identity

local function make_mflow (self)
  if self.mflow then
    assert(self.mflow.__trck == _id, "invalid mflow (track mflow expected)")
    return self.mflow
  end

  -- check sequence
  local sequ = assert(self.sequence, "missing sequence")
  assert(is_sequence(sequ), "invalid sequence")

  -- check beam
  local beam = assert(self.beam, "missing beam")
  assert(is_beam(beam), "invalid beam")

  -- build iterator
  local range, sdir, nturn in self
  local iter, state, init = sequ:siter(range, nturn, sdir)

  -- build mtable
  local save, nofill, observe, implicit in self
  assert(is_boolean(save) or is_callable(save),
                               "invalid save (boolean or callable expected)")
  assert(is_boolean(nofill)  , "invalid nofill (boolean expected)")
  assert(is_boolean(observe) , "invalid observe (boolean expected)")
  assert(is_boolean(implicit), "invalid implicit (boolean expected)")

  -- saving data
  local mtbl, fill
  if save then
    mtbl = make_mtable(self)
    fill = is_callable(save) and save     or -- precedence matters!
           observe  == true  and save_obs or
           implicit == false and save_imp or save_all
  else
    fill = fnone
  end

  -- time direction
  local tdir = sdir*sequ.dir
  assert(tdir == 1 or tdir == -1, "invalid time direction (1 or -1 expected)")

  -- totalpath
  local totalpath in self
  assert(is_boolean(totalpath), "invalid totalpath (boolean expected)")
  local T = totalpath and 1 or 0

  -- method
  local method in self
  local integr = symint[method]
  assertf(is_callable(integr), "invalid integration method '%s'", method)

  -- setup default sclicing
  local nslice in self
  assert(is_integer(nslice) and nslice > 0, "invalid nslice (positive integer expected)")

  -- retrieve default actions (avoid evaluation in case of functions)
  local atentry = self:var_raw('atentry') or fnone
  local atslice = self:var_raw('atslice') or fnone
  local atexit  = self:var_raw('atexit' ) or fnone
  local atfill  = self:var_raw('atexit' ) or fnone
  assert(is_callable(atentry), "invalid atentry (callable expected)")
  assert(is_callable(atslice), "invalid atslice (callable expected)")
  assert(is_callable(atexit ), "invalid atexit (callable expected)")
  assert(is_callable(atfill ), "invalid atfill (callable expected)")

  -- retrieve initial conditions
  local s0, X0, mapdef, mapsave in self
  assert(is_number  (s0), "invalid s0 (number expected)")
  assert(is_mappable(X0), "invalid X0 (mappable expected)")
  if not is_mappable(X0[1]) then X0 = {X0} end

  -- precedence of initial conditions
  local npar = #X0
  local mflw = table.new(npar,50)

  for i=1,npar do
    mflw[i] = X0[i] -- default is to reuse!

    if isa_damap(X0[i]) then -- damap are mappable (i.e. must be first)
      mflw[i].id = X0[i].id or i
    elseif is_mappable(X0[i]) then -- access by indexes first for vectors
      local id =             X0[i].id or i
      local x  = X0[i][1] or X0[i].x  or 0
      local px = X0[i][2] or X0[i].px or 0
      local y  = X0[i][3] or X0[i].y  or 0
      local py = X0[i][4] or X0[i].py or 0
      local t  = X0[i][5] or X0[i].t  or 0
      local pt = X0[i][6] or X0[i].pt or 0
      if mapdef then            -- replace: damap required from coordinates
        mflw[i] = damap(mapdef == true and {} or mapdef)
      end
      if is_table(mflw[i]) then -- reuse: damaps are tables
        mflw[i].id,
        mflw[i].x, mflw[i].px,
        mflw[i].y, mflw[i].py,
        mflw[i].t, mflw[i].pt = id, x, px, y, py, t, pt
      else                      -- replace: need a table for key access (e.g. vector)
        mflw[i] = {id=id, x=x, px=px, y=y, py=py, t=t, pt=pt ; pz=0}
      end
    else
      error("invalid type of item at id="..i.." (coordinates or damap expected)")
    end
  end

  -- complete mflow

  mflw.beam=beam                  -- current beam
  mflw.sequ=sequ                  -- current sequence
  mflw.mtbl=mtbl                  -- current mtable (nil if no save)
  mflw.sdir=sdir                  -- s-direction of tracking
  mflw.tdir=tdir                  -- t-direction of tracking

  mflw.integr=integr              -- default integrator
  mflw.totalpath=totalpath        -- t is the totalpath
  mflw.T=T                        -- cancel compensation for time of flight

  mflw.fill=fill                  -- fill/add one row to mtable (if any)
  mflw.nofill=nofill              -- disable filling at the end of an element
  mflw.nslice=nslice              -- number of slice for each element

  mflw.mapdef=mapdef              -- save damap definitions (for info)
  mflw.mapsave=mapsave            -- save entire damaps

  mflw.s0=s0                      -- initial s-position
  mflw.idx=init                   -- index of the current element
  mflw.spos=s0                    -- s-position of the current element entry
  mflw.npos=nil                   -- integrator step: nil, 'first', 'last'
  mflw.npar=npar                  -- number of particles or damaps: #mflw

  mflw.atentry=atentry            -- action when entering an element
  mflw.atslice=atslice            -- action after each element slices
  mflw.atexit =atexit             -- action when exiting an element
  mflw.atfill =atfill             -- action when filling a mtable row

    -- for processing elements
  mflw.nmul=0                     -- current element number of multipoles
  mflw.knl=table.new(15,0)        -- current element multipoles
  mflw.ksl=table.new(15,0)        -- current element multipoles skew
  mflw.npha=0                     -- current element number of multiplole phases
  mflw.pnl=table.new(15,0)        -- current element multipoles phases
  mflw.psl=table.new(15,0)        -- current element multipoles shew phases

    -- for processing subelements
  mflw.selm=table.new(4,0)        -- subelement pre-allocated stack

    -- internal vars for track
  mflw.__trckitr={iter=iter, state=state} -- iterator and iteraror state
  mflw.__trck=_id

  return mflw
end

-- track command --------------------------------------------------------------o

local function exec (self)
  -- build mflow
  local mflw = make_mflow(self)

  -- check number of element to track
  local nstep in self
  if nstep == 0 then return mflw.mtbl, mflw end

  -- retrieve information
  local s0, sdir, idx, mtbl, fill, nofill, atentry, atexit in mflw
  local iter, state in mflw.__trckitr

  -- disable fill locally
  if nofill ~= false then fill = fnone end

  -- dynamic tracking
  for i,elm,spos in iter, state, idx do
    mflw.idx, mflw.spos = i, s0+spos
    atentry(elm, mflw)
    elm:track   (mflw)
    mflw.spos = s0+spos + elm.l*sdir
    atexit (elm, mflw)
    fill   (elm, mflw)

    -- check remaining number of element to track
    nstep = nstep-1
    if nstep == 0 then return mtbl, mflw, elm end
  end

  return mtbl, mflw
end

local _na -- not applicable (see survey or twiss)

local track = command 'track' {
  beam=nil,         -- beam (required)                                    (mflw)
  sequence=nil,     -- sequence (required)                                (mflw)
  range=nil,        -- range of tracking                                  (iter)
  title=nil,        -- title of mtable                                    (mtbl)
  sdir=1,           -- s-direction of tracking (1 or -1)                  (mflw)

  s0=0,             -- initial s                                          (mflw)
  X0={0,0,0,0,0,0}, -- initial coordinates (or damap, or list of)         (mflw)

  mapdef=false,     -- setup for damap                                    (mflw)
  mapsave=false,    -- save damap in the mtable                           (mflw)

  nturn=1,          -- number of turns                                    (iter)
  nstep=-1,         -- number of elements to track                        (iter)
  nslice=1,         -- number of slice for each element                   (mflw)
  method='simple',  -- method for integration                             (mflw)
  totalpath=false,  -- 't' is the totalpath                               (mflw)

  save=true,        -- create mtable and set fill to save data            (mtbl)
  nofill=false,     -- disable filling at the end of an element           (mflw)
  observe=false,    -- save only observed elements                        (mtbl)
  implicit=true,    -- save also implicit elements                        (mtbl)

  atentry=nil,      -- action to call when entering an element            (mflw)
  atslice=nil,      -- action to call after each element slices           (mflw)
  atexit=nil,       -- action to call when exiting an element             (mflw)
  atfill=nil,       -- action to call when filling a mtable row           (mflw)

  mflow=nil,      -- current mflow, exclusive with other attributes except nstep

  exec=exec,      -- command to execute upon children creation
} :set_readonly() -- reference track command is readonly

-- end ------------------------------------------------------------------------o
return { track = track }
