--[=[
 o-----------------------------------------------------------------------------o
 |
 | Matrix module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provides full set of functions and operations on real and complex matrices.
  - Vectors are column oriented matrices, i.e. implemented as [n x 1] matrices.

 o-----------------------------------------------------------------------------o
]=]

local MR, MC = {}, {}

-- locals ---------------------------------------------------------------------o

local ffi = require 'ffi'
local istype in ffi

local _C, tostring, complex, tocomplex in MAD

local is_nil, is_boolean, is_number, is_string, is_table,
      is_complex, is_scalar, is_callable, is_iterable,
      has_method                                                 in MAD.typeid
local ident, swap, compose, bind1st                              in MAD.gfunc
local random, carg, real, imag, conj, norm, proj, rect, polar,
      ceil, floor, frac, trunc, round, abs, exp, log, log10, sqrt,
      sin, cos, tan, sinh, cosh, tanh, asin, acos, atan, asinh,
      acosh, atanh, erf, tgamma, lgamma, min, max,
      sumsqr, sumabs, minabs, maxabs                             in MAD.gmath
local unm, add, mul, mod, pow, lbool, lnot, land, lor, opstr     in MAD.operator
local rep, errorf, assertf, openfile, strsplitall, num2str       in MAD.utility
local inf, eps                                                   in MAD.constant

-- tmp for returned values
local  res = ffi.new 'double [1]'
local cres = ffi.new 'complex[1]'

-- constants
local dbl_sz = ffi.sizeof 'double'
local cpx_sz = ffi.sizeof 'complex'

-- types ----------------------------------------------------------------------o

ffi.cdef [[
struct  matrix       { const ssz_t nr, nc;       double  data[?]; };
struct cmatrix       { const ssz_t nr, nc;       complex data[?]; };

struct  matrix_cview { const ssz_t nr, nc; const double  data[?]; };
struct cmatrix_cview { const ssz_t nr, nc; const complex data[?]; };

struct  matrix_ccast {       ssz_t nr, nc;       double  data[?]; };
]]

local  matrix_ctor  = ffi.typeof 'struct  matrix'
local cmatrix_ctor  = ffi.typeof 'struct cmatrix'
local  matrix_cview = ffi.typeof 'struct  matrix_cview'
local cmatrix_cview = ffi.typeof 'struct cmatrix_cview'

local  matrix_cref  = ffi.typeof 'struct  matrix&'
local cmatrix_cref  = ffi.typeof 'struct cmatrix&'
local  matrix_cvref = ffi.typeof 'struct  matrix_cview&'
local cmatrix_cvref = ffi.typeof 'struct cmatrix_cview&'
local  matrix_ccast = ffi.typeof 'struct  matrix_ccast&'

local  matrix_size  = ffi.offsetof( matrix_ctor, 'data')
local cmatrix_size  = ffi.offsetof(cmatrix_ctor, 'data')

local is_matrix  = \x -> istype( matrix_ctor, x) or istype( matrix_cview, x)
local is_cmatrix = \x -> istype(cmatrix_ctor, x) or istype(cmatrix_cview, x)
local isa_matrix = \x -> is_matrix(x) or is_cmatrix(x)
local is_vector  = \x -> is_matrix(x)  and (x.nr == 1 or x.nc == 1)
local is_cvector = \x -> is_cmatrix(x) and (x.nr == 1 or x.nc == 1)
local isa_vector = \x -> isa_matrix(x) and (x.nr == 1 or x.nc == 1)

-- allocators -----------------------------------------------------------------o

local function matrix_alloc (nr, nc)
  local len, mat = nr*nc, nil
  if len <= _C.mad_alloc_threshold then
    mat = matrix_ctor(len) -- VLA
  else
    assert(len <= 2^30, "matrix is too large")
    local siz = matrix_size + len*dbl_sz
    mat = assert(_C.mad_calloc(1,siz), "out of memory")
    mat = ffi.gc(ffi.cast(matrix_cref, mat), _C.mad_free)
  end
  local m = ffi.cast(matrix_ccast, mat)
  m.nr, m.nc = nr, nc
  return mat
end

local function cmatrix_alloc (nr, nc)
  local len, mat = nr*nc, nil
  if len <= _C.mad_alloc_threshold/2 then
    mat = cmatrix_ctor(len) -- VLA
  else
    assert(len <= 2^29, "cmatrix is too large")
    local siz = cmatrix_size + len*cpx_sz
    mat = assert(_C.mad_calloc(1,siz), "out of memory")
    mat = ffi.gc(ffi.cast(cmatrix_cref, mat), _C.mad_free)
  end
  local m = ffi.cast(matrix_ccast, mat)
  m.nr, m.nc = nr, nc
  return mat
end

local function fromtable (ctor, tbl)
  local nr, nc = #tbl or 0, is_table(tbl[1]) and #tbl[1] or 1
  assert(nr > 0 and nc > 0, "invalid argument #1 (non-empty table expected)")
  return ctor(nr,nc):fill(tbl)
end

-- constructors ---------------------------------------------------------------o

local function matrix (nr, nc_)
  if is_table(nr) then
    return fromtable(matrix_alloc, nr)
  end
  local nc = nc_ or nr -- square
  assert(is_number(nr) and is_number(nc) and nr >= 1 and nc >= 1,
         "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)")
  return matrix_alloc(nr, nc)
end

local function cmatrix (nr, nc_)
  if is_table(nr) then
    return fromtable(cmatrix_alloc, nr)
  end
  local nc = nc_ or nr -- square
  assert(is_number(nr) and is_number(nc) and nr >= 1 and nc >= 1,
         "invalid argument #1 or #2 (nrow[,ncol] >=1 or table [of tables] expected)")
  return cmatrix_alloc(nr, nc)
end

local  vector = \n ->  matrix(n, 1)
local cvector = \n -> cmatrix(n, 1)

-- checkers -------------------------------------------------------------------o

local function chksiz (r, x, y) -- add, sub
  assert((is_nil(r) or (r.nr == x.nr and r.nc == x.nc)) and
         (is_nil(y) or (y.nr == x.nr and y.nc == x.nc)),
         "incompatible matrix sizes")
  return r
end

local function chksizm (r, x, y) -- mul
  assert((is_nil(r) or (r.nr == x.nr and r.nc == y.nc)) and x.nc == y.nr,
         "incompatible matrix sizes")
  return r
end

local function chksiztm (r, x, y) -- tmul
  assert((is_nil(r) or (r.nr == x.nc and r.nc == y.nc)) and x.nr == y.nr,
         "incompatible matrix sizes")
  return r
end

local function chksizmt (r, x, y) -- mult
  assert((is_nil(r) or (r.nr == x.nr and r.nc == y.nr)) and x.nc == y.nc,
         "incompatible matrix sizes")
  return r
end

local function chksizd (r, x, y) -- div
  assert((is_nil(r) or (r.nr == x.nr and r.nc == y.nr)) and x.nc == y.nc,
         "incompatible matrix sizes")
  return r
end

local function chksizt (r, x) -- transpose
  assert(is_nil(r) or (r.nr == x.nc and r.nc == x.nr),
         "incompatible matrix sizes")
  return r
end

-- get, set -------------------------------------------------------------------o

local idx     = \i,j,c   -> ((i-1)*c + (j-1))

local geti0   = \x,i     -> x.data[i]
local seti0   = \x,i,e   => x.data[i]=e return x end
local geti    = \x,i     -> x.data[i-1]
local seti    = \x,i,e   => x.data[i-1]=e return x end
local get0    = \x,i,j   -> x.data[ i   *x.nc +  j   ]
local set0    = \x,i,j,e => x.data[ i   *x.nc +  j   ]=e return x end
local get     = \x,i,j   -> x.data[(i-1)*x.nc + (j-1)]
local set     = \x,i,j,e => x.data[(i-1)*x.nc + (j-1)]=e return x end

local geti0_s = \x,i   -> 0 <= i and i <  x.nr*x.nc                     and geti0(x, i) or nil
local geti_s  = \x,i   -> 1 <= i and i <= x.nr*x.nc                     and geti (x, i) or nil
local get0_s  = \x,i,j -> 0 <= i and i <  x.nr and 0 <= j and j <  x.nc and get0(x,i,j) or nil
local get_s   = \x,i,j -> 1 <= i and i <= x.nr and 1 <= j and j <= x.nc and get (x,i,j) or nil

local function seti0_s (x, i, e)
  assert(0 <= i and i < x.nr*x.nc, "0-based index out of bounds")
  return seti0(x, i, e)
end

local function seti_s (x, i, e)
  assert(1 <= i and i <= x.nr*x.nc, "index out of bounds")
  return seti(x, i, e)
end

local function set0_s (x, i, j, e)
  assert(0 <= i and i < x.nr and 0 <= j and j < x.nc, "0-based index out of bounds")
  return set0(x, i, j, e)
end

local function set_s (x, i, j, e)
  assert(1 <= i and i <= x.nr and 1 <= j and j <= x.nc, "index out of bounds")
  return set(x, i, j, e)
end

-- unsafe (to remove as method!)
MR._geti0 = geti0
MR._seti0 = seti0
MR._geti  = geti
MR._seti  = seti
MR._get0  = get0
MR._set0  = set0
MR._get   = get
MR._set   = set

-- safe
MR.geti0  = geti0_s
MR.geti   = geti_s
MR.get0   = get0_s
MR.get    = get_s
MR.seti0  = seti0_s
MR.seti   = seti_s
MR.set0   = set0_s
MR.set    = set_s

-- size, same -----------------------------------------------------------------o

local nrow   = \x -> x.nr
local ncol   = \x -> x.nc
local size   = \x -> x.nr * x.nc
local sizes  = \x -> (x.nr, x.nc)
local tsizes = \x -> (x.nc, x.nr)

MR.nrow   = nrow
MR.ncol   = ncol
MR.size   = size
MR.sizes  = sizes
MR.tsizes = tsizes

-- x:same()
-- x:same(e)
-- x:same(nr,nc)
-- x:same(e,nr,nc)
-- x:same(nil,nr,nc)
-- x:same(nr) => x:same(e), i.e. wrong size

function MR.__same (x, e_, nr_, nc_) -- promote to cmatrix if e_ is a complex
  if is_nil(nc_) and is_number(e_) and is_number(nr_) then
    e_, nr_, nc_ = nil, e_, nr_  -- shift right
  end
  if is_nil(e_) or is_number(e_) then
    return  matrix(nr_ or x.nr, nc_ or x.nc)
  elseif is_complex(e_) then
    return cmatrix(nr_ or x.nr, nc_ or x.nc)
  else
    error("invalid argument #2 (nil or scalar expected)")
  end
end

function MC.__same (x, e_, nr_, nc_) -- promote to matrix if e_ is a number
  if is_nil(nc_) and is_number(e_) and is_number(nr_) then
    e_, nr_, nc_ = nil, e_, nr_  -- shift right
  end
  if is_nil(e_) or is_complex(e_) then
    return cmatrix(nr_ or x.nr, nc_ or x.nc)
  elseif is_number(e_) then
    return  matrix(nr_ or x.nr, nc_ or x.nc)
  else
    error("invalid argument #2 (nil or scalar expected)")
  end
end

-- readonly -------------------------------------------------------------------o

function MR.constview (x)
  return ffi.cast(matrix_cvref, x)
end

function MC.constview (x)
  return ffi.cast(cmatrix_cvref, x)
end

-- copy, resize ---------------------------------------------------------------o

function MR.__copy (x, y_)
  local n
  if is_nil(y_) then
    n, x, y_ = x:size(), matrix_alloc(x:sizes()), x
  else
    assert(is_matrix(y_), "invalid argument #2 (matrix expected)")
    n = min(x:size(), y_:size())
  end
  if x ~= y_ then ffi.copy(x.data, y_.data, dbl_sz*n) end
  return x
end

function MC.__copy (x, y_)
  local n
  if is_nil(y_) then
    n, x, y_ = x:size(), cmatrix_alloc(x:sizes()), x
  else
    assert(is_cmatrix(y_), "invalid argument #2 (cmatrix expected)")
    n = min(x:size(), y_:size())
  end
  if x ~= y_ then ffi.copy(x.data, y_.data, cpx_sz*n) end
  return x
end

function MR.resize (x, nr, nc)
  local y
  if is_matrix(nr)
  then x, y = nr, x
  else x, y = matrix(nr,nc), x
  end

  local nr, nc = min(x:nrow(), y:nrow()), min(x:ncol(), y:ncol())
  for i=0,nr-1 do
    ffi.copy(x.data+x.nc*i, y.data+y.nc*i, dbl_sz*nc)
  end
  return x
end

function MC.resize (x, nr, nc)
  local y
  if is_cmatrix(nr)
  then x, y = nr, x
  else x, y = cmatrix(nr,nc), x
  end

  local nr, nc = min(x:nrow(), y:nrow()), min(x:ncol(), y:ncol())
  for i=0,nr-1 do
    ffi.copy(x.data+x.nc*i, y.data+y.nc*i, cpx_sz*nc)
  end
  return x
end

-- zeros, ones, eye, symp, circ, fill, shift, reshape (in place) --------------o

function MR.zeros (x)
  ffi.fill(x.data, dbl_sz * x:size())
  return x
end

function MC.zeros (x)
  ffi.fill(x.data, cpx_sz * x:size())
  return x
end

function MR.ones (x, e_)
  local e, n = e_ or 1, x:size()
  for i=0,n-1 do seti0(x,i,e) end
  return x
end

function MR.eye (x, e_) -- zeros + diag
  x:zeros()
  local e, nr, nc = e_ or 1, x:sizes()
  local n = min(nr, nc)
  for i=0,n*nc,nc+1 do seti0(x,i,e) end
  return x
end

function MR.random (x, f_, ...) -- random
  assert(is_nil(f_) or is_callable(f_), "invalid argument #2 (callable expected)")
  local n, f = x:size(), f_ or random
  for i=0,n-1 do seti0(x,i,f(...)) end
  return x
end

function MC.random (x, f_, ...) -- random
  assert(is_nil(f_) or is_callable(f_), "invalid argument #2 (callable expected)")
  local n, f = x:size(), f_ or random
  for i=0,n-1 do seti0(x,i,complex(f(...),f(...))) end
  return x
end

function MR.shuffle (x) -- random permutation (Knuth shuffles)
  local n = x:size()
  for i=0,n-2 do
    local j = random(i,n-1)
    x.data[i], x.data[j] = x.data[j], x.data[i]
  end
  return x
end

function MR.symp (x) -- zeros + J
  local nr, nc = x:sizes()
  assert(nr == nc and nr % 2 == 0, "invalid argument #1 (2n matrix expected)")
  x:zeros()
  for i=1,nr-1,2 do set(x,i,i+1,1) set(x,i+1,i,-1) end
  return x
end

function MR.circ (x, v)
  local d
  if isa_vector(v) then
    d = v:nrow() == 1 and 'row' or 'col'
  else
    assert(is_iterable(v), "invalid argument #2 (iterable expected)")
    if is_iterable(v[1]) then d, v = 'row', v[1] else d = 'col' end
  end
  local k, nr, nc = 0, x:sizes()
  if d == 'row' then
    for i=1,nr do
    for j=nc+2-i,nc do seti0(x,k, v[j]) k=k+1 end
    for j=1,nc+1-i  do seti0(x,k, v[j]) k=k+1 end
    end
  else
    for i=1,nr do
    for j= i,  1,-1 do seti0(x,k, v[j]) k=k+1 end
    for j=nc,i+1,-1 do seti0(x,k, v[j]) k=k+1 end
    end
  end
  return x
end

function MR.fill (x, a, p_, s_)
  local nr, nc = x:sizes()
  if is_scalar(a) then        -- scalar
    for i=0,nr*nc-1 do seti0(x,i, a) end
  elseif is_callable(a) then  -- generator
    if is_nil(p_) or is_nil(s_) then
      for i=1,nr do
      for j=1,nc do set(x,i,j, a(get(x,i,j), i,j)) end end
    else                      -- stateless iterator
      local v
      for i=0,nr*nc-1 do s_,v = a(p_,s_) ; seti0(x,i,v) end
    end
  elseif is_iterable(a) then
    if is_iterable(a[1]) then -- 2D container
      assert(#a == nr, "incompatible container size")
      for i=1,nr do
        assert(is_iterable(a[i]), "invalid container (iterable expected)")
        assert(#a[i] == nc      , "incompatible container size")
        for j=1,nc do set(x,i,j, a[i][j]) end
      end
    else                      -- 1D container
      assert(#a == nr*nc, "incompatible container size")
      for i=1,nr*nc do seti(x,i, a[i]) end
    end
  else
    error("invalid argument #2 (scalar, callable or iterable expected)")
  end
  return x
end

function MR.movev (x, i, j, yi, y_) -- move x[i..j] to y[yi,yi+j-i]
  local y, yj = y_ or x, yi+j-i
  assert(i  >= 1 and j  <= x:size() and i <= j, "source indexes out of bounds")
  assert(yi >= 1 and yj <= y:size(),       "destination indexes out of bounds")
  if is_matrix(y) then
    _C.mad_vec_copy (x.data+i-1, y.data+yi-1, j-i+1) return x
  elseif is_cmatrix(y) then
    _C.mad_vec_copyv(x.data+i-1, y.data+yi-1, j-i+1) return x
  end
  error("invalid argument #5 (matrix expected)")
end

function MC.movev (x, i, j, yi, y_)
  local y, yj = y_ or x, yi+j-i
  assert(i  >= 1 and j  <= x:size() and i <= j, "source indexes out of bounds")
  assert(yi >= 1 and yj <= y:size(),       "destination indexes out of bounds")
  _C.mad_cvec_copy(x.data+i-1, y.data+yi-1, j-i+1)
  return x
end

function MR.shiftv (x, ni, ns_) -- shift data >= ni by +/-ns
  local n, ns = x:size(), ns_ or 1
  assert(ni >= 1 and ni <= n, "index out of bounds")
  if ns ~= 0 and ni+ns <= n and ni-ns <= n then -- nothing to do?
    _C.mad_vec_shift(x.data+ni-1, n-ni+1, ns)
  end
  return x
end

function MC.shiftv (x, ni, ns_)
  local n, ns = x:size(), ns_ or 1
  assert(ni >= 1 and ni <= n, "index out of bounds")
  if ns ~= 0 and ni+ns <= n and ni-ns <= n then -- nothing to do?
    _C.mad_cvec_shift(x.data+ni-1, n-ni+1, ns)
  end
  return x
end

function MR.roll (x, ns_, ms_)
  local nr, nc = x:sizes()
  if is_nil(ms_) and (nr == 1 or nc == 1)
  then _C.mad_vec_roll(x.data, nr*nc , ns_ or 0)
  else _C.mad_mat_roll(x.data, nr, nc, ns_ or 0, ms_ or 0)
  end
  return x
end

function MC.roll (x, ns_, ms_)
  local nr, nc = x:sizes()
  if is_nil(ms_) and (nr == 1 or nc == 1)
  then _C.mad_cvec_roll(x.data, nr*nc , ns_ or 0)
  else _C.mad_cmat_roll(x.data, nr, nc, ns_ or 0, ms_ or 0)
  end
  return x
end

function MR.reshape (x, nr_, nc_)
  local nr, nc = nr_ or x:size(), nc_ or 1
  assert(nr >= 1 and nc >= 1 and nr*nc <= x:size(), "invalid matrix new sizes")
  local xx = ffi.cast(matrix_ccast, x)
  xx.nr, xx.nc = nr, nc
  return x
end

function MR._reshapeto (x, nr_, nc_)
  -- no check, user is responsible for keeping track of the real allocated size
  -- TOTALLY UNSAFE, accessing data ouside valid indexes trigs a SEGFAULT
  local xx = ffi.cast(matrix_ccast, x)
  xx.nr, xx.nc = nr_ or 1, nc_ or 1
  return x
end

function MR._reshapeby (x, nr_, nc_)
  -- no check, user is responsible for keeping track of the real allocated size
  -- TOTALLY UNSAFE, accessing data ouside valid indexes trigs a SEGFAULT
  local xx = ffi.cast(matrix_ccast, x)
  xx.nr, xx.nc = x.nr + (nr_ or 0), x.nc + (nc_ or 0)
  return x
end

-- conversion -----------------------------------------------------------------o

function MR.complex (_, re_, im_, r) -- (re,im) -> r
  assert(is_nil(re_) or is_matrix(re_), "invalid argument #2 (matrix expected)")
  assert(is_nil(im_) or is_matrix(im_), "invalid argument #3 (matrix expected)")
  assert(is_nil(r  ) or is_cmatrix(r ), "invalid argument #4 (cmatrix expected)")
  assert(re_ or im_, "invalid argument #1 or #2 (at least one matrix expected)")
  r = chksiz(re_, r, im_) or cmatrix_alloc((re_ or im_):sizes())
  _C.mad_vec_cvec(re_ and re_.data, im_ and im_.data, r.data, r:size())
  return r
end

function MR.real (x, re_)
  assert(is_nil(re_) or is_matrix(re_), "invalid argument #2 (matrix expected)")
  re_ = chksiz(re_, x) or matrix_alloc(x:sizes())
  _C.mad_vec_copy(x.data, re_.data, x:size())
  return re_
end

function MC.real (x, re_, im_)
  assert(is_nil(re_) or is_matrix(re_), "invalid argument #2 (matrix expected)")
  assert(is_nil(im_) or is_matrix(im_), "invalid argument #3 (matrix expected)")
  re_ = chksiz(re_, x, im_) or matrix_alloc(x:sizes())
  _C.mad_cvec_vec(x.data, re_.data, im_ and im_.data, x:size())
  return re_, im_
end

function MR.imag (x, im_)
  assert(is_nil(im_) or is_matrix(im_), "invalid argument #2 (matrix expected)")
  im_ = chksiz(im_, x) or matrix_alloc(x:sizes())
  _C.mad_vec_zero(im_.data, x:size())
  return im_
end

function MC.imag (x, im_)
  assert(is_nil(im_) or is_matrix(im_), "invalid argument #2 (matrix expected)")
  im_ = chksiz(im_, x) or matrix_alloc(x:sizes())
  _C.mad_cvec_vec(x.data, nil, im_.data, x:size())
  return im_
end

-- getx, setx, swpx -----------------------------------------------------------o

function MR.getv (x, ij, r_)
  if is_number(ij) then ij = {ij} end
  if is_string(r_) and r_ == 'in' then r_ = x end
  assert(is_iterable(ij)              , "invalid argument #2 (iterable expected)")
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #3 (iterable expected)")
  local r = r_ or x:same(#ij,1)
  for i,ii in ipairs(ij) do r[i] = geti_s(x,ii) end
  return r
end

function MR.setv (x, ij, y, p_, s_)
  if is_number(ij) then ij = {ij} end
  if is_scalar(y) then y = rep(y) end
  assert(is_iterable(ij), "invalid argument #2 (iterable expected)")
  if is_nil(p_) or is_nil(s_) then
    assert(is_iterable(y), "invalid argument #3 (scalar or iterable expected)")
    local k, nk = 1, #y
    for _,ii in ipairs(ij) do seti_s(x,ii,y[k]) ; k=k%nk+1 end
  else  -- stateless iterator
    assert(is_callable(y), "invalid argument #3 (scalar or callable expected)")
    local v
    for _,ii in ipairs(ij) do s_,v = y(p_,s_) ; seti_s(x,ii,v) end
  end
  return x
end

function MR.getdiag (x, r_)
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #2 (iterable expected)")
  local n = min(x:sizes())
  local r = r_ or x:same(n,1)
  for i=1,n do r[i] = get(x,i,i) end
  return r
end

function MR.setdiag (x, y, p_, s_)
  local n = min(x:sizes())
  if is_scalar(y) then y = rep(y) end
  if is_nil(p_) or is_nil(s_) then
    assert(is_iterable(y), "invalid argument #2 (scalar or iterable expected)")
    local k, nk = 1, #y
    for i=1,n do set(x,i,i, y[k]) ; k=k%nk+1 end
  else  -- stateless iterator
    assert(is_callable(y), "invalid argument #2 (scalar or callable expected)")
    local v
    for i=1,n do s_,v = y(p_,s_) ; set(x,i,i, v) end
  end
  return x
end

function MR.getrow (x, ir, r_)
  if is_number(ir) then ir = {ir} end
  assert(is_iterable(ir)              , "invalid argument #2 (iterable expected)")
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #3 (iterable expected)")
  local k, nc = 1, x:ncol()
  local r = r_ or x:same(#ir,nc)
  for _,i in ipairs(ir) do
  for j=1,nc do r[k] = get_s(x,i,j) ; k=k+1 end end
  return r
end

function MR.setrow (x, ir, y, p_, s_)
  if is_number(ir) then ir = {ir} end
  if is_scalar(y) then y = rep(y) end
  assert(is_iterable(ir), "invalid argument #2 (iterable expected)")
  if is_nil(p_) or is_nil(s_) then
    assert(is_iterable(y), "invalid argument #3 (scalar or iterable expected)")
    local k, nk = 1, #y
    for _,i in ipairs(ir) do
    for j=1,x:ncol()      do set_s(x,i,j,y[k]) ; k=k%nk+1 end end
  else  -- stateless iterator
    assert(is_callable(y), "invalid argument #3 (scalar or callable expected)")
    for _,i in ipairs(ir) do local v
    for j=1,x:ncol()      do s_,v = y(p_,s_) ; set_s(x,i,j,v) end end
  end
  return x
end

function MR.swprow (x, ir) -- inplace
  assert(is_iterable(ir), "invalid argument #2 (iterable expected)")
  local nc = x:ncol()
  for k,i in ipairs(ir) do
    if k ~= i then -- swap row k and i
      local r1, r2 = idx(k,1,nc), idx(i,1,nc)
      for j=1,nc do x[r1+j], x[r2+j] = x[r2+j], x[r1+j] end
    end
  end
  return x
end

function MR.getcol (x, jc, r_)
  if is_number(jc) then jc = {jc} end
  assert(is_iterable(jc)              , "invalid argument #2 (iterable expected)")
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #3 (iterable expected)")
  local k, nr = 1, x:nrow()
  local r = r_ or x:same(nr,#jc)
  if isa_matrix(r) and r:ncol() > 1 then
    for i=1,nr            do
    for _,j in ipairs(jc) do r[k] = get_s(x,i,j) ; k=k+1 end end
  else
    for _,j in ipairs(jc) do
    for i=1,nr            do r[k] = get_s(x,i,j) ; k=k+1 end end
  end
  return r
end

function MR.setcol (x, jc, y, p_, s_)
  if is_number(jc) then jc = {jc} end
  if is_scalar(y) then y = rep(y) end
  assert(is_iterable(jc), "invalid argument #2 (iterable expected)")
  if isa_matrix(y) and y:ncol() > 1 then
    local k, nk = 1, #y
    for i=1,x:nrow()      do
    for _,j in ipairs(jc) do set_s(x,i,j,y[k]) ; k=k%nk+1 end end
  elseif is_nil(p_) or is_nil(s_) then
    assert(is_iterable(y), "invalid argument #3 (scalar or iterable expected)")
    local k, nk = 1, #y
    for _,j in ipairs(jc) do
    for i=1,x:nrow()      do set_s(x,i,j,y[k]) ; k=k%nk+1 end end
  else  -- stateless iterator
    assert(is_callable(y), "invalid argument #3 (scalar or callable expected)")
    for _,j in ipairs(jc) do local v
    for i=1,x:nrow()      do s_,v = y(p_,s_) ; set_s(x,i,j,v) end end
  end
  return x
end

function MR.swpcol (x, jc) -- inplace
  assert(is_iterable(jc), "invalid argument #2 (iterable expected)")
  local nr, nc = x:sizes()
  for k,j in ipairs(jc) do
    if k ~= j then -- swap col k and j
      for i=0,nr-1 do x[i*nc+k], x[i*nc+j] = x[i*nc+j], x[i*nc+k] end
    end
  end
  return x
end

function MR.getsub (x, ir, jc, r_)
  if is_number(ir) then ir = {ir} end
  if is_number(jc) then jc = {jc} end
  assert(is_iterable(ir)              , "invalid argument #2 (iterable expected)")
  assert(is_iterable(jc)              , "invalid argument #3 (iterable expected)")
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #4 (iterable expected)")
  local r, k = r_ or x:same(#ir,#jc), 1
  for _,i in ipairs(ir) do
  for _,j in ipairs(jc) do r[k] = get_s(x,i,j) ; k=k+1 end end
  return r
end

function MR.setsub (x, ir, jc, y, p_, s_)
  if is_number(ir) then ir = {ir} end
  if is_number(jc) then jc = {jc} end
  if is_scalar(y) then y = rep(y) end
  assert(is_iterable(ir), "invalid argument #2 (iterable expected)")
  assert(is_iterable(jc), "invalid argument #3 (iterable expected)")
  if is_nil(p_) or is_nil(s_) then
    assert(is_iterable(y), "invalid argument #4 (scalar or iterable expected)")
    local k, nk = 1, #y
    for _,i in ipairs(ir) do
    for _,j in ipairs(jc) do set_s(x,i,j,y[k]) ; k=k%nk+1 end end
  else  -- stateless iterator
    assert(is_callable(y), "invalid argument #4 (scalar or callable expected)")
    for _,i in ipairs(ir) do local v
    for _,j in ipairs(jc) do s_,v = y(p_,s_) ; set_s(x,i,j,v) end end
  end
  return x
end

-- foreach, map, fold, scan, filter -------------------------------------------o

function MR.foreach (x, f)
  assert(is_callable(f), "invalid argument #2 (callable expected)")
  local nr, nc = x:sizes()
  for i=1,nr do
  for j=1,nc do f(get(x,i,j), i,j) end end
  return x
end

function MR.map (x, f, r_)
  if is_string(f ) then f = opstr[f] end
  if is_string(r_) and r_ == 'in' then r_ = x end
  assert(is_callable(f)               , "invalid argument #2 (callable expected)")
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #3 (iterable expected)")
  local r0 = f(geti(x,1))
  assert(is_scalar(r0) or not (is_nil(r_) or isa_matrix(r_)),
                                        "invalid argument #2 (scalar function expected)")
  local r, n = r_ or x:same(r0), x:size()
  r[1] = r0
  for i=2,n do r[i] = f(geti(x,i)) end
  return r
end

function MR.map2 (x, y, f, r_)
  if is_scalar(y ) then y = rep(y) end
  if is_string(f ) then f = opstr[f] end
  if is_string(r_) and r_ == 'in' then r_ = x end
  assert(is_iterable(y)               , "invalid argument #2 (scalar or iterable expected)")
  assert(is_callable(f)               , "invalid argument #3 (callable expected)")
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #4 (iterable expected)")
  local r0 = f(geti(x,1), y[1])
  assert(is_scalar(r0) or not (is_nil(r_) or isa_matrix(r_)),
                                        "invalid argument #3 (scalar function expected)")
  local r, n = r_ or x:same(r0), x:size()
  r[1] = r0
  for i=2,n do r[i] = f(geti(x,i), y[i]) end
  return r
end

function MR.map3 (x, y, z, f, r_)
  if is_scalar(y ) then y = rep(y) end
  if is_scalar(z ) then z = rep(z) end
  if is_string(f ) then f = opstr[f] end
  if is_string(r_) and r_ == 'in' then r_ = x end
  assert(is_iterable(y)               , "invalid argument #2 (scalar or iterable expected)")
  assert(is_iterable(z)               , "invalid argument #3 (scalar or iterable expected)")
  assert(is_callable(f)               , "invalid argument #4 (callable expected)")
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #5 (iterable expected)")
  local r0 = f(geti(x,1), y[1], z[1])
  assert(is_scalar(r0) or not (is_nil(r_) or isa_matrix(r_)),
                                        "invalid argument #4 (scalar function expected)")
  local r, n = r_ or x:same(r0), x:size()
  r[1] = r0
  for i=2,n do r[i] = f(geti(x,i), y[i], z[i]) end
  return r
end

function MR.mapij (x, f, r_)
  if is_string(f ) then f = opstr[f] end
  if is_string(r_) and r_ == 'in' then r_ = x end
  assert(is_callable(f)               , "invalid argument #2 (callable expected)")
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #3 (iterable expected)")
  local r, k, nr, nc = r_ or x:same(), 1, x:sizes()
  for i=1,nr do
  for j=1,nc do
    r[k], k = f(get(x,i,j), i,j), k+1
  end end
  return r
end

function MR.mapat (x, f, ij, r_)
  if is_string(f ) then f = opstr[f] end
  if is_number(ij) then ij = {ij} end
  if is_string(r_) and r_ == 'in' then r_ = x end
  assert(is_callable(f )              , "invalid argument #2 (callable expected)")
  assert(is_iterable(ij)              , "invalid argument #3 (iterable expected)")
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #4 (iterable expected)")
  local r = r_ or x:copy()
  for _,i in ipairs(ij) do r[i] = f(geti_s(x,i)) end
  if is_table(r) then -- complete the fill
    for i=1,x:size() do
      if is_nil(r[i]) then r[i] = geti_s(x,i) end
    end
  end
  return r
end

function MR.foldl (x, f, x0_, d_, r_)
  if is_string(f) then f = opstr[f] end
  if is_string(x0_) then                           -- case 2',4',4": shift right
    x0_, d_, r_ = nil, x0_, is_nil(r_) and d_ or r_
  elseif is_nil(r_) and not is_string(d_) then        -- case 7',3": shift right
    d_, r_ = nil, d_
  end
  assert(is_callable(f)               , "invalid argument #2 (callable expected)")
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #5 (iterable expected)")
  local nr, nc, rr, r = x:sizes()
  if is_nil(d_) or d_ == 'vec' then    -- fold x as vector, r_ is discarded
                            r  = geti(x,1)
    if not is_nil(x0_) then r  = f(x0_, r) end
    for i=2,nr*nc        do r  = f(r, geti(x,i)) end
  elseif d_ == 'row' then              -- fold x rows
    r = r_ or x:same(nr,1)
    for i=1,nr           do rr = get(x,i,1)
    if not is_nil(x0_) then rr = f(x0_, rr) end
    for j=2,nc           do rr = f(rr, get(x,i,j)) end r[i] = rr end
  elseif d_ == 'col' then              -- fold x columns
    r = r_ or x:same(1,nc)
    for j=1,nc           do rr = get(x,1,j)
    if not is_nil(x0_) then rr = f(x0_, rr) end
    for i=2,nr           do rr = f(rr, get(x,i,j)) end r[j] = rr end
  else
    error("invalid argument #4 (string 'vec', 'row' or 'col' expected)")
  end
  return r
end

function MR.foldr (x, f, x0_, d_, r_)
  if is_string(f) then f = opstr[f] end
  if is_string(x0_) then                           -- case 2',4',4": shift right
    x0_, d_, r_ = nil, x0_, is_nil(r_) and d_ or r_
  elseif is_nil(r_) and not is_string(d_) then        -- case 7',3": shift right
    d_, r_ = nil, d_
  end
  assert(is_callable(f)               , "invalid argument #2 (callable expected)")
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #5 (iterable expected)")
  local nr, nc, rr, r = x:sizes()
  if is_nil(d_) or d_ == 'vec' then    -- fold x as vector, r_ is discarded
                            r  = geti(x,nr*nc)
    if not is_nil(x0_) then r  = f(r, x0_) end
    for i=nr*nc-1,1,-1   do r  = f(geti(x,i), r) end
  elseif d_ == 'row' then              -- fold x rows
    r = r_ or x:same(nr,1)
    for i=nr  ,1,-1      do rr = get(x,i,nc)
    if not is_nil(x0_) then rr = f(rr, x0_) end
    for j=nc-1,1,-1      do rr = f(get(x,i,j), rr) end r[i] = rr end
  elseif d_ == 'col' then              -- fold x columns
    r = r_ or x:same(1,nc)
    for j=nc  ,1,-1      do rr = get(x,nr,j)
    if not is_nil(x0_) then rr = f(rr, x0_) end
    for i=nr-1,1,-1      do rr = f(get(x,i,j), rr) end r[j] = rr end
  else
    error("invalid argument #4 (string 'vec', 'row' or 'col' expected)")
  end
  return r
end

function MR.scanl (x, f, x0_, d_, r_)
  if is_string(f) then f = opstr[f] end
  if is_string(x0_) then                           -- case 2',4',4": shift right
    x0_, d_, r_ = nil, x0_, is_nil(r_) and d_ or r_
  elseif is_nil(r_) and not is_string(d_) then        -- case 7',3": shift right
    d_, r_ = nil, d_
  end
  if is_string(r_) and r_ == 'in' then r_ = x end
  assert(is_callable(f)               , "invalid argument #2 (callable expected)")
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #5 (iterable expected)")
  local r, nr, nc, rr = r_ or x:same(), x:sizes()
  if is_nil(d_) or d_ == 'vec' then    -- scan x as vector
                            rr = geti(x,1)
    if not is_nil(x0_) then rr = f(x0_, rr) end    r[1] = rr
    for i=2,nr*nc        do rr = f(rr, geti(x,i))  r[i] = rr end
  elseif d_ == 'row' then              -- scan x rows
    local k = 1
    for i=1,nr           do rr = get(x,i,1)
    if not is_nil(x0_) then rr = f(x0_, rr) end    r[k], k = rr, k+1
    for j=2,nc           do rr = f(rr, get(x,i,j)) r[k], k = rr, k+1 end end
  elseif d_ == 'col' then              -- scan x columns
    if isa_matrix(r) and r:ncol() > 1 then
      for j=1,nc           do rr = get(x,1,j)
      if not is_nil(x0_) then rr = f(x0_, rr) end    r[idx(1,j,nc)+1] = rr
      for i=2,nr           do rr = f(rr, get(x,i,j)) r[idx(i,j,nc)+1] = rr end end
    else
      local k = 1
      for j=1,nc           do rr = get(x,1,j)
      if not is_nil(x0_) then rr = f(x0_, rr) end    r[k], k = rr, k+1
      for i=2,nr           do rr = f(rr, get(x,i,j)) r[k], k = rr, k+1 end end
    end
  else
    error("invalid argument #4 (string 'vec', 'row' or 'col' expected)")
  end
  return r
end

function MR.scanr (x, f, x0_, d_, r_)
  if is_string(f) then f = opstr[f] end
  if is_string(x0_) then                           -- case 2',4',4": shift right
    x0_, d_, r_ = nil, x0_, is_nil(r_) and d_ or r_
  elseif is_nil(r_) and not is_string(d_) then        -- case 7',3": shift right
    d_, r_ = nil, d_
  end
  if is_string(r_) and r_ == 'in' then r_ = x end
  assert(is_callable(f)               , "invalid argument #2 (callable expected)")
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #5 (iterable expected)")
  local r, nr, nc, rr = r_ or x:same(), x:sizes()
  if is_nil(d_) or d_ == 'vec' then    -- scan x as vector
                            rr = geti(x,nr*nc)
    if not is_nil(x0_) then rr = f(rr, x0_) end    r[nr*nc] = rr
    for i=nr*nc-1,1,-1   do rr = f(geti(x,i), rr)  r[i    ] = rr end
  elseif d_ == 'row'  then             -- scan x rows
    local k = nr*nc
    for i=nr  ,1,-1      do rr = get(x,i,nc)
    if not is_nil(x0_) then rr = f(rr, x0_) end    r[k], k = rr, k-1
    for j=nc-1,1,-1      do rr = f(get(x,i,j), rr) r[k], k = rr, k-1 end end
  elseif d_ == 'col' then              -- scan x columns
    if isa_matrix(r) and r:ncol() > 1 then
      for j=nc  ,1,-1      do rr = get(x,nr,j)
      if not is_nil(x0_) then rr = f(rr, x0_) end    r[idx(nr,j,nc)+1] = rr
      for i=nr-1,1,-1      do rr = f(get(x,i,j), rr) r[idx(i ,j,nc)+1] = rr end end
    else
      local k = nr*nc
      for j=nc  ,1,-1      do rr = get(x,nr,j)
      if not is_nil(x0_) then rr = f(rr, x0_) end    r[k], k = rr, k-1
      for i=nr-1,1,-1      do rr = f(get(x,i,j), rr) r[k], k = rr, k-1 end end
    end
  else
    error("invalid argument #4 (string 'vec', 'row' or 'col' expected)")
  end
  return r
end

function MR.filter (x, p, r_)
  if is_string(r_) and r_ == 'in' then r_ = x end
  assert(is_callable(p)               , "invalid argument #2 (callable expected)")
  assert(is_nil(r_) or is_iterable(r_), "invalid argument #3 (iterable expected)")
  local r, k, nr, nc = r_ or x:same(), 1, x:sizes()
  for i=1,nr do
  for j=1,nc do
    if p(get(x,i,j), i,j) == true then
      r[k], k = get(x,i,j), k+1
    end
  end end
  if isa_matrix(r) then r:reshape(k-1) end
  return r
end

-- special maps ---------------------------------------------------------------o

MR.ceil  = \x,r_ -> x:map(ceil , r_)
MR.floor = \x,r_ -> x:map(floor, r_)
MR.frac  = \x,r_ -> x:map(frac , r_)
MR.trunc = \x,r_ -> x:map(trunc, r_)
MR.round = \x,r_ -> x:map(round, r_)

MR.abs   = \x,r_ -> x:map(abs  , r_)
MR.sqrt  = \x,r_ -> x:map(sqrt , r_)
MR.exp   = \x,r_ -> x:map(exp  , r_)
MR.log   = \x,r_ -> x:map(log  , r_)
MR.log10 = \x,r_ -> x:map(log10, r_)

MR.sin   = \x,r_ -> x:map(sin  , r_)
MR.cos   = \x,r_ -> x:map(cos  , r_)
MR.tan   = \x,r_ -> x:map(tan  , r_)
MR.sinh  = \x,r_ -> x:map(sinh , r_)
MR.cosh  = \x,r_ -> x:map(cosh , r_)
MR.tanh  = \x,r_ -> x:map(tanh , r_)

MR.asin  = \x,r_ -> x:map(asin , r_)
MR.acos  = \x,r_ -> x:map(acos , r_)
MR.atan  = \x,r_ -> x:map(atan , r_)
MR.asinh = \x,r_ -> x:map(asinh, r_)
MR.acosh = \x,r_ -> x:map(acosh, r_)
MR.atanh = \x,r_ -> x:map(atanh, r_)

MR.erf   = \x,r_ -> x:map(erf   , r_)
MR.tgamma= \x,r_ -> x:map(tgamma, r_)
MR.lgamma= \x,r_ -> x:map(lgamma, r_)

MR.carg  = \x,r_ -> x:map(carg , r_)
MR.conj  = \x,r_ -> x:map(conj , r_)
MR.proj  = \x,r_ -> x:map(proj , r_)
MR.rect  = \x,r_ -> x:map(rect , r_)
MR.polar = \x,r_ -> x:map(polar, r_)

-- special folds --------------------------------------------------------------o

local all = \p,r,x -> lbool(land(r, p(x)))
local any = \p,r,x -> lbool(lor (r, p(x)))

MR.min     = \x,d_,r_ -> x:foldl(min, nil, d_, r_)
MR.max     = \x,d_,r_ -> x:foldl(max, nil, d_, r_)
MR.sum     = \x,d_,r_ -> x:foldl(add, nil, d_, r_)
MR.product = \x,d_,r_ -> x:foldl(mul, nil, d_, r_)
MR.sumsqr  = \x,d_,r_ -> x:foldl(sumsqr, 0, d_, r_)
MR.sumabs  = \x,d_,r_ -> x:foldl(sumabs, 0, d_, r_)
MR.minabs  = \x,d_,r_ -> x:foldl(minabs, 0, d_, r_)
MR.maxabs  = \x,d_,r_ -> x:foldl(maxabs, 0, d_, r_)

MR.all   = \x,p,d_,r_ =>
              assert(is_callable(p), "invalid argument #2 (callable expected)")
              return x:foldl(bind1st(all, p), true , d_, r_) end
MR.any   = \x,p,d_,r_ =>
              assert(is_callable(p), "invalid argument #2 (callable expected)")
              return x:foldl(bind1st(any, p), false, d_, r_) end

-- special scans --------------------------------------------------------------o

-- left accumulation
MR.accmin    = \x,d_,r_ -> x:scanl(min, nil, d_, r_)
MR.accmax    = \x,d_,r_ -> x:scanl(max, nil, d_, r_)
MR.accsum    = \x,d_,r_ -> x:scanl(add, nil, d_, r_)
MR.accprod   = \x,d_,r_ -> x:scanl(mul, nil, d_, r_)
MR.accsumsqr = \x,d_,r_ -> x:scanl(sumsqr, 0, d_, r_)
MR.accsumabs = \x,d_,r_ -> x:scanl(sumabs, 0, d_, r_)
MR.accminabs = \x,d_,r_ -> x:scanl(minabs, 0, d_, r_)
MR.accmaxabs = \x,d_,r_ -> x:scanl(maxabs, 0, d_, r_)

MR.accumulate = MR.accsum

-- right accumulation
MR.raccmin    = \x,d_,r_ -> x:scanr(min, nil, d_, r_)
MR.raccmax    = \x,d_,r_ -> x:scanr(max, nil, d_, r_)
MR.raccsum    = \x,d_,r_ -> x:scanr(add, nil, d_, r_)
MR.raccprod   = \x,d_,r_ -> x:scanr(mul, nil, d_, r_)
MR.raccsumsqr = \x,d_,r_ -> x:scanr(compose(sumsqr,swap), 0, d_, r_)
MR.raccsumabs = \x,d_,r_ -> x:scanr(compose(sumabs,swap), 0, d_, r_)
MR.raccminabs = \x,d_,r_ -> x:scanr(compose(minabs,swap), 0, d_, r_)
MR.raccmaxabs = \x,d_,r_ -> x:scanr(compose(maxabs,swap), 0, d_, r_)

-- special filters ------------------------------------------------------------o

MR.filter_out = \x,p,r_ -> x:filter(compose(lnot,p), r_)

-- special algorithms ---------------------------------------------------------o

function MR.kbnsum (x) -- Neumaier variant
  return _C.mad_vec_sum(x.data, x:size())
end

function MC.kbnsum (x) -- Neumaier variant
  _C.mad_cvec_sum(x.data, cres, x:size()) return cres[0]
end

function MR.horner (x, x0)
  return _C.mad_vec_eval(x.data, x0, x:size())
end

function MC.horner (x, x0)
  _C.mad_cvec_eval(x.data, x0.re, x0.im, cres, x:size()) return cres[0]
end

-- conjugate, transpose -------------------------------------------------------o

MR.conjugate = MR.conj

function MR.transpose (x, r_)
  if is_string(r_) and r_ == 'in' then r_ = x end
  local r = chksizt(r_,x) or matrix_alloc(x:tsizes())
  _C.mad_mat_trans(x.data, r.data, x:sizes())         -- transpose
  return r
end

MR.t = MR.transpose -- shortcut

function MC.transpose (x, r_, c_)
  if is_string(r_) and r_ == 'in' then r_ = x end
  if is_boolean(r_) and is_nil(c_) then r_, c_ = nil, r_ end
  local r = chksizt(r_,x) or cmatrix_alloc(x:tsizes())
  if c_ == false
  then _C.mad_cmat_trans (x.data, r.data, x:sizes())  -- transpose (no conj.)
  else _C.mad_cmat_ctrans(x.data, r.data, x:sizes())  -- conjugate transpose
  end
  return r
end

MC.t = MC.transpose -- shortcut

function MR.trace (x)
  local r, nr, nc = 0, x:sizes()
  local n = min(nr, nc)
  for i=0,n*nc,nc+1 do r = r + geti0(x,i) end
  return r
end

MR.tr = MR.trace -- shortcut

-- symplectic matrix ----------------------------------------------------------o

function MR.sympconj (x, r_) -- -J M' J = symplectic conjugate
  if is_string(r_) and r_ == 'in' then r_ = x end
  local nr, nc = x:sizes()
  assert(nr == nc and nr % 2 == 0, "invalid argument #1 (2n matrix expected)")
  local r = chksiz(r_,x) or matrix_alloc(nr,nr)
  _C.mad_mat_sympconj(x.data, r.data, nr)
  return r
end

function MC.sympconj (x, r_) -- -J M' J = symplectic conjugate
  if is_string(r_) and r_ == 'in' then r_ = x end
  local nr, nc = x:sizes()
  assert(nr == nc and nr % 2 == 0, "invalid argument #1 (2n matrix expected)")
  local r = chksiz(r_,x) or cmatrix_alloc(nr,nr)
  _C.mad_cmat_sympconj(x.data, r.data, nr)
  return r
end

function MR.symperr (x, r_) -- M' J M - J = symplectic deviation
  local nr, nc = x:sizes()
  assert(nr == nc and nr % 2 == 0, "invalid argument #1 (2n matrix expected)")
  if is_nil(r_) then
    return _C.mad_mat_symperr(x.data, nil, nr)
  end
  assert(x.data ~= r_.data, "invalid argument #2 (different matrix expected)")
  chksiz(r_,x)
  return r_, _C.mad_mat_symperr(x.data, r_.data, nr)
end

function MC.symperr (x, r_) -- M' J M - J = symplectic deviation
  local nr, nc = x:sizes()
  assert(nr == nc and nr % 2 == 0, "invalid argument #1 (2n matrix expected)")
  if is_nil(r_) then
    return _C.mad_cmat_symperr(x.data, nil, nr)
  end
  assert(x.data ~= r_.data, "invalid argument #2 (different matrix expected)")
  chksiz(r_,x)
  return r_, _C.mad_cmat_symperr(x.data, r_.data, nr)
end

-- inner, cross, mixed, outer -------------------------------------------------o

function MR.inner (x, y, r_)
  -- (x:t() * y):tr() without temporary, tr is called only if r_ == 'tr'
  assert(isa_matrix(y), "invalid argument #2 (matrix expected)")
  chksiz(x,y)
  local nr, nc = x:sizes()
  if nc == 1 or is_string(r_) and r_ == 'tr' then
    if is_matrix(y)
    then return _C.mad_vec_dot    (x.data, y.data,       nr*nc)
    else        _C.mad_vec_dotv_r (x.data, y.data, cres, nr*nc) return cres[0]
    end
  else
    assert(is_nil(r_) or r_:nrow() == 1 and r_:ncol() == nc,
           "incompatible matrix sizes")
    local r = r_ or x:same(y[1], 1, nc)
    if is_matrix(y)
    then _C.mad_mat_dot  (x.data, y.data, r.data, nr, nc)
    else _C.mad_mat_dotm (x.data, y.data, r.data, nr, nc)
    end
    return r
  end
end

MR.dot = MR.inner -- shortcut

function MC.inner (x, y, r_)
  -- (x:t() * y):tr() without temporary, tr is called only if r_ == 'tr'
  assert(isa_matrix(y), "invalid argument #2 (matrix expected)")
  chksiz(x,y)
  local nr, nc = x:sizes()
  if nc == 1 or is_string(r_) and r_ == 'tr' then
    if is_matrix(y)
    then return _C.mad_cvec_dotv_r (x.data, y.data, cres, nr*nc)
    else        _C.mad_cvec_dot_r  (x.data, y.data, cres, nr*nc)
    end
    return cres[0]
  else
    assert(is_nil(r_) or r_:nrow() == 1 and r_:ncol() == nc,
           "incompatible matrix sizes")
    local r = r_ or x:same(1, nc)
    if is_matrix(y)
    then _C.mad_cmat_dotm (x.data, y.data, r.data, nr, nc)
    else _C.mad_cmat_dot  (x.data, y.data, r.data, nr, nc)
    end
    return r
  end
end

MC.dot = MC.inner -- shortcut

function MR.outer (x, y, r_)
  -- x * y:t() without temporary
  if is_string(r_) and r_ == 'in' then r_ = x end
  assert(isa_matrix(y), "invalid argument #2 (matrix expected)")
  local nr, nc = x:nrow(), y:nrow()
  assert(x :ncol() == 1  and y :ncol() == 1 and (is_nil(r_) or
         r_:nrow() == nr and r_:ncol() == nc), "incompatible matrix sizes")
  local r = r_ or x:same(x[1]+y[1], nr, nc)
  for i=0,nr-1 do
  for j=0,nc-1 do set0(r,i,j, geti0(x,i) * conj(geti0(y,j))) end end
  return r
end

function MR.cross (x, y, r_) -- TODO: move to mad_mat
  if is_string(r_) and r_ == 'in' then r_ = x end
  assert(isa_matrix(y), "invalid argument #2 (matrix expected)")
  local nr, nc = x:sizes()
  assert(nr == 3, "invalid matrix sizes")
  local r = chksiz(r_,x,y) or x:same(x[1]+y[1], 3, nc)
  local r0, r1, r2
  -- single cross product
  if nc == 1 then
    r0 = geti0(x,1) * geti0(y,2) - geti0(x,2) * geti0(y,1)
    r1 = geti0(x,2) * geti0(y,0) - geti0(x,0) * geti0(y,2)
    r2 = geti0(x,0) * geti0(y,1) - geti0(x,1) * geti0(y,0)
    seti0(r,0,r0) ; seti0(r,1,r1) ; seti0(r,2,r2)
  else
  -- multiple cross products
    local i0, i1, i2 = 0, nc, 2*nc -- 1st, 2nd and 3rd rows
    for i=0,nc-1 do
      r0 = geti0(x,i1) * geti0(y,i2) - geti0(x,i2) * geti0(y,i1)
      r1 = geti0(x,i2) * geti0(y,i0) - geti0(x,i0) * geti0(y,i2)
      r2 = geti0(x,i0) * geti0(y,i1) - geti0(x,i1) * geti0(y,i0)
      seti0(r,i0,r0) ; seti0(r,i1,r1) ; seti0(r,i2,r2)
      i0, i1, i2 = i0+1, i1+1, i2+1
    end
  end
  return r
end

function MR.mixed (x, y, z, r_)
  -- diag( (uxv)'.w ) without temporary
  if is_string(r_) and r_ == 'in' then r_ = x end
  assert(isa_matrix(y), "invalid argument #2 (matrix expected)")
  assert(isa_matrix(z), "invalid argument #3 (matrix expected)")
  local nr, nc = x:sizes()
  assert(nr == 3, "invalid matrix sizes")
  assert(nr == y:nrow() and nc == y:ncol() and
         nr == z:nrow() and nc == z:ncol(), "incompatible matrix sizes")
  if nc == 1 then
  -- single mixed product (r_ ignored)
    return conj(geti0(x,1) * geti0(y,2) - geti0(x,2) * geti0(y,1)) * geti0(z,0) +
           conj(geti0(x,2) * geti0(y,0) - geti0(x,0) * geti0(y,2)) * geti0(z,1) +
           conj(geti0(x,0) * geti0(y,1) - geti0(x,1) * geti0(y,0)) * geti0(z,2)
  end
  -- multiple mixed products
  assert(is_nil(r_) or nc == r_:nrow() and 1 == r_:ncol(),
         "incompatible result matrix sizes")
  local r = r_ or x:same(x[1]+y[1]+z[1], 1, nc)
  local i0, i1, i2 = 0, nc, 2*nc -- 1st, 2nd and 3rd rows
  for i=0,nc-1 do
    r.data[i] = conj(geti0(x,i1) * geti0(y,i2) - geti0(x,i2) * geti0(y,i1)) * geti0(z,i0) +
                conj(geti0(x,i2) * geti0(y,i0) - geti0(x,i0) * geti0(y,i2)) * geti0(z,i1) +
                conj(geti0(x,i0) * geti0(y,i1) - geti0(x,i1) * geti0(y,i0)) * geti0(z,i2)
    i0, i1, i2 = i0+1, i1+1, i2+1
  end
  return r
end

-- norm, unit, center, angle (in place) ---------------------------------------o

function MR.norm (x)
  return _C.mad_vec_norm(x.data, x:size())
end

function MC.norm (x)
  return _C.mad_cvec_norm(x.data, x:size())
end

function MR.distance (x, y)
  assert(is_matrix(y), "invalid argument #2 (matrix expected)")
  return _C.mad_vec_dist(x.data, y.data, x:size())
end

function MC.distance (x, y)
  assert(is_cmatrix(y), "invalid argument #2 (cmatrix expected)")
  return _C.mad_cvec_dist(x.data, y.data, x:size())
end

function MR.unit (x, r_)
  if is_string(r_) and r_ == 'in' then r_ = x end
  local n = x:norm()
  assert(n ~= 0, "null matrix norm")
  local r = chksiz(r_,x) or x:same()
  _C.mad_vec_muln(x.data, 1/n, r.data, r:size())
  return r
end

function MC.unit (x, r_)
  if is_string(r_) and r_ == 'in' then r_ = x end
  local n = x:norm()
  assert(n ~= 0, "null matrix norm")
  local r = chksiz(r_,x) or x:same()
  _C.mad_cvec_muln(x.data, 1/n, r.data, r:size())
  return r
end

function MR.center (x, d_, r_) -- center vector or matrix row or col on mean
  if is_nil(r_) and not is_string(d_) then
    d_, r_ = nil, d_ -- shift right
  end
  if is_string(r_) and r_ == 'in' then r_ = x end
  local r = chksiz(r_,x) or x:same()
  if is_nil(d_) or d_ == 'vec'
  then _C.mad_vec_center(x.data, r.data, x:size())
  else _C.mad_mat_center(x.data, r.data, x:nrow(), x:ncol(), d_=='col' and 2 or 1)
  end
  return r
end

function MC.center (x, d_, r_) -- center vector or matrix row or col on mean
  if is_nil(r_) and not is_string(d_) then
    d_, r_ = nil, d_ -- shift right
  end
  if is_string(r_) and r_ == 'in' then r_ = x end
  local r = chksiz(r_,x) or x:same()
  if is_nil(d_) or d_ == 'vec'
  then _C.mad_cvec_center(x.data, r.data, x:size())
  else _C.mad_cmat_center(x.data, r.data, x:nrow(), x:ncol(), d_=='col' and 2 or 1)
  end
  return r
end

function MR.angle (x, y, n_)
  local w = x:inner(y)
  local v = x:norm() * y:norm()
  assert(v ~= 0, "null vector norm") -- convention: return pi/2 ?
  local a = acos(w / v) -- [0, pi]
  if n_ and x:mixed(y, n_) < 0 then a = -a end -- [-pi, pi]
  return a
end

-- operators ------------------------------------------------------------------o

MR.__unm  = \x,_,r_ -> x:map (   unm, r_) -- note: _ is dummy arg, see Lua specs.
MR.__mod  = \x,y,r_ -> x:map2(y, mod, r_) -- for now
MR.__pow  = \x,y,r_ -> x:map2(y, pow, r_) -- for now
MR.__emod = \x,y,r_ -> x:map2(y, mod, r_) -- incomplete
MR.__epow = \x,y,r_ -> x:map2(y, pow, r_) -- incomplete

--[[ TODO
  mexp, mlog, msqrt, mpow using Padé approximants or eigen systems
]]

-- equal

function MR.__req_cpx (y, x, tol_) -- cpx == mat
  tol_ = tol_ or 0
  assert(is_number(tol_), "invalid argument #3 (number expected)")
  if abs(x.im) > tol_ then return false end
  for i=1,y:size() do
    if abs(geti(y,i) - x.re) > tol_ then return false end
  end
  return true
end

function MR.__eq (x, y, tol_)
  tol_ = tol_ or 0
  assert(is_number(tol_), "invalid argument #3 (number expected)")
  if is_nil(x) or is_nil(y) then
    return false
  elseif is_number(x) then                    -- num == mat
    for i=1,y:size() do
      if abs(geti(y,i) - x) > tol_ then return false end
    end
  elseif is_scalar(y) then                    -- mat == num or cpx
    y = complex(y)
    if abs(y.im) > tol_ then return false end
    for i=1,x:size() do
      if abs(geti(x,i) - y.re) > tol_ then return false end
    end
  elseif is_cmatrix(y) then                   -- mat == cmat
    if x:nrow() ~= y:nrow() or x:ncol() ~= y:ncol() then return false end
    for i=1,x:size() do
      if abs(geti(x,i) - geti(y,i).re) > tol_ or
         abs(            geti(y,i).im) > tol_ then return false end
    end
  elseif is_matrix(x) and is_matrix(y) then   -- mat == mat
    if x:nrow() ~= y:nrow() or x:ncol() ~= y:ncol() then return false end
    for i=1,x:size() do
      if abs(geti(x,i) - geti(y,i)) > tol_ then return false end
    end
  elseif has_method(y, '__req_mat') then      -- mat == ?
    return y:__req_mat(x, tol_)
  else
    return false
  end
  return true
end

function MC.__req_cpx (y, x, tol_) -- cpx == cmat
  tol_ = tol_ or 0
  assert(is_number(tol_), "invalid argument #3 (number expected)")
  for i=1,y:size() do
    if abs(geti(y,i).re - x.re) > tol_ or
       abs(geti(y,i).im - x.im) > tol_ then return false end
  end
  return true
end

function MC.__eq (x, y, tol_)
   tol_ = tol_ or 0
  assert(is_number(tol_), "invalid argument #3 (number expected)")
  if is_nil(x) or is_nil(y) then
    return false
  elseif is_number(x) then                    -- num == cmat
    for i=1,y:size() do
      if abs(geti(y,i).re - x) > tol_ or
         abs(geti(y,i).im    ) > tol_ then return false end
    end
  elseif is_scalar(y) then                    -- cmat == num or cpx
    y = complex(y)
    for i=1,x:size() do
      if abs(geti(x,i).re - y.re) > tol_ or
         abs(geti(x,i).im - y.im) > tol_ then return false end
    end
  elseif is_matrix(y) then                    -- cmat == mat
    if x:nrow() ~= y:nrow() or x:ncol() ~= y:ncol() then return false end
    for i=1,x:size() do
      if abs(geti(x,i).re - geti(y,i)) > tol_ or
         abs(geti(x,i).im            ) > tol_ then return false end
    end
  elseif is_cmatrix(x) and is_cmatrix(y) then -- cmat == cmat
    if x:nrow() ~= y:nrow() or x:ncol() ~= y:ncol() then return false end
    for i=1,x:size() do
      if abs(geti(x,i).re - geti(y,i).re) > tol_ or
         abs(geti(x,i).im - geti(y,i).im) > tol_ then return false end
    end
  elseif has_method(y, '__req_cmat') then     -- cmat == ?
    return y:__req_mat(x, tol_)
  else
    return false
  end
  return true
end

-- add (see also kadd)

function MR.__radd_cpx (y, x, r)                 -- cpx + mat => cpx + vec
  r = chksiz(r,y) or cmatrix_alloc(y:sizes())
  _C.mad_vec_addc_r(y.data, x.re, x.im, r.data, r:size()) return r
end

function MR.__add (x, y, r)
  if is_number(x) then                           -- num + mat => num + vec
    r = chksiz(r,y) or matrix_alloc(y:sizes())
    _C.mad_vec_addn(y.data, x, r.data, r:size()) return r
  elseif is_number(y) then                       -- mat + num => vec + num
    r = chksiz(r,x) or matrix_alloc(x:sizes())
    _C.mad_vec_addn(x.data, y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- mat + cpx => vec + cpx
    r = chksiz(r,x) or cmatrix_alloc(x:sizes())
    _C.mad_vec_addc_r(x.data, y.re, y.im, r.data, r:size()) return r
  elseif is_cmatrix(y) then                      -- mat + cmat => vec + cvec
    r = chksiz(r,x,y) or cmatrix_alloc(x:sizes())
    _C.mad_cvec_addv(y.data, x.data, r.data, r:size()) return r
  elseif is_matrix(y) and is_matrix(x) then      -- mat + mat => vec + vec
    r = chksiz(r,x,y) or matrix_alloc(x:sizes())
    _C.mad_vec_add(x.data, y.data, r.data, r:size()) return r
  elseif has_method(y, '__radd_mat') then        -- mat + ?
    return y:__radd_mat(x, r)
  end
  error("invalid arguments (unsupported matrix operation '+')")
end

function MC.__radd_cpx (y, x, r)                 -- cpx + cmat => cpx + cvec
  r = chksiz(r,y) or cmatrix_alloc(y:sizes())
  _C.mad_cvec_addc_r(y.data, x.re, x.im, r.data, r:size()) return r
end

function MC.__add (x, y, r)
  if is_number(x) then                           -- num + cmat => num + cvec
    r = chksiz(r,y) or cmatrix_alloc(y:sizes())
    _C.mad_cvec_addn(y.data, x, r.data, r:size()) return r
  elseif is_number(y) then                       -- cmat + num => cvec + num
    r = chksiz(r,x) or cmatrix_alloc(x:sizes())
    _C.mad_cvec_addn(x.data, y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- cmat + cpx => cvec + cpx
    r = chksiz(r,x) or cmatrix_alloc(x:sizes())
    _C.mad_cvec_addc_r(x.data, y.re, y.im, r.data, r:size()) return r
  elseif is_matrix(y) then                       -- cmat + mat => cvec + vec
    r = chksiz(r,x,y) or cmatrix_alloc(x:sizes())
    _C.mad_cvec_addv(x.data, y.data, r.data, r:size()) return r
  elseif is_cmatrix(y) and is_cmatrix(x) then    -- cmat + cmat => cvec + cvec
    r = chksiz(r,x,y) or cmatrix_alloc(x:sizes())
    _C.mad_cvec_add(x.data, y.data, r.data, r:size()) return r
  elseif has_method(y, '__radd_cmat') then       -- cmat + ?
    return y:__radd_cmat(x, r)
  end
  error("invalid arguments (unsupported matrix operation '+')")
end

-- sub (see also kadd)

function MR.__rsub_cpx (y, x, r)                 -- cpx - mat => cpx - vec
  r = chksiz(r,y) or cmatrix_alloc(y:sizes())
  _C.mad_vec_subc_r(y.data, x.re, x.im, r.data, r:size()) return r
end

function MR.__sub (x, y, r)
  if is_number(x) then                           -- num - mat => num - vec
    r = chksiz(r,y) or matrix_alloc(y:sizes())
    _C.mad_vec_subn(y.data, x, r.data, r:size()) return r
  elseif is_number(y) then                       -- mat - num => vec + -num
    r = chksiz(r,x) or matrix_alloc(x:sizes())
    _C.mad_vec_addn(x.data, -y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- mat - cpx => vec + -cpx
    r = chksiz(r,x) or cmatrix_alloc(x:sizes())
    _C.mad_vec_addc_r(x.data, -y.re, -y.im, r.data, r:size()) return r
  elseif is_cmatrix(y) then                      -- mat - cmat => vec - cvec
    r = chksiz(r,x,y) or cmatrix_alloc(x:sizes())
    _C.mad_cvec_subv(y.data, x.data, r.data, r:size()) return r
  elseif is_matrix(y) and is_matrix(x) then      -- mat - mat => vec - vec
    r = chksiz(r,x,y) or matrix_alloc(x:sizes())
    _C.mad_vec_sub(x.data, y.data, r.data, r:size()) return r
  elseif has_method(y, '__rsub_mat') then        -- mat - ?
    return y:__rsub_mat(x, r)
  end
  error("invalid arguments (unsupported matrix operation '-')")
end

function MC.__rsub_cpx (y, x, r)                 -- cpx - cmat => cpx - cvec
  r = chksiz(r,y) or cmatrix_alloc(y:sizes())
  _C.mad_cvec_subc_r(y.data, x.re, x.im, r.data, r:size()) return r
end

function MC.__sub (x, y, r)
  if is_number(x) then                           -- num - cmat => num - cvec
    r = chksiz(r,y) or cmatrix_alloc(y:sizes())
    _C.mad_cvec_subn(y.data, x, r.data, r:size()) return r
  elseif is_number(y) then                       -- cmat - num => cvec + -num
    r = chksiz(r,x) or cmatrix_alloc(x:sizes())
    _C.mad_cvec_addn(x.data, -y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- cmat - cpx => cvec + -cpx
    r = chksiz(r,x) or cmatrix_alloc(x:sizes())
    _C.mad_cvec_addc_r(x.data, -y.re, -y.im, r.data, r:size()) return r
  elseif is_matrix(y) then                       -- cmat - mat => cvec - vec
    r = chksiz(r,x,y) or cmatrix_alloc(x:sizes())
    _C.mad_cvec_subv(x.data, y.data, r.data, r:size()) return r
  elseif is_cmatrix(y) and is_cmatrix(x) then    -- cmat - cmat => cvec - cvec
    r = chksiz(r,x,y) or cmatrix_alloc(x:sizes())
    _C.mad_cvec_sub(x.data, y.data, r.data, r:size()) return r
  elseif has_method(y, '__rsub_cmat') then       -- cmat - ?
    return y:__rsub_cmat(x, r)
  end
  error("invalid arguments (unsupported matrix operation '-')")
end

-- mul

function MR.__rmul_cpx (y, x, r)                 -- cpx * mat => cpx * vec
  r = chksiz(r,y) or cmatrix_alloc(y:sizes())
  _C.mad_vec_mulc_r(y.data, x.re, x.im, r.data, r:size()) return r
end

function MR.__mul (x, y, r)
  if is_number(x) then                           -- num * mat => num * vec
    r = chksiz(r,y) or matrix_alloc(y:sizes())
    _C.mad_vec_muln(y.data, x, r.data, r:size()) return r
  elseif is_number(y) then                       -- mat * num => vec * num
    r = chksiz(r,x) or matrix_alloc(x:sizes())
    _C.mad_vec_muln(x.data, y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- mat * cpx => vec * cpx
    r = chksiz(r,x) or cmatrix_alloc(x:sizes())
    _C.mad_vec_mulc_r(x.data, y.re, y.im, r.data, r:size()) return r
  elseif is_cmatrix(y) then                      -- mat * cmat
    r = chksizm(r,x,y) or cmatrix_alloc(x:nrow(), y:ncol())
    _C.mad_mat_mulm(x.data, y.data, r.data, r:nrow(), r:ncol(), x:ncol()) return r
  elseif is_matrix(y) and is_matrix(x) then      -- mat * mat
    r = chksizm(r,x,y) or matrix_alloc(x:nrow(), y:ncol())
    _C.mad_mat_mul(x.data, y.data, r.data, r:nrow(), r:ncol(), x:ncol()) return r
  elseif has_method(y, '__rmul_mat') then        -- mat * ?
    return y:__rmul_mat(x, r)
  end
  error("invalid arguments (unsupported matrix operation '*')")
end

function MC.__rmul_cpx (y, x, r)                 -- cpx * cmat => cpx * cvec
  r = chksiz(r,y) or cmatrix_alloc(y:sizes())
  _C.mad_cvec_mulc_r(y.data, x.re, x.im, r.data, r:size()) return r
end

function MC.__mul (x, y, r)
  if is_number(x) then                           -- num * cmat => num * cvec
    r = chksiz(r,y) or cmatrix_alloc(y:sizes())
    _C.mad_cvec_muln(y.data, x, r.data, r:size()) return r
  elseif is_number(y) then                       -- cmat * num => cvec * num
    r = chksiz(r,x) or cmatrix_alloc(x:sizes())
    _C.mad_cvec_muln(x.data, y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- cmat * cpx => cvec * cpx
    r = chksiz(r,x) or cmatrix_alloc(x:sizes())
    _C.mad_cvec_mulc_r(x.data, y.re, y.im, r.data, r:size()) return r
  elseif is_matrix(y) then                       -- cmat * mat
    r = chksizm(r,x,y) or cmatrix_alloc(x:nrow(), y:ncol())
    _C.mad_cmat_mulm(x.data, y.data, r.data, r:nrow(), r:ncol(), x:ncol()) return r
  elseif is_cmatrix(y) and is_cmatrix(x) then    -- cmat * cmat
    r = chksizm(r,x,y) or cmatrix_alloc(x:nrow(), y:ncol())
    _C.mad_cmat_mul(x.data, y.data, r.data, r:nrow(), r:ncol(), x:ncol()) return r
  elseif has_method(y, '__rmul_cmat') then       -- cmat * ?
    return y:__rmul_cmat(x, r)
  end
  error("invalid arguments (unsupported matrix operation '*')")
end

-- element wise mul (.*)

function MR.__remul_cpx (y, x, r)                -- cpx .* mat => cpx * vec
  r = chksiz(r,y) or cmatrix_alloc(y:sizes())
  _C.mad_vec_mulc_r(y.data, x.re, x.im, r.data, r:size()) return r
end

function MR.__emul (x, y, r)
  if is_number(x) then                           -- num .* mat => num * vec
    r = chksiz(r,y) or matrix_alloc(y:sizes())
    _C.mad_vec_muln(y.data, x, r.data, r:size()) return r
  elseif is_number(y) then                       -- mat .* num => vec * num
    r = chksiz(r,x) or matrix_alloc(x:sizes())
    _C.mad_vec_muln(x.data, y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- mat .* cpx => vec * cpx
    r = chksiz(r,x) or cmatrix_alloc(x:sizes())
    _C.mad_vec_mulc_r(x.data, y.re, y.im, r.data, r:size()) return r
  elseif is_cmatrix(y) then                      -- mat .* cmat => vec * cvec
    r = chksiz(r,x,y) or cmatrix_alloc(x:sizes())
    _C.mad_cvec_mulv(y.data, x.data, r.data, r:size()) return r
  elseif is_matrix(y) and is_matrix(x) then      -- mat .* mat => vec * vec
    r = chksiz(r,x,y) or matrix_alloc(x:sizes())
    _C.mad_vec_mul(x.data, y.data, r.data, r:size()) return r
  elseif has_method(y, '__remul_mat') then       -- mat .* ?
    return y:__remul_mat(x, r)
  end
  error("invalid arguments (unsupported matrix operation '.*')")
end

function MC.__remul_cpx (y, x, r)                -- cpx .* cmat => cpx * cvec
  r = chksiz(r,y) or cmatrix_alloc(y:sizes())
  _C.mad_cvec_mulc_r(y.data, x.re, x.im, r.data, r:size()) return r
end

function MC.__emul (x, y, r)
  if is_number(x) then                           -- num .* cmat => num * cvec
    r = chksiz(r,y) or cmatrix_alloc(y:sizes())
    _C.mad_cvec_muln(y.data, x, r.data, r:size()) return r
  elseif is_number(y) then                       -- cmat .* num => cvec * num
    r = chksiz(r,x) or cmatrix_alloc(x:sizes())
    _C.mad_cvec_muln(x.data, y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- cmat .* cpx => cvec * cpx
    r = chksiz(r,x) or cmatrix_alloc(x:sizes())
    _C.mad_cvec_mulc_r(x.data, y.re, y.im, r.data, r:size()) return r
  elseif is_matrix(y) then                       -- cmat .* mat => cvec * vec
    r = chksiz(r,x,y) or cmatrix_alloc(x:sizes())
    _C.mad_cvec_mulv(x.data, y.data, r.data, r:size()) return r
  elseif is_cmatrix(y) and is_cmatrix(x) then    -- cmat .* cmat => cvec * cvec
    r = chksiz(r,x,y) or cmatrix_alloc(x:sizes())
    _C.mad_cvec_mul(x.data, y.data, r.data, r:size()) return r
  elseif has_method(y, '__remul_cmat') then      -- cmat .* ?
    return y:__remul_cmat(x, r)
  end
  error("invalid arguments (unsupported matrix operation '.*')")
end

-- div

function MR.__rdiv_cpx (y, x, r, rcond_)         -- cpx / mat
  local rank
  r = chksiz(r,y) or cmatrix_alloc(y:sizes())
  rank = _C.mad_mat_invc_r(y.data, x.re, x.im, r.data, y:nrow(), y:ncol(), rcond_ or -1)
  return r, rank
end

function MR.__div (x, y, r, rcond_)
  local rank
  if is_number(x) then                           -- num / mat
    r = chksiz(r,y) or matrix_alloc(y:sizes())
    rank = _C.mad_mat_invn(y.data, x, r.data, y:nrow(), y:ncol(), rcond_ or -1)
    return r, rank
  elseif is_number(y) then                       -- mat / num => vec / num
    r = chksiz(r,x) or matrix_alloc(x:sizes())
    _C.mad_vec_muln(x.data, 1/y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- mat / cpx => vec / cpx
    r = chksiz(r,x) or cmatrix_alloc(x:sizes()) ; y = 1/y
    _C.mad_vec_mulc_r(x.data, y.re, y.im, r.data, r:size()) return r
  elseif is_cmatrix(y) then                      -- mat / cmat
    r = chksizd(r,x,y) or cmatrix_alloc(x:nrow(), y:nrow())
    rank = _C.mad_mat_divm(x.data, y.data, r.data, r:nrow(), r:ncol(), x:ncol(), rcond_ or -1)
    return r, rank
  elseif is_matrix(y) and is_matrix(x) then      -- mat / mat
    r = chksizd(r,x,y) or matrix_alloc(x:nrow(), y:nrow())
    rank = _C.mad_mat_div(x.data, y.data, r.data, r:nrow(), r:ncol(), x:ncol(), rcond_ or -1)
    return r, rank
  elseif has_method(y, '__rdiv_mat') then        -- mat / ?
    return y:__rdiv_mat(x, r)
  end
  error("invalid arguments (unsupported matrix operation '/')")
end

function MC.__rdiv_cpx (y, x, r, rcond_)         -- cpx / cmat
  local rank
  r = chksiz(r,y) or cmatrix_alloc(y:sizes())
  rank = _C.mad_cmat_invc_r(y.data, x.re, x.im, r.data, y:nrow(), y:ncol(), rcond_ or -1)
  return r, rank
end

function MC.__div (x, y, r, rcond_)
  local rank
  if is_number(x) then                           -- num / cmat => num / cvec
    r = chksiz(r,y) or cmatrix_alloc(y:sizes())
    rank = _C.mad_cmat_invn(y.data, x, r.data, y:nrow(), y:ncol(), rcond_ or -1)
    return r, rank
  elseif is_number(y) then                       -- cmat / num => cvec / num
    r = chksiz(r,x) or cmatrix_alloc(x:sizes())
    _C.mad_cvec_muln(x.data, 1/y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- cmat / cpx => cvec / cpx
    r = chksiz(r,x) or cmatrix_alloc(x:sizes()) ; y = 1/y
    _C.mad_cvec_mulc_r(x.data, y.re, y.im, r.data, r:size()) return r
  elseif is_matrix(y) then                       -- cmat / mat
    r = chksizd(r,x,y) or cmatrix_alloc(x:nrow(), y:nrow())
    rank = _C.mad_cmat_divm(x.data, y.data, r.data, r:nrow(), r:ncol(), x:ncol(), rcond_ or -1)
    return r, rank
  elseif is_cmatrix(y) and is_cmatrix(x) then    -- cmat / cmat
    r = chksizd(r,x,y) or cmatrix_alloc(x:nrow(), y:nrow())
    rank = _C.mad_cmat_div(x.data, y.data, r.data, r:nrow(), r:ncol(), x:ncol(), rcond_ or -1)
    return r, rank
  elseif has_method(y, '__rdiv_cmat') then       -- cmat / ?
    return y:__rdiv_cmat(x, r)
  end
  error("invalid arguments (unsupported matrix operation '/')")
end

-- element wise div (./)

function MR.__rediv_cpx (y, x, r)                -- cpx ./ mat => cpx / vec
  r = chksiz(r,y) or cmatrix_alloc(y:sizes())
  _C.mad_vec_divc_r(y.data, x.re, x.im, r.data, r:size()) return r
end

function MR.__ediv (x, y, r)
  if is_number(x) then                           -- num ./ mat => num / vec
    r = chksiz(r,y) or matrix_alloc(y:sizes())
    _C.mad_vec_divn(y.data, x, r.data, r:size()) return r
  elseif is_number(y) then                       -- mat ./ num => vec / num
    r = chksiz(r,x) or matrix_alloc(x:sizes())
    _C.mad_vec_muln(x.data, 1/y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- mat ./ cpx => vec / cpx
    r = chksiz(r,x) or cmatrix_alloc(x:sizes()) ; y = 1/y
    _C.mad_vec_mulc_r(x.data, y.re, y.im, r.data, r:size()) return r
  elseif is_cmatrix(y) then                      -- mat ./ cmat => vec / cvec
    r = chksiz(r,x,y) or cmatrix_alloc(x:sizes())
    _C.mad_vec_divv(x.data, y.data, r.data, r:size()) return r
  elseif is_matrix(y) and is_matrix(x) then      -- mat ./ mat => vec / vec
    r = chksiz(r,x,y) or matrix_alloc(x:sizes())
    _C.mad_vec_div(x.data, y.data, r.data, r:size()) return r
  elseif has_method(y, '__rediv_mat') then       -- mat ./ ?
    return y:__rediv_mat(x, r)
  end
  error("invalid arguments (unsupported matrix operation './')")
end

function MC.__rediv_cpx (y, x, r)                -- cpx ./ cmat => cpx / cvec
  r = chksiz(r,y) or cmatrix_alloc(y:sizes())
  _C.mad_cvec_divc_r(y.data, x.re, x.im, r.data, r:size()) return r
end

function MC.__ediv (x, y, r)
  if is_number(x) then                           -- num ./ cmat => num / cvec
    r = chksiz(r,y) or cmatrix_alloc(y:sizes())
    _C.mad_cvec_divn(y.data, x, r.data, r:size()) return r
  elseif is_number(y) then                       -- cmat ./ num => cvec / num
    r = chksiz(r,x) or cmatrix_alloc(x:sizes())
    _C.mad_cvec_muln(x.data, 1/y, r.data, r:size()) return r
  elseif is_complex(y) then                      -- cmat ./ cpx => cvec / cpx
    r = chksiz(r,x) or cmatrix_alloc(x:sizes()) ; y = 1/y
    _C.mad_cvec_mulc_r(x.data, y.re, y.im, r.data, r:size()) return r
  elseif is_matrix(y) then                       -- cmat ./ mat => cvec / vec
    r = chksiz(r,x,y) or cmatrix_alloc(x:sizes())
    _C.mad_cvec_divv(x.data, y.data, r.data, r:size()) return r
  elseif is_cmatrix(y) and is_cmatrix(x) then    -- cmat ./ cmat => cvec / cvec
    r = chksiz(r,x,y) or cmatrix_alloc(x:sizes())
    _C.mad_cvec_div(x.data, y.data, r.data, r:size()) return r
  elseif has_method(y, '__rediv_cmat') then      -- cmat ./ ?
    return y:__rediv_cmat(x, r)
  end
  error("invalid arguments (unsupported matrix operation './')")
end

-- kadd (in place)

local kmax = 20
local kr   = ffi.new(       'num_t [?]', kmax)
local kc   = ffi.new(      'cnum_t [?]', kmax)
local krd  = ffi.new('const  num_t*[?]', kmax)
local kcd  = ffi.new('const cnum_t*[?]', kmax)

function MR.kadd (r, a, x)
  assert(is_iterable(a), "invalid argument #1 (iterable expected)")
  assert(is_iterable(x), "invalid argument #2 (iterable expected)")
  local k = #x
  assert(k <= kmax, "too many matrices")
  assert(k == #a, "incompatible number of coefficients")
  assert(is_matrix(x[k]), "incompatible matrix type")
  assert(nrow(x[k]) == nrow(r) and
         ncol(x[k]) == ncol(r), "incompatible matrix size")
  for i=1,k-1 do
    assert(is_matrix(x[i]), "incompatible matrix type")
    assert(nrow(x[i]) == nrow(x[i+1]) and
           ncol(x[i]) == ncol(x[i+1]), "incompatible matrix size")
    kr[i-1], krd[i-1] = a[i], x[i].data
  end
  kr[k-1], krd[k-1] = a[k], x[k].data
  _C.mad_vec_kadd(k, kr, krd, r.data, size(r)) return r
end

function MC.kadd (r, a, x)
  assert(is_iterable(a), "invalid argument #1 (iterable expected)")
  assert(is_iterable(x), "invalid argument #2 (iterable expected)")
  local k = #x
  assert(k <= kmax, "too many matrices")
  assert(k == #a, "incompatible number of coefficients")
  assert(is_cmatrix(x[k]), "incompatible matrix type")
  assert(nrow(x[k]) == nrow(r) and
         ncol(x[k]) == ncol(r), "incompatible matrix size")
  for i=1,k-1 do
    assert(is_cmatrix(x[i]), "incompatible matrix type")
    assert(nrow(x[i]) == nrow(x[i+1]) and
           ncol(x[i]) == ncol(x[i+1]), "incompatible matrix size")
    kc[i-1], kcd[i-1] = a[i], x[i].data
  end
  kc[k-1], kcd[k-1] = a[k], x[k].data
  _C.mad_cvec_kadd(k, kc, kcd, r.data, size(r)) return r
end

-- tmul

function MR.tmul (x, y, r)
  if is_cmatrix(y) then                         -- mat' * cmat
    r = chksiztm(r,x,y) or cmatrix_alloc(x:ncol(), y:ncol())
    _C.mad_mat_tmulm(x.data, y.data, r.data, r:nrow(), r:ncol(), x:nrow()) return r
  elseif is_matrix(y) and is_matrix(x) then     -- mat' * mat
    r = chksiztm(r,x,y) or matrix_alloc(x:ncol(), y:ncol())
    _C.mad_mat_tmul(x.data, y.data, r.data, r:nrow(), r:ncol(), x:nrow()) return r
  elseif has_method(y, '__rtmul_mat') then      -- mat' * ?
    return y:__rtmul_mat(x, r)
  end
  error("invalid arguments (unsupported matrix operation '*')")
end

function MC.tmul (x, y, r)
  if is_matrix(y) then                          -- cmat' * mat
    r = chksiztm(r,x,y) or cmatrix_alloc(x:ncol(), y:ncol())
    _C.mad_cmat_tmulm(x.data, y.data, r.data, r:nrow(), r:ncol(), x:nrow()) return r
  elseif is_cmatrix(x) and is_cmatrix(y) then   -- cmat' * cmat
    r = chksiztm(r,x,y) or cmatrix_alloc(x:ncol(), y:ncol())
    _C.mad_cmat_tmul(x.data, y.data, r.data, r:nrow(), r:ncol(), x:nrow()) return r
  elseif has_method(y, '__rtmul_cmat') then     -- cmat' * ?
    return y:__rtmul_cmat(x, r)
  end
  error("invalid arguments (unsupported matrix operation '*')")
end

-- mult

function MR.mult (x, y, r)
  if is_cmatrix(y) then                         -- mat * cmat'
    r = chksizmt(r,x,y) or cmatrix_alloc(x:nrow(), y:nrow())
    _C.mad_mat_multm(x.data, y.data, r.data, r:nrow(), r:ncol(), x:ncol()) return r
  elseif is_matrix(y) and is_matrix(x) then     -- mat * mat'
    r = chksizmt(r,x,y) or matrix_alloc(x:nrow(), y:nrow())
    _C.mad_mat_mult(x.data, y.data, r.data, r:nrow(), r:ncol(), x:ncol()) return r
  elseif has_method(y, '__rmult_mat') then      -- mat * ?'
    return y:__rmult_mat(x, r)
  end
  error("invalid arguments (unsupported matrix operation '*')")
end

function MC.mult (x, y, r)
  if is_matrix(y) then                          -- cmat * mat'
    r = chksizmt(r,x,y) or cmatrix_alloc(x:nrow(), y:nrow())
    _C.mad_cmat_multm(x.data, y.data, r.data, r:nrow(), r:ncol(), x:ncol()) return r
  elseif is_cmatrix(x) and is_cmatrix(y) then   -- cmat * cmat'
    r = chksizmt(r,x,y) or cmatrix_alloc(x:nrow(), y:nrow())
    _C.mad_cmat_mult(x.data, y.data, r.data, r:nrow(), r:ncol(), x:ncol()) return r
  elseif has_method(y, '__rmult_cmat') then     -- cmat * ?'
    return y:__rmult_cmat(x, r)
  end
  error("invalid arguments (unsupported matrix operation '*')")
end

-- solver, det, svd, eigenvalue, eigenvector ----------------------------------o

function MR.solve (a, b, rcond_)
  local r, rank = b:t():div(a:t(), nil, rcond_)
  return r:t(), rank
end

function MR.svd (x)
  local nr, nc = x:sizes()
  local rs, ru, rv = matrix_alloc(min(nr,nc),1), matrix_alloc(nr,nr), matrix_alloc(nc,nc)
  local info = _C.mad_mat_svd(x.data, ru.data, rs.data, rv.data, nr, nc)
  return ru, rs, rv, info
end

function MC.svd (x)
  local nr, nc = x:sizes()
  local rs, ru, rv = matrix_alloc(min(nr,nc),1), cmatrix_alloc(nr,nr), cmatrix_alloc(nc,nc)
  local info = _C.mad_cmat_svd(x.data, ru.data, rs.data, rv.data, nr, nc)
  return ru, rs, rv, info
end

function MR.det (x)
  local nr, nc = x:sizes()
  assert(nr == nc, "matrix must be square")
  if nr == 2 then -- fast stable 2x2 case
    local w = x.data[1]*x.data[2]
    local e = w - x.data[1]*x.data[2]
    return (x.data[0]*x.data[3] - w) + e, 0
  end
  local info = _C.mad_mat_det(x.data, res, nr)
  return res[0], info
end

function MC.det (x)
  local nr, nc = x:sizes()
  assert(nr == nc, "matrix must be square")
  if nr == 2 then -- fast stable 2x2 case
    local w = x.data[1]*x.data[2]
    local e = w - x.data[1]*x.data[2]
    return (x.data[0]*x.data[3] - w) + e, 0
  end
  local info = _C.mad_cmat_det(x.data, cres, nr)
  return cres[0], info
end

function MR.eigen (x)
  local nr, nc = x:sizes()
  assert(nr == nc, "matrix must be square")
  local w, vl, vr = cmatrix_alloc(nr, 1), matrix_alloc(nr,nr), matrix_alloc(nr,nr)
  local info = _C.mad_mat_eigen(x.data, w.data, vl.data, vr.data, nr)
  return w, vl, vr, info
end

function MC.eigen (x)
  local nr, nc = x:sizes()
  assert(nr == nc, "matrix must be square")
  local w, vl, vr = cmatrix_alloc(nr, 1), cmatrix_alloc(nr,nr), cmatrix_alloc(nr,nr)
  local info = _C.mad_cmat_eigen(x.data, w.data, vl.data, vr.data, nr)
  return w, vl, vr, info
end

-- FFT, convolution, correlation, covariance ----------------------------------o

function MR.fft (x, r_)
  local nr, nc = x:sizes()
  local r = chksiz(r_, x) or cmatrix_alloc(nr,nc)
  if nr == 1 or nc == 1
  then _C.mad_vec_fft(x.data, r.data, x:size())  -- 1D FFT
  else _C.mad_mat_fft(x.data, r.data, x:sizes()) -- 2D FFT
  end
  return r
end

function MC.fft (x, r_)
  local nr, nc = x:sizes()
  local r = chksiz(r_, x) or cmatrix_alloc(nr,nc)
  if nr == 1 or nc == 1
  then _C.mad_cvec_fft(x.data, r.data, x:size())  -- 1D FFT
  else _C.mad_cmat_fft(x.data, r.data, x:sizes()) -- 2D FFT
  end
  return r
end

MR.ifft = \ error("invalid argument #1 (cmatrix expected)")

function MC.ifft (x, r_)
  local nr, nc = x:sizes()
  local r = chksiz(r_, x) or cmatrix_alloc(nr,nc)
  if nr == 1 or nc == 1
  then _C.mad_cvec_ifft(x.data, r.data, x:size())  -- 1D FFT
  else _C.mad_cmat_ifft(x.data, r.data, x:sizes()) -- 2D FFT
  end
  return r
end

function MR.rfft (x, r_)
  local nr, nc, r = x:sizes()
  if nr == 1 or nc == 1 then -- 1D FFT
    nr, nc = floor(nr/2+1), floor(nc/2+1)
    r = r_ or cmatrix_alloc(nr,nc)
    assert(nr == r:nrow() and nc == r:ncol(), "incompatible matrix sizes")
    _C.mad_vec_rfft(x.data, r.data, x:size())
  else                       -- 2D FFT
    nc = floor(nc/2+1)
    r = r_ or cmatrix_alloc(nr,nc)
    assert(nr == r:nrow() and nc == r:ncol(), "incompatible matrix sizes")
    _C.mad_mat_rfft(x.data, r.data, x:sizes())
  end
  return r
end

MC.rfft  = \ error("invalid argument #1 (matrix expected)")
MR.irfft = \ error("invalid argument #1 (cmatrix expected)")

function MC.irfft (x, r)
  assert(is_matrix(r), "invalid argument #2 (matrix expected)")
  local nr, nc = r:sizes()
  if nr == 1 or nc == 1 then -- 1D FFT
    nr, nc = floor(nr/2+1), floor(nc/2+1)
    assert(nr == x:nrow() and nc == x:ncol(), "incompatible matrix sizes")
    _C.mad_cvec_irfft(x.data, r.data, r:size())
  else                       -- 2D FFT
    nc = floor(nc/2+1)
    assert(nr == x:nrow() and nc == x:ncol(), "incompatible matrix sizes")
    _C.mad_cmat_irfft(x.data, r.data, r:sizes())
  end
  return r
end

 -- convolution theorem
function MR.conv (x, y, r_)
  local r = r_ or x:same()
  local xf = x:rfft()
  if x.data == y.data
  then return xf:emul(xf      ,xf):irfft(r)
  else return xf:emul(y:rfft(),xf):irfft(r)
  end
end

function MC.conv (x, y, r_)
  local r = r_ or x:same()
  local xf = x:fft()
  if x.data == y.data
  then return xf:emul(xf     ,xf):ifft(r)
  else return xf:emul(y:fft(),xf):ifft(r)
  end
end

 -- correlation theorem
function MR.corr (x, y, r_)
  local r = r_ or x:same()
  local xf = x:rfft()
  if x.data == y.data
  then return xf:emul(xf      :conj(    ),xf):irfft(r)
  else return xf:emul(y:rfft():conj('in'),xf):irfft(r)
  end
end

function MC.corr (x, y, r_)
  local r = r_ or x:same()
  local xf = x:fft()
  if x.data == y.data
  then return xf:emul(xf     :conj(    ),xf):ifft(r)
  else return xf:emul(y:fft():conj('in'),xf):ifft(r)
  end
end

function MR.covar (x, y, d_, r_)
  local xc = x:center(x:same(), d_)
  if x.data == y.data
  then return xc:corr(xc                    , r_)
  else return xc:corr(y:center(y:same(), d_), r_)
  end
end

-- NFFT -----------------------------------------------------------------------o

function MR.nfft (x, p_, r_)
  if is_cmatrix(p_) and is_nil(r_) then p_, r_ = nil, p_ end -- right shift
  local r = r_ or x:same(0i)
  assert(is_cmatrix(r), "invalid argument #3 (cmatrix expected)")
  local nr, nc = (p_ and chksiz(x,p_) or x):sizes()
  if nr == 1 or nc == 1
  then _C.mad_vec_nfft(x.data, p_ and p_.data, r.data, nr*nc , r:size()) -- 1D NFFT
  else _C.mad_mat_nfft(x.data, p_ and p_.data, r.data, nr, nc, r:size()) -- 2D NFFT
  end
  return r
end

function MC.nfft (x, p_, r_)
  if is_cmatrix(p_) and is_nil(r_) then p_, r_ = nil, p_ end -- right shift
  local r = r_ or x:same(0i)
  assert(is_cmatrix(r), "invalid argument #3 (cmatrix expected)")
  local nr, nc = (p_ and chksiz(x,p_) or x):sizes()
  if nr == 1 or nc == 1
  then _C.mad_cvec_nfft(x.data, p_ and p_.data, r.data, nr*nc , r:size()) -- 1D NFFT
  else _C.mad_cmat_nfft(x.data, p_ and p_.data, r.data, nr, nc, r:size()) -- 2D NFFT
  end
  return r
end

MR.infft = \ error("invalid argument #1 (cmatrix expected)")

function MC.infft (x, p_, r_)
  if is_cmatrix(p_) and is_nil(r_) then p_, r_ = nil, p_ end -- right shift
  local r = p_ and (chksiz(r_, p_) or p_:same(0i)) or x:same(0i)
  assert(is_cmatrix(r), "invalid argument #3 (cmatrix expected)")
  local nr, nc = r:sizes()
  if nr == 1 or nc == 1
  then _C.mad_cvec_infft(x.data, p_ and p_.data, r.data, nr*nc , x:size()) -- 1D NFFT
  else _C.mad_cmat_infft(x.data, p_ and p_.data, r.data, nr, nc, x:size()) -- 2D NFFT
  end
  return r
end

-- linspace, logspace, factorial ----------------------------------------------o

local function linspace (start, stop_, size_)
  assert(is_scalar(start) and abs(start) < inf,
         "invalid argument #1 (finite scalar expected)")
  if is_nil(stop_) then start, stop_ = 0, start end
  assert(is_scalar(stop_) and abs(stop_) < inf,
         "invalid argument #2 (finite scalar expected)")
  if is_nil(size_) then size_ = 100 else size_ = math.ceil(size_) end
  assert(is_number(size_) and size_ > 0,
         "invalid argument #3 (positive number expected)")
  local v = (is_complex(start) or is_complex(stop_)) and cvector(size_) or vector(size_)
  local step = size_ > 1 and (stop_-start)/(size_-1) or 0
  for i=0,size_-1 do seti0(v, i, start+step*i) end
  return v
end

local function logspace (start, stop_, size_)
  assert(is_number(start) and start > 0 and start < inf or
         is_complex(start) and abs(start) < inf,
        "invalid argument #1 (positive finite number expected)")
  if is_nil(stop_) then start, stop_ = 1, start end
  assert(is_number(stop_) and stop_ > 0 and stop_ < inf or
         is_complex(stop_) and abs(stop_) < inf,
         "invalid argument #2 (positive finite number expected)")
  if is_nil(size_) then size_ = 100 else size_ = math.ceil(size_) end
  assert(is_number(size_) and size_ > 0,
         "invalid argument #3 (positive number expected)")
  local v = (is_complex(start) or is_complex(stop_)) and cvector(size_) or vector(size_)
  local logstart, logstop = log(start), log(stop_)
  local logstep = size_ > 1 and (logstop-logstart)/(size_-1) or 0
  for i=0,size_-1 do seti0(v, i, exp(logstart+logstep*i)) end
  return v
end

local fact_ = vector(171) -- memoize

local function fact (n)
  assert(n >= 0, "invalid argument #1 (positive integer expected)")
  return n <= 170 and geti0(fact_, n) or inf
end

do -- fill on load
  local a = 1
  for i=1,170 do a = a*i ; seti0(fact_, i, a) end
  seti0(fact_, 0, 1)
end

-- concatenation, conversion --------------------------------------------------o

MR.__len = MR.size

function MR.__concat (x, y, d_, r_)
  assert(isa_matrix(x), "invalid argument #1 (matrix expected)")
  assert(isa_matrix(y), "invalid argument #2 (matrix expected)")
  local nrx, ncx = x:sizes()
  local nry, ncy = y:sizes()
  local r
  if is_nil(d_) or d_ == 'vec' or d_ == 'col' then -- concat columns (vectical)
    local nr, nc = nrx + nry, ncx
    assert(ncx == ncy and (is_nil(r_) or nr == r_:nrow() and nc == r_:ncol()),
           "incompatible matrix sizes")
    local r = r_ or x:same(x[1]+y[1],nr,nc)
    local nx, ny = nrx * nc, nry * nc
    for i=0,nx-1 do seti0(r,i   , geti0(x,i)) end
    for i=0,ny-1 do seti0(r,i+nx, geti0(y,i)) end
    if d_ == 'vec' then r:reshape(nr*nc) end
    return r
  elseif d_ == 'row' then                          -- concat rows (horizontal)
    local nr, nc = nrx, ncx + ncy
    assert(nrx == nry and (is_nil(r_) or nr == r_:nrow() and nc == r_:ncol()),
           "incompatible matrix sizes")
    local r = r_ or x:same(x[1]+y[1],nr,nc)
    for i=0,nr-1 do
      for j=0,ncx-1 do set0(r,i,j    , get0(x,i,j)) end
      for j=0,ncy-1 do set0(r,i,j+ncx, get0(y,i,j)) end
    end
    return r
  end
  error("invalid argument #3 (string 'vec', row' or 'col' expected)")
end

function MR.tostring (x, sep_, lsep_)
  local nr, nc = x:sizes()
  local r, c = table.new(nr,0), table.new(nc,0)
  for i=0,nr-1 do
    for j=0,nc-1 do
      c[j+1] = tostring(get0(x,i,j))
    end
    r[i+1] = table.concat(c, sep_ or ' ')
  end
  return table.concat(r, lsep_ or '\n')
end

function MR.totable (x, r_)
  assert(is_nil(r_) or is_table(r_), "invalid argument #2 (table expected)")
  local nr, nc, r = x:sizes()
  if nc == 1 then
    r = r_ or table.new(nr*nc,0)
    for i=0,nr*nc-1 do r[i+1] = geti0(x,i) end
  else
    r = r_ or table.new(nr,0)
    for i=0,nr-1 do
      local c = r[i+1] or table.new(nc,0)
      assert(is_table(c), "invalid argument #2 (table of tables expected)")
      for j=0,nc-1 do c[j+1] = get0(x,i,j) end
      r[i+1] = c
    end
  end
  return r
end

-- I/O -----------------------------------------------------------------------o

function MR.write (x, filnam_, name_, eps_)
  eps_ = eps_ or eps
  local file = openfile(filnam_, 'w', '.dat')
  local nr, nc, v = x:sizes()
  file:write(name_ or '', '[',nr,'x',nc, is_cmatrix(x) and 'i' or '','] =\n')
  local tostr = is_cmatrix(x) and tostring or num2str
  local zero  = is_cmatrix(x) and 0i or 0
  for i=0,nr-1 do
    file:write('  ')
    for j=0,nc-1 do
      v = get0(x,i,j)
      file:write(tostr(abs(v) >= eps_ and v or zero), j==nc-1 and '\n' or '  ')
    end
  end

  if is_string(filnam_) then file:close() else file:flush() end
  return x
end

function MR.print (x, name_, eps_)
  if is_nil(eps_) and is_number(name_) then
    name_, eps_ = nil, name_ -- right shift
  end
  return x:write(nil, name_, eps_)
end

function MR.read (_, filnam_)
  local file = openfile(filnam_, 'r', '.dat')
  local def = file:read()
  if not def then return end

  local _, _, nrs, ncs, cpx = string.find(def, "^[^[]*%[(%d+)x(%d+)(i?)%]%s*=")
  local nr, nc = tonumber(nrs), tonumber(ncs)
  local i, x, v, to, row, ncol = 0, nil

  if cpx == 'i' or cpx == 'I'
  then x, toval = cmatrix(nr, nc), tocomplex
  else x, toval =  matrix(nr, nc), tonumber
  end

  for line in file:lines() do
    if i == nr then break end
    i = i+1
    row, ncol = strsplitall(line, " \t", nil, row)
    assertf(ncol == nc,
            "invalid format row %d (%d columns expected, got %d)", i, nc, ncol)

    for j=1,nc do
      v = toval(row[j])
      if is_nil(v) then
        errorf("invalid input row %d column %d (scalar expected, got '%s')",
               i, j, row[j])
      end
      x:set(i,j, v)
    end
  end
  assertf(i == nr, "invalid format (%d rows expected, got %d)", nr, i)

  if is_string(filnam_) then file:close() end
  return x
end

-- metamethods ----------------------------------------------------------------o

MR.unm = \x,r_ -> MR.__unm(x,nil,r_)

MR.  add, MR.  sub, MR.  mul, MR.  div, MR.  mod, MR.  pow =
MR.__add, MR.__sub, MR.__mul, MR.__div, MR.__mod, MR.__pow

MC.  add, MC.  sub, MC.  mul, MC.  div, MC.  mod, MC.  pow =
MC.__add, MC.__sub, MC.__mul, MC.__div, MC.__mod, MC.__pow

MR.  emul, MR.  ediv, MR.  emod, MR.  epow =
MR.__emul, MR.__ediv, MR.__emod, MR.__epow

MC.  emul, MC.  ediv, MC.  emod, MC.  epow =
MC.__emul, MC.__ediv, MC.__emod, MC.__epow

MR.  eq, MR.  same, MR.  copy, MR.length, MR.  concat =
MR.__eq, MR.__same, MR.__copy, MR.__len , MR.__concat

MC.  eq, MC.  same, MC.  copy, MC.length, MC.  concat =
MC.__eq, MC.__same, MC.__copy, MC.__len , MC.__concat

local function iter (x, i)
  if i < size(x) then return i+1, geti0(x, i) end
end

MR.__ipairs = \s -> (iter, s, 0)
MR.__pairs  = \s -> (iter, s, 0)

local type = type

function MR.__index (s, i)
  if type(i) == 'number'
  then return geti_s(s, i)
  else return MR[i]
  end
end

function MC.__index (s, i)
  if type(i) == 'number'
  then return geti_s(s, i)
  else return MC[i]
  end
end

function MR.__newindex (s, i, x)
  if type(i) == 'number'
  then seti_s(s, i, x)
  else error("invalid matrix member '".. tostring(i) .."'")
  end
end

-- MR -> MC -------------------------------------------------------------------o

for k,v in pairs(MR) do
  if is_nil(MC[k]) then MC[k] = v end
end

-- only MR

local MROT = require 'madl_matrot' -- rotation matrices (in place)

for k,v in pairs(MROT) do
  assert(is_nil(MR[k]), "duplicated matrix method detected (unexpected)")
  MR[k] = v
end

-- env ------------------------------------------------------------------------o

MAD.gmath.fact = fact

MAD.typeid.is_vector  = is_vector
MAD.typeid.is_matrix  = is_matrix
MAD.typeid.is_cvector = is_cvector
MAD.typeid.is_cmatrix = is_cmatrix
MAD.typeid.isa_vector = isa_vector
MAD.typeid.isa_matrix = isa_matrix

-- metatables -----------------------------------------------------------------o

MR.__metatable = MR
MC.__metatable = MC

ffi.metatype( matrix_ctor , MR)
ffi.metatype(cmatrix_ctor , MC)
ffi.metatype( matrix_cview, MR)
ffi.metatype(cmatrix_cview, MC)

-- end ------------------------------------------------------------------------o
return {
  vector   = vector,
  matrix   = matrix,
  cvector  = cvector,
  cmatrix  = cmatrix,
  linspace = linspace,
  logspace = logspace,
  -- __help   = require 'madh_matrix',
}
