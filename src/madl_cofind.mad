--[=[
 o-----------------------------------------------------------------------------o
 |
 | Closed Orbit module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local warn, vector, matrix, command, track        in MAD
local cvname, has_dp                              in MAD.gphys
local is_positive, is_boolean                     in MAD.typeid
local errorf, assertf                             in MAD.utility
local abs                                         in math

local I  = matrix(6):eye()
local I4 = matrix(4):eye()

-- cofind algorithms ----------------------------------------------------------o

local method = {}

function method.newton (X0, X, R, tol, dptol)
  local dX, rnk

  -- check for 4D or 6D
  if has_dp(R, dptol) then    -- 6D case
    dX, rnk = (R-I):solve(X-X0)

    if rnk < 6 then
      warn("singular matrix occurred during 6D closed orbit search.")
      return rnk, "Singular"
    end

    -- adjust orbit
    X0:sub(dX,X0)
  else                        -- 4D case
    local X4 = X:getrow(1..4) - X0:getrow(1..4)
    local R4 = R:getsub(1..4, 1..4) - I4
    dX, rnk = R4:solve(X4)

    if rnk < 4 then
      warn("singular matrix occurred during 4D closed orbit search.")
      return rnk, "Singular"
    end

    -- adjust orbit
    X4 = X0:getrow(1..4) - dX
    X0:zeros():copy(X4)
  end

  -- return if last applied correction is below tolerance
  if dX:maxabs() < tol then
    return rnk, rnk == 4 and "4D" or "6D"
  end
end

-- cofind using jacobian ------------------------------------------------------o

local function cofind_jacob (self, track)
  local cotol, coiter, codiff, codptol, comethod in self
  local costep = method[comethod]

  -- build 6D initial orbit and final orbit translation
  local X0 = vector(6):fill(self.X0)
  local X1 = vector(6):fill(self.X1)

  -- track 6+1 particles to compute jacobian by finite differences
  local Xs = { 0,0,0,0,0,0,X0 }
  for j=1,6 do Xs[j] = X0:same() end

  -- search for fix point
  for itr=1,coiter do

    -- init dx_j
    for j=1,6 do
      Xs[j]:copy(X0):seti(j, X0[j]+codiff)
    end

    -- track 6D x 7 particles
    local _, mflw = track { X0=Xs }

    -- retrieve 6D orbit and one-turn map
    local X, R = vector(6), matrix(6)

    for i=1,6 do
      X[i] = mflw[7][cvname[i]]
      for j=1,6 do -- compute jacobian df(x_i)/dx_j
        R:set(i,j, (mflw[j][cvname[i]] - X[i])/codiff)
      end
    end

    -- update X0 = X0-dX if |dX| >= cotol, where dX solves (R-I)dX = X-X0-X1
    local rnk, typ = costep(X0, X-X1, R, cotol, codptol)

    -- orbit, one-turn map, rank of R, "4D" | "6D" | "Singular", no iterations
    if typ then return X0, R, rnk, typ, itr end
  end

  errorf("closed orbit did not converge in %d iterations", coiter)
end

-- cofind using map -----------------------------------------------------------o

local function cofind_map (self, track)
  local cotol, coiter, codptol, comethod in self
  local costep = method[comethod]

  -- build 6D initial orbit and final orbit translation
  local X0 = vector(6):fill(self.X0)
  local X1 = vector(6):fill(self.X1)

  -- search for fix point
  for itr=1,coiter do

    -- track 6D x 1 damap
    local _, mflw = track { X0=X0 }

    -- retrieve 6D orbit and one-turn map
    local X = mflw[1]:get0()
    local R = mflw[1]:get1()

    -- update X0 = X0-dX if |dX| >= cotol, where dX solves (R-I)dX = X-X0-X1
    local rnk, typ = costep(X0, X-X1, R, cotol, codptol)

    -- orbit, one-turn map, rank of R, "4D" | "6D" | "Singular", no iterations
    if typ then return X0, R, rnk, typ, itr end
  end

  errorf("closed orbit did not converge in %d iterations", coiter)
end

-- cofind command -------------------------------------------------------------o

local function exec (self)
  local cotol, coiter, codiff, codptol, cousemap, comethod in self
  assertf(is_positive(cotol ), "invalid cotol %.15g (positive number expected)" , cotol )
  assertf(is_positive(coiter), "invalid coiter %d (positive number expected)"   , coiter)
  assertf(is_positive(codiff), "invalid codiff %.15g (positive number expected)", codiff)
  assertf(is_positive(codptol),"invalid codptol %.15g (positive number expected)",codptol)
  assertf(is_boolean(cousemap),"invalid cousemap %s (boolean expected)",tostring(cousemap))
  assertf(method[comethod]   , "invalid comethod '%s' (unsupported)", comethod)

  -- prepare the track template
  local trck0 = track 'cotrack' {

    -- forwarded options
    beam      = self.beam,
    sequence  = self.sequence,
    range     = self.range,
    sdir      = self.sdir,

    s0        = self.s0,
    X0        = self.X0,
    X1        = self.X1,

    nturn     = self.nturn,
    nslice    = self.nslice,
    method    = self.method,

    mapdef    = cousemap and {xy=1} or nil,

    -- overridden options
    save      = false,
    exec      = false,
  }

  -- search closed orbit using Newton algorithm
  if cousemap
  then return cofind_map   (self, trck0) -- use one-turn map
  else return cofind_jacob (self, trck0) -- use computed jacobian
  end
end

local cofind = command 'cofind' {
  beam=nil,          -- beam (required)                                   (trck)
  sequence=nil,      -- sequence (required)                               (trck)
  range=nil,         -- range of tracking                                 (trck)
  sdir=1,            -- s-direction of tracking (1 or -1)                 (trck)

  s0=0,              -- initial s                                         (trck)
  X0={0,0,0,0,0,0},  -- initial coordinates for orbit search              (trck)
  X1={0,0,0,0,0,0},  -- optional final coordinates translation            (cofn)

  nturn=1,           -- number of turns                                   (trck)
  nslice=1,          -- number of slice for each element                  (trck)
  method='simple',   -- default integrator                                (trck)

  cotol=1e-8,        -- closed orbit tolerance                            (cofn)
  coiter=20,         -- maximum number of iteration                       (cofn)
  codiff=1e-10,      -- finite differences steps                          (cofn)
  codptol=1e-12,     -- static vs dynamic tolerance                       (cofn)
  cousemap=true,     -- use DA to compute the jacobian                    (cofn)
  comethod='newton', -- default optimizer                                 (cofn)

  exec=exec,      -- command to execute upon children creation
} :set_readonly() -- reference cofind command is readonly

-- end ------------------------------------------------------------------------o
return { cofind = cofind }
