--[=[
 o-----------------------------------------------------------------------------o
 |
 | object module (object model)
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide an object model to support prototype-based programming with value
    semantic for functions stored in variables and further extensions.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local is_nil, is_boolean, is_number, is_string, is_table, is_rawtable,
      is_function, is_functor, is_metaname,is_callable, is_iterable,
      is_mappable                                               in MAD.typeid
local bset, btst, bclr, bnot, band, bor, lshift, eq             in MAD.operator
local bsearch, lsearch, kpairs, openfile, assertf               in MAD.utility
local functor                                                   in MAD.gfunc

-- implementation -------------------------------------------------------------o

-- Root of all objects, forward declaration
local object

-- object members
local _var, _mth = {}, {} -- hidden keys

-- reserved flags (bits)
local _flg = {} -- hidden key
local flg_ro, flg_cl = 0, 1 -- flags id for readonly and class
local flg_free = 2          -- used flags (0 - 1), free flags (2 - 31)

-- instance and metatable of 'incomplete objects' proxy
local obj0 = setmetatable({}, {
  __index     := error("forbidden read access to incomplete object" , 2),
  __newindex  := error("forbidden write access to incomplete object", 2),
  __metatable  = false,
})

-- helpers

local function name (a)
  local var = rawget(a,_var)
  return rawget(var,'__id') or ('? <: ' .. var.__id)
end

local function parent (a)
  return getmetatable(rawget(a,'__index'))
end

local function init (a)
  local init_mm = rawget(getmetatable(a), '__init')
  if init_mm then return init_mm(a) end
  return a
end

local function fclass (a)
  return btst(rawget(a,_flg) or 0, flg_cl)
end

local function freadonly (a)
  return btst(rawget(a,_flg) or 0, flg_ro)
end

local function set_class (a)
  rawset(a,_flg, bset(rawget(a,_flg) or 0, flg_cl))
  return a
end

local function is_object (a) -- exported
  return is_table(a) and rawget(a,_var) ~= nil
end

local function is_class (a) -- exported
  return is_table(a) and fclass(a)
end

local function is_instanceOf (a, b) -- exported
  if is_object(a) and is_class(b) then
    repeat a = parent(a) until not a or rawequal(a,b)
    return not not a
  end
  return false
end

local function copy_methods (a, mm)
  local cm = table.new(0,50)
  for k,v in pairs(mm) do cm[k] = v end
  rawset(a, _mth, cm)
  return cm
end

local function copy_metamethods (a, mm)
  assert(mm.__metatable == mm, "invalid object metatable")
  mm.__metatable = nil -- unprotect change
  local cm = table.new(0,8)
  for k,v in pairs(mm) do cm[k] = v end
  setmetatable(a, cm)
  mm.__metatable, cm.__metatable = mm, cm
  return cm
end

-- metamethods ----------------------------------------------------------------o

local MT = {}

-- objects are proxies controlling variables access and inheritance
function MT:__call (a, b) -- object constructor (define the object-model)
  if is_string(a) or is_nil(a) then                     -- [un]named object
    if is_nil(b) then                                   -- proxy
      local obj = {__id=a, [_var]=obj0, [_mth]=obj0, __index=rawget(self,_var)}
      return setmetatable(obj, getmetatable(self))      -- incomplete object
    elseif is_rawtable(b) then                          -- proxy
      local obj = {[_var]=b,[_mth]=rawget(self,_mth),__index=rawget(self,_var)}
      b.__id=a ; setmetatable(b, obj) ; set_class(self) -- set fast inheritance
      return init(setmetatable(obj, getmetatable(self)))-- complete object
    end
  elseif is_rawtable(a) then
    if rawget(self,_var) == obj0 then                   -- final. incompl. obj
      local par = parent(self) ; set_class(par)
      a.__id, self.__id = self.__id, nil                -- transfer id
      rawset(self,_var, setmetatable(a, self));         -- set fast inheritance
      rawset(self,_mth, rawget(par, _mth))              -- set shared methods
      return init(self)
    else                                                -- unnamed object
      local obj = {[_var]=a,[_mth]=rawget(self,_mth),__index=rawget(self,_var)}
      setmetatable(a, obj) ; set_class(self)            -- set fast inheritance
      return init(setmetatable(obj, getmetatable(self)))-- complete object
    end
  end
  error(is_nil(b) and "invalid argument #1 (string or raw table expected)"
                  or  "invalid argument #2 (raw table expected)", 2)
end

function MT:__index (k) -- methods have the precedence over variables
  local m = rawget(self,_mth)[k]
  if m then return m end

  local v = rawget(self,_var)[k]
  if type(k) == 'string' and type(v) == 'function'
  then return v(self)
  else return v end
end

function MT:__newindex (k, v)
  if freadonly(self) or type(k) == 'string'
     and (rawget(self,_mth)[k] or string.sub(k,1,2) == '__') then
    error("forbidden write access to '" .. name(self) .. "." .. tostring(k) ..
          "' (readonly object, method or variable)", 2)
  end
  rawget(self,_var)[k] = v      -- note: must use [k] for obj0
end

function MT:__len ()
  local var = rawget(self,_var)
  if is_nil(var[1]) then return 0 end -- fast
  while is_nil(rawget(var,1)) do      -- slow
    var  = rawget(self,'__index')
    self = getmetatable(var)
  end
  return rawlen(var)
end

local function iter (var, key) -- scan only numbers and strings
  local k, v = next(var, key)
  while type(k) ~= 'string' and type(k) ~= 'number' and k do
    k, v = next(var, k)
  end
  return k, v
end

local function pairs_iter (self)
  return iter, rawget(self,_var), nil
end

local function ipairs_iter (self)
  return ipairs(rawget(self,_var))
end

MT.__pairs  =  pairs_iter
MT.__ipairs = ipairs_iter

function MT:__tostring()
  return string.format("object: '%s' %p", name(self), self)
end

-- methods --------------------------------------------------------------------o

local MF = {}

MF.is_class      = is_class
MF.is_instanceOf = is_instanceOf

function MF:raw_len ()
  return rawlen(rawget(self,_var))    -- no inheritance
end

function MF:raw_get (k)
  return rawget(rawget(self,_var),k)  -- no inheritance nor function evaluation
end

function MF:raw_set (k, v)
  rawset(rawget(self,_var), k, v)     -- no protection!!
end

function MF:mth_get (k)               -- retrieve method (only)
  return rawget(self,_mth)[k]
end

function MF:var_raw (k)
  return rawget(self,_var)[k]         -- no function evaluation with inheritance
end

function MF:var_val (k, v)            -- string key with value function
  if type(k) == 'string' and type(v) == 'function'
  then return v(self)
  else return v end
end

function MF:var_get (k)           -- reusing var_raw and var_val breaks inlining
  local v = rawget(self,_var)[k]
  if type(k) == 'string' and type(v) == 'function'
  then return v(self)
  else return v end
end

function MF:is_readonly ()
  assert(is_object(self), "invalid argument #1 (object expected)")
  return freadonly(self)
end

function MF:set_readonly (set_)
  assert(is_object(self), "invalid argument #1 (object expected)")
  if set_ ~= false
  then rawset(self, _flg, bset(rawget(self,_flg) or 0, flg_ro))
  else rawset(self, _flg, bclr(rawget(self,_flg) or 0, flg_ro))
  end
  return self
end

function MF:get_variables (lst, noeval_)
  assert(is_object(self) , "invalid argument #1 (object expected)")
  assert(is_iterable(lst), "invalid argument #2 (iterable expected)")
  local n   = #lst
  local res = table.new(0,n)
  local get = noeval_ == true and MF.var_raw or MF.var_get
  for i=1,n do res[lst[i]] = get(self, lst[i]) end
  return res -- key -> val
end

function MF:set_variables (tbl, override_)
  assert(is_object(self)    , "invalid argument #1 (object expected)")
  assert(is_mappable(tbl)   , "invalid argument #2 (mappable expected)")
  assert(not freadonly(self), "forbidden write access to readonly object")
  local var = rawget(self,_var)
  local id  = rawget(var,'__id')
  for k,v in pairs(tbl) do
    assert(is_nil(rawget(var,k)) or override_ ~= false, "cannot override variable")
    var[k] = v
  end
  var.__id = id
  return self
end

function MF:wrap_variables (tbl)
  assert(is_object(self)    , "invalid argument #1 (object expected)")
  assert(is_mappable(tbl)   , "invalid argument #2 (mappable expected)")
  assert(not freadonly(self), "forbidden write access to readonly object")
  local var = rawget(self,_var)
  local id  = rawget(var,'__id')
  for k,f in pairs(tbl) do
    local v, newv = var[k]
    assert(not is_nil(v) , "invalid variable (nil value)")
    assert(is_callable(f), "invalid wrapper (callable expected)")
    if is_callable(v) then newv = f(v) else newv = f(\ v) end -- simplify user's side.
    if is_functor(v) and not is_functor(newv) then
      newv = functor(newv)                   -- newv must maintain v's semantic.
    end
    var[k] = newv
  end
  var.__id = id
  return self
end

function MF:set_functors (tbl, override_, strict_)
  assert(is_object(self)    , "invalid argument #1 (object expected)")
  assert(is_mappable(tbl)   , "invalid argument #2 (mappable expected)")
  assert(not freadonly(self), "forbidden write access to readonly object")
  local var = rawget(self,_var)
  local id  = rawget(var,'__id')
  for k,f in pairs(tbl) do
    assert(is_string(k), "invalid key (function name expected)")
    assert(is_callable(f) or strict_ == false, "invalid value (callable expected)")
    assert(is_nil(rawget(var,k)) or override_ ~= false, "cannot override function")
    var[k] = is_function(f) and functor(f) or f
  end
  var.__id = id
  return self
end

function MF:set_methods (tbl, override_, strict_)
  assert(is_object(self)    , "invalid argument #1 (object expected)")
  assert(is_mappable(tbl)   , "invalid argument #2 (mappable expected)")
  assert(not freadonly(self), "forbidden write access to readonly object")
  local sm, pm = rawget(self,_mth), rawget(parent(self),_mth) or MF
  if sm == pm then -- create new methods table if same as parent
    assert(not fclass(self), "invalid method write access (unexpected class)")
    sm = copy_methods(self, pm)
  end
  for k,f in pairs(tbl) do
    assertf(is_string(k), "invalid key '%s' (method name expected)", tostring(k))
    assert(is_callable(f) or strict_ == false, "invalid value (callable expected)")
    assertf(is_nil(rawget(sm,k)) or override_ == true, "cannot override method '%s'", k)
    sm[k] = f
  end
  return self
end

function MF:set_metamethods (tbl, override_, strict_)
  assert(is_object(self)    , "invalid argument #1 (object expected)")
  assert(is_mappable(tbl)   , "invalid argument #2 (mappable expected)")
  assert(not freadonly(self), "forbidden write access to readonly object")
  local sm, pm = getmetatable(self), getmetatable(parent(self)) or MT
  if sm == pm then -- create new metatable if same as parent
    assert(not fclass(self), "invalid metatable write access (unexpected class)")
    sm = copy_metamethods(self, pm)
  end
  for k,m in pairs(tbl) do
    assertf(is_metaname(k) or strict_ == false, "invalid key '%s' (metamethod expected)", tostring(k))
    assertf(is_nil(rawget(sm,k)) or override_ == true, "cannot override metamethod '%s'", k)
    sm[k] = m
  end
  return self
end

local function final_err (self)
  error("invalid object creation ('"..name(self).."' is qualified as final)", 2)
end

function MF:set_final ()
  return set_metamethods(self, {__call=final_err}, true)
end

function MF:get_varkeys (class_)
  assert(is_object(self)                    , "invalid argument #1 (object expected)")
  assert(is_nil(class_) or is_object(class_), "invalid argument #2 (object expected)")
  local lst, key = table.new(8,1), table.new(0,8)
  while self and not rawequal(self, class_) do
    for k,v in kpairs(self) do
      if not (key[k] or is_functor(v)) and is_string(k) and string.sub(k,1,2) ~= '__'
      then lst[#lst+1], key[k] = k, k
      end
    end
    self = parent(self)
  end
  assert(rawequal(self, class_),"invalid argument #2 (parent of argument #1 expected)")
  return lst
end

function MF:insert (idx_, val)
  assert(is_object(self)    , "invalid argument #1 (object expected)")
  assert(not freadonly(self), "forbidden write access to readonly object")
  table.insert(rawget(self,_var), idx_, val)
  return self
end

function MF:remove (idx_)
  assert(is_object(self)    , "invalid argument #1 (object expected)")
  assert(not freadonly(self), "forbidden write access to readonly object")
  return table.remove(rawget(self,_var), idx_)
end

function MF:move (idx1, idx2, idxto, dest_)
  dest_ = dest_ or self
  assert(is_object(self)     , "invalid argument #1 (object expected)")
  assert(is_object(dest_)    , "invalid argument #2 (object expected)")
  assert(not freadonly(dest_), "forbidden write access to readonly object")
  table.move(rawget(self,_var), idx1, idx2, idxto, rawget(dest_,_var))
  return dest_
end

function MF:sort (cmp_)
  assert(is_object(self)    , "invalid argument #1 (object expected)")
  assert(not freadonly(self), "forbidden write access to readonly object")
  table.sort(rawget(self,_var), cmp_)
  return self
end

function MF:bsearch (val, cmp_, low_, high_)
  assert(is_object(self), "invalid argument #1 (object expected)")
  return bsearch(rawget(self,_var), val, cmp_, low_, high_)
end

function MF:lsearch (val, equ_, low_, high_)
  assert(is_object(self), "invalid argument #1 (object expected)")
  return lsearch(rawget(self,_var), val, equ_, low_, high_)
end

function MF:clear_array ()
  assert(is_object(self)    , "invalid argument #1 (object expected)")
  assert(not freadonly(self), "forbidden write access to readonly object")
  local var = rawget(self,_var)
  for i=1,rawlen(var) do var[i]=nil end
  return self
end

function MF:clear_variables ()
  assert(is_object(self)    , "invalid argument #1 (object expected)")
  assert(not freadonly(self), "forbidden write access to readonly object")
  local var = rawget(self,_var)
  local id  = rawget(var,'__id')
  for k in kpairs(self) do var[k]=nil end
  var.__id = id
  return self
end

function MF:clear_all ()
  assert(is_object(self)    , "invalid argument #1 (object expected)")
  assert(not freadonly(self), "forbidden write access to readonly object")
  local var = rawget(self,_var)
  local id  = rawget(var,'__id')
  for k in pairs_iter(self) do var[k]=nil end -- table.clear destroys all keys
  var.__id = id
  return self
end

-- inheritance

function MF:set_parent (newp)
  assert(is_object(self), "invalid argument #1 (object expected)")
  assert(is_object(newp), "invalid argument #2 (object expected)")
  if freadonly(self) then
    error("forbidden write access to readonly object '" .. name(self) .. "'", 2)
  end
  local spar = self.parent
  if getmetatable(newp) ~= getmetatable(spar) then
    error("new and current parent do not share same metamethods")
  end
  if newp.parent ~= spar.parent then
    error("new and current parent do not inherit from same direct parent")
  end
  rawset(self,'__index', rawget(newp,_var))
  set_class(newp)
  return self
end

-- copy

function MF:same (name_)
  assert(is_object(self)                  ,"invalid argument #1 (object expected)")
  assert(is_nil(name_) or is_string(name_),"invalid argument #2 (string expected)")
  -- same shares the same parent
  local par = parent(self)
  local sam = par(name_, {})
  -- methods
  local sm, pm = rawget(self, _mth), rawget(par, _mth)
  if sm ~= pm then copy_methods(sam, sm) end
  -- metatable
  local sm, pm = getmetatable(self), getmetatable(par)
  if sm ~= pm then copy_metamethods(sam, sm) end
  return sam
end

function MF:copy (name_)
  assert(is_object(self)                  ,"invalid argument #1 (object expected)")
  assert(is_nil(name_) or is_string(name_),"invalid argument #2 (string expected)")
  local cpy = MF.same(self, name_ or MF.raw_get(self,'__id'))
  local var, cvar = rawget(self,_var), rawget(cpy,_var)
  local id  = rawget(cvar,'__id')
  for k,v in pairs_iter(self) do cvar[k] = v end
  cvar.__id = id
  return cpy
end

MT.__same = MF.same
MT.__copy = MF.copy

-- flags

local flg_mask = lshift(-1, flg_free)
local flg_notmask = bnot(flg_mask)

function MF:test_flag (n)
  assert(is_object(self), "invalid argument #1 (object expected)")
  assert(is_number(n)   , "invalid argument #2 (number expected)")
  return btst(rawget(self,_flg) or 0, n)
end

function MF:set_flag (n)
  assert(is_object(self), "invalid argument #1 (object expected)")
  assert(is_number(n)   , "invalid argument #2 (number expected)")
  if n >= flg_free then
    rawset(self, _flg, bset(rawget(self,_flg) or 0, n))
  end
  return self
end

function MF:clear_flag (n)
  assert(is_object(self), "invalid argument #1 (object expected)")
  assert(is_number(n)   , "invalid argument #2 (number expected)")
  if n >= flg_free then
    rawset(self, _flg, bclr(rawget(self,_flg) or 0, n))
  end
  return self
end

function MF:get_flags ()
  assert(is_object(self), "invalid argument #1 (object expected)")
  return rawget(self,_flg) or 0
end

function MF:test_flags (flags)
  assert(is_object(self) , "invalid argument #1 (object expected)")
  assert(is_number(flags), "invalid argument #2 (number expected)")
  return band(rawget(self,_flg) or 0, flags) ~= 0
end

function MF:set_flags (flags)
  assert(is_object(self) , "invalid argument #1 (object expected)")
  assert(is_number(flags), "invalid argument #2 (number expected)")
  flags = band(flags, flg_mask)
  rawset(self, _flg, bor(rawget(self, _flg) or 0, flags))
  return self
end

function MF:clear_flags (flags)
  assert(is_object(self) , "invalid argument #1 (object expected)")
  assert(is_number(flags), "invalid argument #2 (number expected)")
  flags = band(flags, flg_mask)
  rawset(self, _flg, band(rawget(self, _flg) or 0, bnot(flags)))
  return self
end

-- environments

local _env = {} -- hidden key

function MF:open_env (ctx_)
  assert(is_object(self), "invalid argument #1 (object expected)")
  assert(is_nil(ctx_) or is_function(ctx_) or is_number(ctx_) and ctx_ >= 1,
                          "invalid argument #2 (not a function or < 1)")
  ctx_ = is_function(ctx_) and ctx_ or is_number(ctx_) and ctx_+1 or 2
  assert(is_nil(rawget(self,_env)), "invalid environment (already open)")
  rawset(self, _env, { ctx=ctx_, env=getfenv(ctx_) })
  rawset(self, self.__id, self) -- self reference
  setfenv(ctx_, self)
  return self
end

function MF:is_open_env ()
  assert(is_object(self), "invalid argument #1 (object expected)")
  return not is_nil(rawget(self,_env))
end

function MF:reset_env () -- if an error occurs while in the environment
  assert(is_object(self), "invalid argument #1 (object expected)")
  rawset(self, _env, nil)
  rawset(self, self.__id, nil) -- clear self reference
  return self
end

function MF:close_env ()
  assert(is_object(self), "invalid argument #1 (object expected)")
  local env = rawget(self,_env)
  assert(not is_nil(env), "invalid environment (not open)")
  setfenv(env.ctx, env.env)
  return MF.reset_env(self)
end

function MF:dumpenv () -- for debug
  assert(is_object(self), "invalid argument #1 (object expected)")
  for k,v in pairs(rawget(self,_var)) do
    if is_rawtable(v) then
      for k,v in pairs(v) do
        print(k,'=',v)
      end
    elseif is_object(v) then
      print(k,'=',name(v))
    else
      print(k,'=',v)
    end
  end
end

-- I/O ------------------------------------------------------------------------o

-- dump obj members (including controlled inheritance)
function MF:dumpobj (filnam_, class_, pattern_)
  if is_object(filnam_) and is_nil(pattern_) then
    filnam_, class_, pattern_ = nil, filnam_, class_ -- right shift
  end
  if is_string(class_) and is_nil(pattern_) then
    class_, pattern_ = nil, class_                   -- right shift
  end

  class_, pattern_ = class_ or object, pattern_ or ''
  assert(is_object(self)    , "invalid argument #1 (object expected)")
  assert(is_object(class_)  , "invalid argument #3 (object expected)")
  assert(is_string(pattern_), "invalid argument #4 (string expected)")

  local tostring in MAD
  local n, cnt, res, spc, str = 0, {}, {}, ""
  while self and not rawequal(self, class_) do
    local var = rawget(self,_var)
    -- header
    local id = rawget(var, '__id')
    n, str = n+1, id and (" '" .. id .. "'") or ""
    res[n] = spc .. "+ " .. tostring(self)
    spc = spc .. "   "
    -- variables
    for k,v in kpairs(self) do
      if is_string(k) and string.sub(k,1,2) ~= '__' and string.find(k,pattern_) then
        str = spc .. tostring(k)
        if is_string(v) then
          str = str .. " : '" .. tostring(v):sub(1,15) .. "'"
        elseif is_function(v) then
          str = str .. " := " .. tostring(v(self))
        else
          str = str .. " :  " .. tostring(v)
        end
        if cnt[k]
        then str = str .. " (" .. string.rep('*', cnt[k]) .. ")" -- mark overrides
        else cnt[k] = 0
        end
        cnt[k], n = cnt[k]+1, n+1
        res[n] = str
      end
    end
    self = parent(self)
  end
  assert(rawequal(self, class_), "invalid argument #2 (parent of argument #1 expected)")

  -- return result as a string
  if filnam_ == '-' then return table.concat(res, '\n') end

  -- dump to file
  local file = openfile(filnam_, 'w', '.dat')
  for _,s in ipairs(res) do file:write(s,'\n') end
  if is_string(filnam_) then file:close() else file:flush() end

  return self
end

-- variables ------------------------------------------------------------------o

local MV = {}

MV.__id  = 'object'
MV.__par = parent
MV.first_free_flag = flg_free

-- aliases
MV.parent = parent
MV.name   = \s -> s.__id
MF.setv   = MF.set_variables
MF.getv   = MF.get_variables

-- env ------------------------------------------------------------------------o

MAD.typeid.is_class      = is_class
MAD.typeid.is_object     = is_object
MAD.typeid.is_instanceOf = is_instanceOf

-- metatables -----------------------------------------------------------------o

-- root object variables = module
object = setmetatable({[_var]=MV, [_mth]=MF}, MT)

 -- parent link
setmetatable(MV, object)

-- protect against changing metatable
MT.__metatable = MT

-- set as readonly
object:set_readonly()

-- end ------------------------------------------------------------------------o
return { object = object }
