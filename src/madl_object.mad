--[=[
 o-----------------------------------------------------------------------------o
 |
 | object module (object model)
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide an object model to support prototype-based programming with value
    semantic for functions stored in variables and further extensions.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local is_nil, is_boolean, is_number, is_string, is_table, is_rawtable,
      is_function, is_functor, is_metaname,is_callable, is_iterable,
      is_mappable                                               in MAD.typeid
local bset, btst, bclr, bnot, band, bor, lshift, eq             in MAD.operator
local bsearch, lsearch, kpairs, openfile, assertf, errorf       in MAD.utility
local functor                                                   in MAD.gfunc

local type, strsub = type, string.sub

-- implementation -------------------------------------------------------------o

-- Root of all objects, forward declaration
local object

-- object kind
local _id = {} -- unique identifier

-- reserved flags (bits)
local _flg = {} -- hidden key
local flg_ro, flg_cl = 0, 1 -- flags id for readonly and class
local flg_free = 2          -- used flags (0 - 1), free flags (2 - 31)

-- instance and metatable of 'incomplete objects' proxy
local var0 = setmetatable({}, {
  __index     := error("forbidden read access to incomplete object" , 2),
  __newindex  := error("forbidden write access to incomplete object", 2),
  __metatable  = false,
})

-- helpers --------------------------------------------------------------------o

local function name (a)
  local var = a.__var
  return rawget(var,'__id') or ('? <: ' .. var.__id)
end

local function init (a)
  local init = getmetatable(a).__init
  if init then return init(a) end
  return a
end

local function parent (a)
  return getmetatable(a.__index)
end

local function fclass (a)
  return btst(rawget(a,_flg) or 0, flg_cl)
end

local function freadonly (a)
  return btst(rawget(a,_flg) or 0, flg_ro)
end

local function set_class (a)
  rawset(a,_flg, bset(rawget(a,_flg) or 0, flg_cl))
  return a
end

local function is_object (a) -- exported
  local mt = getmetatable(a)
  return mt ~= nil and mt.__obj == _id
end

local function is_class (a) -- exported
  return is_object(a) and fclass(a)
end

local function is_instanceOf (a, b) -- exported
  if is_object(a) and is_class(b) then
    repeat a = parent(a) until not a or rawequal(a,b)
    return not not a
  end
  return false
end

local function copy_metamethods (a, m)
  local c = table.new(0,8)
  for k,v in pairs(m) do c[k] = v end
  m.__metatable = nil -- unprotect change
  setmetatable(a, c)
  m.__metatable, c.__metatable = m, c
  return c
end

-- metamethods ----------------------------------------------------------------o

local MT = {__obj=_id}

-- objects are proxies controlling variables access and inheritance
function MT:__call (a, b) -- object constructor (define the object-model)
  if is_string(a) or is_nil(a) then                     -- [un]named object
    if is_nil(b) then
      local obj = {__id=a, __var=var0, __index=self.__var} -- proxy
      return setmetatable(obj, getmetatable(self))      -- incomplete object
    elseif is_rawtable(b) then
      local obj = {__var=b, __index=self.__var}         -- proxy
      b.__id=a ; setmetatable(b, obj) ; set_class(self) -- set fast inheritance
      return init(setmetatable(obj, getmetatable(self)))-- complete object
    end
  elseif is_rawtable(a) then
    if self.__var == var0 then                          -- finalize named object
      a.__id, self.__id = self.__id, nil
      self.__var = setmetatable(a, self)                -- set fast inheritance
      set_class(parent(self))
      return init(self)
    else                                                -- unnamed object
      local obj = {__var=a, __index=self.__var}         -- proxy
      setmetatable(a, obj) ; set_class(self)            -- set fast inheritance
      return init(setmetatable(obj, getmetatable(self)))-- complete object
    end
  end
  error(is_nil(b) and "invalid argument #1 (string or raw table expected)"
                  or  "invalid argument #2 (raw table expected)", 2)
end

function MT:__index (k)        -- reusing var_raw and var_val kills the inlining
  local v = self.__var[k]
  if type(k) == 'string' and type(v) == 'function'
  then return v(self)
  else return v end
end

function MT:__newindex (k, v)
  if freadonly(self) or type(k) == 'string' and strsub(k,1,2) == '__' then
    error("forbidden write access to '" .. name(self) .. "." .. tostring(k)
          .. "' (readonly object, method or variable)", 2)
  end
  self.__var[k] = v      -- note: must use [k] for var0
end

function MT:__len ()
  local var = self.__var
  if is_nil(var[1]) then return 0 end -- fast
  while is_nil(rawget(var,1)) do      -- slow
    var  = self.__index
    self = getmetatable(var)
  end
  return rawlen(var)
end

local function iter (var, key) -- scan only numbers and strings
  local k, v = next(var, key)
  while type(k) ~= 'string' and type(k) ~= 'number' and k do
    k, v = next(var, k)
  end
  return k, v
end

local function pairs_iter (self)
  return iter, self.__var, nil
end

local function ipairs_iter (self)
  return ipairs(self.__var)
end

MT.__pairs  =  pairs_iter
MT.__ipairs = ipairs_iter

function MT:__tostring()
  return string.format("object: '%s' %p", name(self), self)
end

-- methods (member functions) -------------------------------------------------o

local MF = {}

MF.is_class      = is_class
MF.is_instanceOf = is_instanceOf

function MF:raw_len ()
  return rawlen(self.__var)           -- no inheritance
end

function MF:raw_get (k)
  return rawget(self.__var,k)         -- no inheritance nor function evaluation
end

function MF:raw_set (k, v)
  rawset(self.__var, k, v)            -- no protection!!
end

function MF:var_raw (k)
  return self.__var[k]                -- no function evaluation with inheritance
end

function MF:var_val (k, v)            -- string key with value function
  if type(k) == 'string' and type(v) == 'function'
  then return v(self)
  else return v end
end

function MF:var_get (k)             -- named __index, can return multiple values
  local v = self.__var[k]
  if type(k) == 'string' and type(v) == 'function'
  then return v(self)
  else return v end
end

function MF:is_readonly ()
  assert(is_object(self), "invalid argument #1 (object expected)")
  return freadonly(self)
end

function MF:set_readonly (set_)
  assert(is_object(self), "invalid argument #1 (object expected)")
  if set_ ~= false
  then rawset(self, _flg, bset(rawget(self,_flg) or 0, flg_ro))
  else rawset(self, _flg, bclr(rawget(self,_flg) or 0, flg_ro))
  end
  return self
end

function MF:get_variables (lst, noeval_)
  assert(is_object(self) , "invalid argument #1 (object expected)")
  assert(is_iterable(lst), "invalid argument #2 (iterable expected)")
  local n   = #lst
  local res = table.new(0,n)
  local get = noeval_ == true and MF.var_raw or MF.var_get
  for i=1,n do res[lst[i]] = get(self, lst[i]) end
  return res -- key -> val
end

function MF:set_variables (tbl, override_) -- default: override = true
  assert(is_object(self) , "invalid argument #1 (object expected)")
  assert(is_mappable(tbl), "invalid argument #2 (mappable expected)")
  if freadonly(self) then
    errorf("forbidden write access to readonly object '%s'", name(self))
  end
  local var = self.__var
  local id  = rawget(var,'__id')
  for k,v in pairs(tbl) do
    assertf(override_ ~= false or is_nil(var[k]), "cannot override variable '%s'",k)
    var[k] = v
  end
  var.__id = id
  return self
end

function MF:wrap_variables (tbl)
  assert(is_object(self)    , "invalid argument #1 (object expected)")
  assert(is_mappable(tbl)   , "invalid argument #2 (mappable expected)")
  if freadonly(self) then
    errorf("forbidden write access to readonly object '%s'", name(self))
  end
  local var = self.__var
  local id  = rawget(var,'__id')
  for k,f in pairs(tbl) do
    local v, newv = var[k]
    assert(not is_nil(v) , "invalid variable (nil value)")
    assert(is_callable(f), "invalid wrapper (callable expected)")
    if is_callable(v) then newv = f(v) else newv = f(\ v) end -- simplify user's side.
    if is_functor(v) and not is_functor(newv) then
      newv = functor(newv)                   -- newv must maintain v's semantic.
    end
    var[k] = newv
  end
  var.__id = id
  return self
end

function MF:set_methods (tbl, override_) -- default: override = true
  assert(is_object(self) , "invalid argument #1 (object expected)")
  assert(is_mappable(tbl), "invalid argument #2 (mappable expected)")
  if freadonly(self) then
    errorf("forbidden write access to readonly object '%s'", name(self))
  end
  if fclass(self) and override_ == false then
    errorf("cannot set methods to '%s' (unexpected class)", name(self))
  end
  local var = self.__var
  local id  = rawget(var,'__id')
  for k,f in pairs(tbl) do
    assertf(is_string(k)  , "invalid key '%s' (string expected)", k)
    assertf(is_callable(f), "invalid value for key '%s' (callable expected)", k)
    assertf(override_ ~= false or is_nil(var[k]), "cannot override method '%s'",k)
    var[k] = is_function(f) and functor(f) or f
  end
  var.__id = id
  return self
end

function MF:set_metamethods (tbl, override_) -- default: override = false
  assert(is_object(self) , "invalid argument #1 (object expected)")
  assert(is_mappable(tbl), "invalid argument #2 (mappable expected)")
  if freadonly(self) then
    errorf("forbidden write access to readonly object '%s'", name(self))
  end
  if fclass(self) then
    errorf("cannot set metamethods to '%s' (unexpected class)", name(self))
  end
  local sm, pm = getmetatable(self), getmetatable(parent(self)) or MT
  if sm == pm then sm = copy_metamethods(self, pm) end
  for k,m in pairs(tbl) do
    assertf(is_string(k) and strsub(k,1,2) == '__',
            "invalid key '%s' (string starting with __ expected)", tostring(k))
    assertf(override_ == true or is_nil(sm[k]), "cannot override metamethod '%s'",k)
    sm[k] = m
  end
  return self
end

local function final_err (self)
  error("invalid object creation ('"..name(self).."' is qualified as final)", 2)
end

function MF:set_final ()
  return set_metamethods(self, {__call=final_err}, true)
end

function MF:get_varkeys (class_)
  assert(is_object(self)                    , "invalid argument #1 (object expected)")
  assert(is_nil(class_) or is_object(class_), "invalid argument #2 (object expected)")
  local lst, key = table.new(8,1), table.new(0,8)
  while self and not rawequal(self, class_) do
    for k,v in kpairs(self) do
      if not (key[k] or is_functor(v)) and is_string(k) and strsub(k,1,2) ~= '__'
      then lst[#lst+1], key[k] = k, k
      end
    end
    self = parent(self)
  end
  assert(rawequal(self, class_),"invalid argument #2 (parent of argument #1 expected)")
  return lst
end

function MF:insert (idx_, val)
  assert(is_object(self)    , "invalid argument #1 (object expected)")
  if freadonly(self) then
    errorf("forbidden write access to readonly object '%s'", name(self))
  end
  table.insert(self.__var, idx_, val)
  return self
end

function MF:remove (idx_)
  assert(is_object(self)    , "invalid argument #1 (object expected)")
  if freadonly(self) then
    errorf("forbidden write access to readonly object '%s'", name(self))
  end
  return table.remove(self.__var, idx_)
end

function MF:move (idx1, idx2, idxto, dest_)
  dest_ = dest_ or self
  assert(is_object(self)     , "invalid argument #1 (object expected)")
  assert(is_object(dest_)    , "invalid argument #2 (object expected)")
  if not freadonly(dest_) then
    errorf("forbidden write access to readonly object '%s'", name(dest_))
  end
  table.move(self.__var, idx1, idx2, idxto, dest_.__var)
  return dest_
end

function MF:sort (cmp_)
  assert(is_object(self)    , "invalid argument #1 (object expected)")
  if freadonly(self) then
    errorf("forbidden write access to readonly object '%s'", name(self))
  end
  table.sort(self.__var, cmp_)
  return self
end

function MF:bsearch (val, cmp_, low_, high_)
  assert(is_object(self), "invalid argument #1 (object expected)")
  return bsearch(self.__var, val, cmp_, low_, high_)
end

function MF:lsearch (val, equ_, low_, high_)
  assert(is_object(self), "invalid argument #1 (object expected)")
  return lsearch(self.__var, val, equ_, low_, high_)
end

function MF:clear_array ()
  assert(is_object(self)    , "invalid argument #1 (object expected)")
  if freadonly(self) then
    errorf("forbidden write access to readonly object '%s'", name(self))
  end
  local var = self.__var
  for i=1,rawlen(var) do var[i]=nil end
  return self
end

function MF:clear_variables ()
  assert(is_object(self)    , "invalid argument #1 (object expected)")
  if freadonly(self) then
    errorf("forbidden write access to readonly object '%s'", name(self))
  end
  local var = self.__var
  local id  = rawget(var,'__id')
  for k in kpairs(self) do var[k]=nil end
  var.__id = id
  return self
end

function MF:clear_all ()
  assert(is_object(self)    , "invalid argument #1 (object expected)")
  if freadonly(self) then
    errorf("forbidden write access to readonly object '%s'", name(self))
  end
  local var = self.__var
  local id  = rawget(var,'__id')
  for k in pairs_iter(self) do var[k]=nil end -- table.clear destroys all keys
  var.__id = id
  return self
end

-- inheritance

function MF:set_parent (newp)
  assert(is_object(self), "invalid argument #1 (object expected)")
  assert(is_object(newp), "invalid argument #2 (object expected)")
  if freadonly(self) then
    error("forbidden write access to readonly object '" .. name(self) .. "'", 2)
  end
  local spar = self.parent
  if getmetatable(newp) ~= getmetatable(spar) then
    error("new and current parent do not share same metamethods")
  end
  if newp.parent ~= spar.parent then
    error("new and current parent do not inherit from same direct parent")
  end
  self.__index = newp.__var
  set_class(newp)
  return self
end

-- copy

function MF:same (name_)
  assert(is_object(self)                  ,"invalid argument #1 (object expected)")
  assert(is_nil(name_) or is_string(name_),"invalid argument #2 (string expected)")
  -- same shares the same parent
  local par = parent(self)
  local sam = par(name_, {})
  -- metatable
  local sm, pm = getmetatable(self), getmetatable(par)
  if sm ~= pm then copy_metamethods(sam, sm) end
  return sam
end

function MF:copy (name_)
  assert(is_object(self)                  ,"invalid argument #1 (object expected)")
  assert(is_nil(name_) or is_string(name_),"invalid argument #2 (string expected)")
  local cpy = MF.same(self, name_ or MF.raw_get(self,'__id'))
  local var, cvar = self.__var, cpy.__var
  local id  = rawget(cvar,'__id')
  for k,v in pairs_iter(self) do cvar[k] = v end
  cvar.__id = id
  return cpy
end

MT.__same = MF.same
MT.__copy = MF.copy

-- flags

local flg_mask = lshift(-1, flg_free)
local flg_notmask = bnot(flg_mask)

function MF:test_flag (n)
  assert(is_object(self), "invalid argument #1 (object expected)")
  assert(is_number(n)   , "invalid argument #2 (number expected)")
  return btst(rawget(self,_flg) or 0, n)
end

function MF:set_flag (n)
  assert(is_object(self), "invalid argument #1 (object expected)")
  assert(is_number(n)   , "invalid argument #2 (number expected)")
  if n >= flg_free then
    rawset(self, _flg, bset(rawget(self,_flg) or 0, n))
  end
  return self
end

function MF:clear_flag (n)
  assert(is_object(self), "invalid argument #1 (object expected)")
  assert(is_number(n)   , "invalid argument #2 (number expected)")
  if n >= flg_free then
    rawset(self, _flg, bclr(rawget(self,_flg) or 0, n))
  end
  return self
end

function MF:get_flags ()
  assert(is_object(self), "invalid argument #1 (object expected)")
  return rawget(self,_flg) or 0
end

function MF:test_flags (flags)
  assert(is_object(self) , "invalid argument #1 (object expected)")
  assert(is_number(flags), "invalid argument #2 (number expected)")
  return band(rawget(self,_flg) or 0, flags) ~= 0
end

function MF:set_flags (flags)
  assert(is_object(self) , "invalid argument #1 (object expected)")
  assert(is_number(flags), "invalid argument #2 (number expected)")
  flags = band(flags, flg_mask)
  rawset(self, _flg, bor(rawget(self, _flg) or 0, flags))
  return self
end

function MF:clear_flags (flags)
  assert(is_object(self) , "invalid argument #1 (object expected)")
  assert(is_number(flags), "invalid argument #2 (number expected)")
  flags = band(flags, flg_mask)
  rawset(self, _flg, band(rawget(self, _flg) or 0, bnot(flags)))
  return self
end

-- environments

local _env = {} -- hidden key

function MF:open_env (ctx_)
  assert(is_object(self), "invalid argument #1 (object expected)")
  assert(is_nil(ctx_) or is_function(ctx_) or is_number(ctx_) and ctx_ >= 1,
                          "invalid argument #2 (not a function or < 1)")
  ctx_ = is_function(ctx_) and ctx_ or is_number(ctx_) and ctx_+1 or 2
  assert(is_nil(rawget(self,_env)), "invalid environment (already open)")
  rawset(self, _env, { ctx=ctx_, env=getfenv(ctx_) })
  rawset(self, self.__id, self) -- self reference
  setfenv(ctx_, self)
  return self
end

function MF:is_open_env ()
  assert(is_object(self), "invalid argument #1 (object expected)")
  return not is_nil(rawget(self,_env))
end

function MF:reset_env () -- if an error occurs while in the environment
  assert(is_object(self), "invalid argument #1 (object expected)")
  local env = rawget(self,_env)
  if env then
    setfenv(env.ctx, env.env)
    rawset(self, _env, nil)
    rawset(self, self.__id, nil) -- clear self reference
  end
  return self
end

function MF:close_env ()
  assert(is_object(self), "invalid argument #1 (object expected)")
  assert(not is_nil(rawget(self,_env)), "invalid environment (not open)")
  return MF.reset_env(self)
end

function MF:load_env (loader)
  assert(is_object(self), "invalid argument #1 (object expected)")
  if is_string(loader) then loader = assert(loadfile(loader)) end
  assert(is_callable(loader), "invalid argument #2 (filename or callable expected)")
  self:open_env(loader)
  local st, err = pcall(loader)
  self:reset_env()
  assert(st, err)
  return self
end

function MF:dumpenv () -- for debug
  assert(is_object(self), "invalid argument #1 (object expected)")
  for k,v in pairs(self.__var) do
    if is_rawtable(v) then
      for k,v in pairs(v) do
        print(k,'=',v)
      end
    elseif is_object(v) then
      print(k,'=',name(v))
    else
      print(k,'=',v)
    end
  end
end

-- I/O ------------------------------------------------------------------------o

-- dump obj members (including controlled inheritance)
function MF:dumpobj (filnam_, class_, pattern_)
  if is_object(filnam_) and is_nil(pattern_) then
    filnam_, class_, pattern_ = nil, filnam_, class_ -- right shift
  end
  if is_string(class_) and is_nil(pattern_) then
    class_, pattern_ = nil, class_                   -- right shift
  end

  class_, pattern_ = class_ or object, pattern_ or ''
  assert(is_object(self)    , "invalid argument #1 (object expected)")
  assert(is_object(class_)  , "invalid argument #3 (object expected)")
  assert(is_string(pattern_), "invalid argument #4 (string expected)")

  local tostring in MAD
  local n, cnt, res, spc, str = 0, {}, {}, ""
  while self and not rawequal(self, class_) do
    local var = self.__var
    -- header
    local id = rawget(var, '__id')
    n, str = n+1, id and (" '" .. id .. "'") or ""
    res[n] = spc .. "+ " .. tostring(self)
    spc = spc .. "   "
    -- variables
    for k,v in kpairs(self) do
      if is_string(k) and strsub(k,1,2) ~= '__' and string.find(k,pattern_) then
        str = spc .. tostring(k)
        if is_string(v) then
          str = str .. " : '" .. tostring(v):sub(1,15) .. "'"
        elseif is_function(v) then
          str = str .. " := " .. tostring(v(self))
        else
          str = str .. " :  " .. tostring(v)
        end
        if cnt[k]
        then str = str .. " (" .. string.rep('*', cnt[k]) .. ")" -- mark overrides
        else cnt[k] = 0
        end
        cnt[k], n = cnt[k]+1, n+1
        res[n] = str
      end
    end
    self = parent(self)
  end
  assert(rawequal(self, class_), "invalid argument #2 (parent of argument #1 expected)")

  -- return result as a string
  if filnam_ == '-' then return table.concat(res, '\n') end

  -- dump to file
  local file = openfile(filnam_, 'w', '.dat')
  for _,s in ipairs(res) do file:write(s,'\n') end
  if is_string(filnam_) then file:close() else file:flush() end

  return self
end

-- variables ------------------------------------------------------------------o

local MV = {}

MV.__id  = 'object'
MV.__par = parent
MV.first_free_flag = flg_free

-- aliases
MV.parent = parent
MV.name   = \s -> s.__id
MF.setv   = MF.set_variables
MF.getv   = MF.get_variables

-- env ------------------------------------------------------------------------o

MAD.typeid.is_class      = is_class
MAD.typeid.is_object     = is_object
MAD.typeid.is_instanceOf = is_instanceOf

-- object ---------------------------------------------------------------------o

-- add variables, methods and metamethods, and set as readonly
object = MF.set_methods(setmetatable({__var=MV, __index={}}, MT), MF) :set_readonly()

 -- parent link
setmetatable(MV, object)

-- protect against changing metatable
MT.__metatable = MT

-- end ------------------------------------------------------------------------o
return { object = object }
