--[=[
 o-----------------------------------------------------------------------------o
 |
 | Survey module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - TODO

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local vector, matrix, element, mtable, command                    in MAD
local is_sequence, is_boolean, is_number, is_integer, is_table,
      is_implicit, is_callable, is_mappable                       in MAD.typeid
local fnone                                                       in MAD.gfunc
local errorf                                                      in MAD.utility

-- integrator schemes ---------------------------------------------------------o

local thinonly, driftonly, thickonly                              in MAD.symint

-- geometric maps -------------------------------------------------------------o

local thin, drift, thick, xrotation, yrotation, srotation,
      translate, changeref, changedir, changenrj                  in MAD.geomap

-- load maps into elements ----------------------------------------------------o

local invalid = \e ->
  errorf("invalid element %s of kind %s with length %s", e.name, e.kind, e.l)

local E = element

-- kind maps

E. thin_element :set_functors { survey = \e,m ->  thinonly(e,m,1, nil  , thin) }
E.drift_element :set_functors { survey = \e,m -> driftonly(e,m,1, drift, nil ) }
E.thick_element :set_functors { survey = \e,m -> thickonly(e,m,1, thick, nil ) }
E.extra_element :set_functors { survey = invalid }

-- special maps

E.patch     :set_functors { survey = invalid   }
E.special   :set_functors { survey = fnone     }
E.xrotation :set_functors { survey = xrotation }
E.yrotation :set_functors { survey = yrotation }
E.srotation :set_functors { survey = srotation }
E.translate :set_functors { survey = translate }
E.changeref :set_functors { survey = changeref }
E.changedir :set_functors { survey = changedir }
E.changenrj :set_functors { survey = changenrj }

-- survey mtable --------------------------------------------------------------o

local function save_all (elm, mflw, lw_)
  local name, kind, l, angle, tilt in elm

  local V, A, sdir, tdir, spos, mtbl, atfill in mflw
  local x, y, z      = V[1], V[2], V[3]
  local th, phi, psi = A[1], A[2], A[3]
  local lw = lw_ or 1

  -- keep order!
  mtbl = mtbl + { name, kind, spos, l*lw*sdir, angle*lw*tdir, tilt*tdir,
                  x, y, z, th, phi, psi, psi+tilt*tdir, tdir }
  atfill(elm, mflw, lw)
end

local function save_imp (elm, mflw, lw_)
  if is_implicit(elm) then return end
  save_all(elm, mflw, lw_)
end

local function save_obs (elm, mflw, lw_)
  if not is_observed(elm) then return end
  save_all(elm, mflw, lw_)
end

local function make_mtable (self)
  local range, nturn, sdir, implicit, title in self
  local sequ = self.sequence
  local nrow = sequ:length_of(range, nturn)*(implicit and 2 or 1)

  -- keep order!
  return mtable 'survey' {
    type='survey', title=title or sequ.name, sdir=sdir, reserve=nrow,
    {'name'}, 'kind', 's', 'l', 'angle', 'tilt',
    'x', 'y', 'z', 'theta', 'phi', 'psi', 'globaltilt',
    'tdir', -- t-direction of the tracking: sdir * seqdir
  }
end

-- survey mflow ---------------------------------------------------------------o

local _id = {} -- identity

local function make_mflow (self)
  if self.mflow then
    assert(self.mflow.__surv == _id, "invalid mflow (survey mflow expected)")
    return self.mflow
  end

  -- check sequence
  local sequ = assert(self.sequence, "missing sequence")
  assert(is_sequence(sequ), "invalid sequence")

  -- build iterator
  local range, sdir, nturn in self
  local iter, state, init = sequ:siter(range, nturn, sdir)

  -- build mtable
  local save, nofill, observe, implicit in self
  assert(is_boolean(save) or is_callable(save),
                               "invalid save (boolean or callable expected)")
  assert(is_boolean(nofill)  , "invalid nofill (boolean expected)")
  assert(is_boolean(observe) , "invalid observe (boolean expected)")
  assert(is_boolean(implicit), "invalid implicit (boolean expected)")

  -- saving data
  local mtbl, fill
  if save then
    mtbl = make_mtable(self)
    fill = is_callable(save) and save     or -- precedence matters!
           observe  == true  and save_obs or
           implicit == false and save_imp or save_all
  else
    fill = fnone
  end

  -- time direction
  local tdir = sdir*sequ.dir
  assert(tdir == 1 or tdir == -1, "invalid time direction (1 or -1 expected)")

  -- setup default sclicing
  local nslice in self
  assert(is_integer(nslice) and nslice > 0, "invalid nslice (positive integer expected)")

  -- retrieve default actions (avoid evaluation in case of functions)
  local atentry = self:var_raw('atentry') or fnone
  local atslice = self:var_raw('atslice') or fnone
  local atexit  = self:var_raw('atexit' ) or fnone
  local atfill  = self:var_raw('atexit' ) or fnone
  assert(is_callable(atentry), "invalid atentry (callable expected)")
  assert(is_callable(atslice), "invalid atslice (callable expected)")
  assert(is_callable(atexit ), "invalid atexit (callable expected)")
  assert(is_callable(atfill ), "invalid atfill (callable expected)")

  -- retrieve initial conditions
  local s0, X0, A0 in self
  assert(is_number  (s0), "invalid s0 (number expected)")
  assert(is_mappable(X0), "invalid X0 (mappable expected)")
  assert(is_mappable(A0), "invalid A0 (mappable expected)")

  -- precedence of initial conditions
  local x     = X0[1] or X0.x     or 0
  local y     = X0[2] or X0.y     or 0
  local z     = X0[3] or X0.z     or 0
  local theta = A0[1] or A0.theta or 0
  local phi   = A0[2] or A0.phi   or 0
  local psi   = A0[3] or A0.psi   or 0

  -- build mflow
  local mflw = {
    sequ=sequ,                         -- current sequence
    mtbl=mtbl,                         -- current mtable (nil if no save)
    sdir=sdir,                         -- s-direction of tracking
    tdir=tdir,                         -- t-direction of tracking

    fill=fill,                         -- fill/add one row to mtable (if any)
    nofill=nofill,                     -- disable filling at the end of an element
    nslice=nslice,                     -- number of slice for each element

    s0=s0,                             -- initial s-position
    idx=init,                          -- index of the current element
    spos=s0,                           -- s-position of the current element entry
    npos=nil,                          -- integrator step: nil, 'first', 'last'

    atentry=atentry,                   -- action when entering an element
    atslice=atslice,                   -- action after each element slices
    atexit =atexit,                    -- action when exiting an element
    atfill =atfill,                    -- action when filling a mtable row

    -- global frame (see geomap)
    V=vector(3):fill{x,y,z},           -- displacement vector
    W=matrix(3):rotmad(theta,phi,psi), -- orientation matrix (rotations)
    A=vector(3):fill{theta,phi,psi},   -- oriented angles

    -- local frame (see geomap) at element slices or exit
    R=vector(3),                       -- displacement vector
    S=matrix(3),                       -- orientation matrix (rotations)
    T=matrix(3),                       -- transformation matrix if tilted
    U=vector(3),                       -- temporary vector for calculations

    -- internal vars for survey
    __survitr={iter=iter, state=state},   -- iterator and iteraror state
    __surv=_id,
  }

  return mflw
end

-- survey command -------------------------------------------------------------o

local function exec (self)
  -- build mflow
  local mflw = make_mflow(self)

  -- check number of element to track
  local nstep in self
  if nstep == 0 then return mflw.mtbl, mflw end

  -- retrieve information
  local s0, sdir, idx, mtbl, fill, nofill, atentry, atexit in mflw
  local iter, state in mflw.__survitr

  -- disable fill locally
  if nofill ~= false then fill = fnone end

  -- geometric tracking
  for i,elm,spos in iter, state, idx do
    mflw.idx, mflw.spos = i, s0+spos
    atentry(elm, mflw)
    elm:survey  (mflw)
    mflw.spos = s0+spos + elm.l*sdir
    atexit (elm, mflw)
    fill   (elm, mflw)

    -- check remaining number of element to track
    nstep = nstep-1
    if nstep == 0 then return mtbl, mflw, elm end
  end

  return mtbl, mflw
end

local _na -- not applicable (see track or twiss)

local survey = command 'survey' {
  beam=_na,         -- N/A                                                (mflw)
  sequence=nil,     -- sequence (required)                                (mflw)
  range=nil,        -- range of tracking                                  (iter)
  title=nil,        -- title of mtable                                    (mtbl)
  sdir=1,           -- s-direction of tracking (1 or -1)                  (mflw)

  s0=0,             -- initial s                                          (mflw)
  X0={0,0,0},       -- initial coordinates x, y, z                        (mflw)
  A0={0,0,0},       -- initial angles theta, phi, psi                     (mflw)

  mapdef=_na,       -- N/A                                                (mflw)
  mapsave=false,    -- save W in the mtable                               (mflw)

  nturn=1,          -- number of turns                                    (iter)
  nstep=-1,         -- number of elements to track                        (iter)
  nslice=1,         -- number of slice for each element                   (mflw)
  method=_na,       -- N/A                                                (mflw)
  totalpath=_na,    -- N/A                                                (mflw)

  save=true,        -- create mtable and set fill to save data            (mtbl)
  nofill=false,     -- disable filling at the end of an element           (mflw)
  observe=false,    -- save only observed elements                        (mtbl)
  implicit=true,    -- save also implicit elements                        (mtbl)

  atentry=nil,      -- action to call when entering an element            (mflw)
  atslice=nil,      -- action to call after each element slices           (mflw)
  atexit=nil,       -- action to call when exiting an element             (mflw)
  atfill=nil,       -- action to call when filling a mtable row           (mflw)

  mflow=nil,      -- current mflow, exclusive with other attributes except nstep

  exec=exec,        -- command to execute upon children creation
} :set_readonly()   -- reference survey command is readonly

-- end ------------------------------------------------------------------------o
return { survey = survey }
