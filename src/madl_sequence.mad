--[=[
 o-----------------------------------------------------------------------------o
 |
 | Sequence module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide sequence object to define lattices

 o-----------------------------------------------------------------------------o
]=]

local M = {}

-- locals ---------------------------------------------------------------------o

local warn                                                       in MAD
local second, bind1st, bind2nd, bind2st                          in MAD.gfunc
local lt, sub, ltrue, lfalse                                     in MAD.operator
local sequence, marker, drift, changedir, flags                  in MAD.element
local minlen                                                     in MAD.constant
local strtrim, strsplit, strbracket, bsearch, errorf, openfile   in MAD.utility
local is_nil, is_boolean, is_number, is_integer, is_decimal,
      is_string, is_table, is_rawtable, is_iterable, is_callable,
      is_range, is_element, is_object, is_instanceOf,
      set_concept, concept                                       in MAD.typeid
local not_mappable, not_extendable, not_mutable                  in concept
local implicit                                                   in flags

local abs in math

local type = type

-- backup original methods and metamethods
local sequence_mt = getmetatable(sequence)
local var_raw, var_val, mth_get, raw_get, test_flag in sequence
local seq_cpy, var_set = sequence.copy, sequence_mt.__newindex
local readonly = sequence.set_readonly

-- root object ----------------------------------------------------------------o

local _data = {} -- hidden key

-- special numerical value for elements positions.
local uninitialized = -1e9
local ongoing_init  = -2e9

-- defined in elements
sequence :setv { dir=1, l=uninitialized,
                 [_data]={eidx={}, spos={}, epos={}, ne=0} }

local function is_sequence (a)
  return is_table(a) and a[_data] ~= nil
end

local function is_owner (a)
  return raw_get(a, _data) ~= nil
end

local function is_view (a)
  return raw_get(a, _data) == nil
end

-- definitions ----------------------------------------------------------------o

-- start and end markers
local mkstart = marker '$start' {} : set_readonly()
local mkend   = marker '$end'   {} : set_readonly()

-- sanity checks --------------------------------------------------------------o

local function seq_error (msg, seq, idx, elm)
  local fun = seq.debug and warn or error
  elm = elm or is_integer(idx) and is_sequence(seq) and seq[idx]
  fun(msg .. (is_object(seq) and " in sequence '" .. seq.__id .. "'" or '')
          .. (is_object(elm) and " for element '" .. elm.__id .. "'" or '')
          .. (          idx  and " at index "     .. idx             or ''), 2)
end

local function seq_poserr (typ, seq, idx, pos)
  local msg = string.format(
    "invalid %s position at s = %.6gm (negative drift %.6gm)",
             typ,               seq:spos(idx),        seq:spos(idx)-pos)
  seq_error(msg, seq, idx, seq[idx])
end

local function seq_lenerr (typ, seq, idx, len)
  local msg = string.format(
    "invalid %s length at s = %.6gm (invalid length %.6gm)",
             typ,             seq:spos(idx),        len)
  seq_error(msg, seq, idx, seq[idx])
end

-- check sequence spos and elements overlapp
local function check_drift (seq, idx)
  local data, ds = var_raw(seq,_data)
  assert(idx > 1 and idx < data.ne, "unexpected corrupted element index")

  ds = data.spos[idx  ] - (data.spos[idx-1]+data[idx-1].l)
  if ds < -minlen then seq_poserr("element", seq, idx, data.spos[idx]-ds) end

  ds = data.spos[idx+1] - (data.spos[idx  ]+data[idx  ].l)
  if ds < -minlen then seq_poserr("element", seq, idx, data.spos[idx]-ds) end
end

-- check shared element

local function check_shared (seq, idx)
  local elm = var_raw(seq,_data)[idx]
  if is_nil(raw_get(elm, 'l') or raw_get(elm, 'refpos')) then
    return elm.parent
  end
  seq_error("invalid shared element (l or refpos defined)", seq, idx, elm)
end

-- check sequence $start and $stop integrity
local function check_mark (seq)
  local data = var_raw(seq,_data)
  local n = data.ne
      if not data[1]:is_instanceOf(mkstart) then
    error("invalid sequence first element ($start marker expected)", 2)
  elseif not data[n]:is_instanceOf(mkend  ) then
    error("invalid sequence last element ($end marker expected)"   , 2)
  end
end

-- check sequence spos and elements overlapp
local function check_spos (seq)
  local data = var_raw(seq,_data)
  for i=1,data.ne-1 do
    local ds = data.spos[i+1] - (data.spos[i]+data[i].l)
    if ds < -minlen then
      seq_poserr("element", seq, i, data.spos[i]-ds)
    elseif data[i].is_thin and data[i].l ~= 0 then
      seq_lenerr("element", seq, i, data[i].l)
    end
  end
end

-- check dictionnary of name -> idx
local function check_index (seq)
  local data = var_raw(seq,_data)
  local eidx = data.eidx
  local s, e, S, E = eidx['#s'], eidx['#e'], eidx['#S'], eidx['#E']
  assert(is_number(s) and is_number(e) and is_number(S) and is_number(E),
         "unexpected reuse of #s/#e or #S/#E start/stop markers names")

  eidx['#s'], eidx['#e'], eidx['#S'], eidx['#E'] = nil

  -- check dict vs data: name -> index or table of indexes
  for en,ei in pairs(eidx) do
    if is_number(ei) then
      assert(data[ei].__id == en     , "unexpected corrupted dictionnary")
    elseif is_table(ei) then
      assert(data[ei[1]].__id == en  , "unexpected corrupted dictionnary")
      assert(ei.n             >= 2   , "unexpected corrupted dictionnary")
      for i=2,ei.n do
        assert(ei[i-1] < ei[i]       , "unexpected corrupted dictionnary")
        assert(data[ei[i]].__id == en, "unexpected corrupted dictionnary")
      end
    else
      error("unexpected corrupted dictionnary")
    end
  end

  -- check data vs dict: name -> index or table of indexes
  for i=1,data.ne do
    local ei = eidx[data[i].__id]
    if is_number(ei) then
      assert(ei == i                 , "unexpected corrupted dictionnary")
    elseif is_table(ei) then
      local ii
      for j=1,ei.n do
        if ei[j] >= i then ii = ei[j] ; break end
      end
      assert(ii == i                 , "unexpected corrupted dictionnary")
    else
      error("unexpected corrupted dictionnary")
    end
  end

  eidx['#s'], eidx['#e'], eidx['#S'], eidx['#E'] = s, e, S, E
end

local function check_sequ (seq)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  assert(seq.dir == 1 or seq.dir == -1, "invalid direction (1 or -1 expected)")
  check_spos (seq)
  check_index(seq)
  check_mark (seq)
  return seq
end

-- helper for mangled names and elements indexes (same as mtable) -------------o

-- reflect indexes
local function reflect (i, n)
  return i < 0 and n+i+1 or i
end

-- canonize index (direct)
local function index_of_idx (seq, idx)
  local n = var_raw(seq,_data).ne
  idx = reflect(idx, n)
  return idx >= 1 and idx <= n and idx or nil
end

-- get index from s-position (binary)
local function index_of_num (seq, num, dir)
  local l = seq.l
  if num < 0 then num = l+num end -- reflect
  if num < 0 or num > l then return nil end
  local data = var_raw(seq,_data)
  local idx = bsearch(data.spos, num)
  dir = dir or 0
  assert(dir == 0 or dir == 1 or dir == -1, "invalid direction (0, 1 or -1 expected)")
  if idx > 1 and num < data.spos[idx]-minlen then
    if dir < 0 or num < data.spos[idx-1]+data[idx-1].l+minlen then
      idx = idx-1
    elseif dir == 0 and num > data.spos[idx-1]+data[idx-1].l+minlen then
      idx = nil
    end
  end
  return idx, num
end

-- get index from name [with absolute count] (direct)
local function index_of_cnam (seq, nam, cnt)
  local ei = var_raw(seq,_data).eidx[nam]
  if is_table(ei) then
    return ei[ reflect(cnt, ei.n) ]
  elseif cnt == 1 or cnt == -1 then
    return ei
  end
  return nil
end

-- get index from name [with relative count] (linear)
local function index_of_rnam (seq, nam, cnt, ref)
  local ei = var_raw(seq,_data).eidx[nam]
  if is_nil(ei) then return nil end
  assert(is_integer(ref), "invalid reference index (integer expected)")
  local idx = assert(index_of_idx(seq, ref), "invalid reference index")
  if is_number(ei) then
    return (cnt ==  1 and ei >= idx and ei) or
           (cnt == -1 and ei <= idx and ei) or nil
  end
  if cnt > 0 then
    for i=1,ei.n do
      if ei[i] >= idx then return ei[i+cnt-1] end
    end
  elseif cnt < 0 then
    for i=ei.n,1,-1 do
      if ei[i] <= idx then return ei[i+cnt+1] end
    end
  end
end

-- get index from [mangled] name or s-position (direct or linear)
local function index_of_str (seq, str, ref_, dir_)
  local num = tonumber(str)
  if num then return index_of_num(seq, num, dir_) end
  local nam, cnt, _, bra = strbracket(str)
  cnt = is_nil(cnt) and 1 or tonumber(cnt)
  assert(is_integer(cnt) and cnt ~= 0, "invalid argument #2 (non-zero count expected)")
  if is_nil(ref_) or bra == 1 then
    return index_of_cnam(seq, nam, cnt      )
  else
    return index_of_rnam(seq, nam, cnt, ref_)
  end
end

-- get index from 'from' [mangled] name (direct or linear)
local function index_of_fnam (seq, nam, ref_)
  assert(is_string(nam), "invalid argument #2 (string expected)")
  local nam, cnt, _, bra = strbracket(nam)
  cnt = is_nil(cnt) and 1 or tonumber(cnt)
  assert(is_integer(cnt) and cnt ~= 0, "invalid argument #2 (non-zero count expected)")
  if is_nil(ref_) or bra ~= 2 then -- need both for relative from
    return index_of_cnam(seq, nam, cnt      ), bra
  else
    return index_of_rnam(seq, nam, cnt, ref_), bra
  end
end

-- get index from element (linear)
local function index_of_elm (seq, elm, ref_)
  local nam, data = elm.__id, var_raw(seq,_data)
  local ei = data.eidx[nam]
  if is_nil(ei) then return nil end
  ref_ = ref_ or 1
  assert(is_integer(ref_), "invalid reference index (integer expected)")
  local idx = assert(index_of_idx(seq, ref_), "invalid reference index")
  if is_number(ei) then
    return ei >= idx and data[ei] == elm and ei or nil
  end
  for i=1,ei.n do
    if ei[i] >= idx and data[ei[i]] == elm then return ei[i] end
  end
  return nil
end

-- get [mangled] name from index (linear)
local function name_of_idx (seq, idx, ref_)
  local data = var_raw(seq,_data)
  idx = index_of_idx(seq, idx)
  if is_nil(idx) then return nil end
  local nam = data[idx].__id
  local ei = data.eidx[nam]
  if is_number(ei) then
    assert(ei == idx, "unexpected corrupted dictionnary")
    return nam
  end

  local cnt, b1, b2 = 0
  if ref_ then
    assert(is_integer(ref_), "invalid reference index (integer expected)")
    local idx = assert(index_of_idx(seq, ref_), "invalid reference index")
    for i=1,ei.n do
      if ei[i] < idx then cnt = cnt+1 else break end
    end
    b1, b2 = "{", "}"
  else
    b1, b2 = "[", "]"
  end

  for i=1,ei.n do
    if ei[i] == idx then
      if cnt >= i then cnt = cnt+1 end
      return string.format("%s%s%d%s", nam, b1, i-cnt, b2)
    end
  end
  error("unexpected corrupted dictionnary")
end

-- position helpers -----------------------------------------------------------o

-- forward declaration
local elem_pos

-- return e-position of 'from', memoize result if count is not relative
local function from_epos (seq, from, idx)
  local data = var_raw(seq,_data)
  if data.last_from ~= from then                     -- memoized?
    local idx, bra = index_of_fnam(seq, from, idx)
    if is_nil(idx) then                              -- not found
      seq_error("invalid from of '" .. from .. "'", seq, idx)
    end
    data.last_frompos = second(elem_pos(seq, idx))
    data.last_from = bra ~= 2 and from or nil        -- memoize if not relative
  end
  return data.last_frompos                           -- epos
end

-- return e-position of 'refpos'
local function refpos_epos (elm, rpos, idx)
  if #elm == 0 then
    -- if not is_element(elm[rpos]) then
    seq_error("invalid refpos to subelement '" .. rpos .. "'", elm, idx)
  end
  return from_epos(elm, rpos)
end

-- return internal e-position of 'refpos'
local function refpos_pos (seq, elm, idx)
  local refpos = elm.refpos or seq.refer or 'centre'
  local rpos

      if refpos == 'entry'  then rpos = 0
  elseif refpos == 'centre' then rpos = elm.l/2
  elseif refpos == 'exit'   then rpos = elm.l
  elseif is_number(refpos)  then rpos = refpos
  else                           rpos = refpos_epos(elm, refpos, idx)
  end
  return rpos
end

-- forward index
-- return (#elm-1)+1 because seq[idx] == sseq[2] (see copy_ssequ and sequ_pos).
local function fidx (elm)
  return is_sequence(elm) and #elm or 1
end

local function fpos (at, elen, spos, epos)
  return at and epos or spos+elen
end

-- return e-position of 'from'
local function from_pos (seq, elm, idx)
  local at   = elm.at
  local from = elm.from or at and (at>=0 and 'start' or 'end') or 'prev'
  local epos = at or refpos_pos(seq, elm, idx)

      if from == 'start'    then ;
  elseif from == 'prev'     then epos = epos + fpos(at, seq[idx-1].l, elem_pos(seq,idx-1        ))
  elseif from == 'next'     then epos = epos + fpos(at,       -elm.l, elem_pos(seq,idx+fidx(elm)))
  elseif from == 'end'      then epos = epos + seq.l
  elseif from == 'selected' then epos = epos + seq:epos(idx)
  elseif is_number(from)    then epos = epos + from
  else                           epos = epos + from_epos(seq,from,idx)
  end
  return epos
end

-- build positions ------------------------------------------------------------o

-- set s-positions at index or return element s-positions
-- already declared for forward use, *must not be local*
function elem_pos (seq, idx, elm_)
  local data = var_raw(seq,_data)
  local spos = data.spos[idx]
  if is_nil(spos) then
    seq_error("invalid index or reference detected", seq, idx, elm_)
  elseif is_nil(elm_) then
    if spos >= 0 then
      return spos, data.epos[idx]
    elseif spos == ongoing_init then
      seq_error("cycling dependencies detected", seq, idx)
    elseif spos ~= uninitialized then
      seq_error("corrupted s-position detected", seq, idx)
    end
    data.spos[idx] = ongoing_init
  end

  local elm  = elm_ or data[idx]
  local epos =   from_pos(seq, elm, idx)
  local rpos = refpos_pos(seq, elm, idx)
  spos = epos - rpos

  if is_nil(elm_) then
    data.spos[idx], data.epos[idx] = spos, epos
  end
  return spos, epos
end

-- set s-positions of elements from their sub sequence
local function sequ_pos (seq, sseq, idx, dir)
  check_mark(sseq)
  local pos = elem_pos(seq, idx, sseq)    -- shift by subsequence refpos
  local data, sdata = var_raw(seq,_data), var_raw(sseq,_data)

  if seq.dir ~= sseq.dir then -- changedir patch
    data.spos[idx] = sdata.spos[1] + pos
    data.epos[idx] = sdata.epos[1] + pos
    idx = idx + 1
  end

  local n = sdata.ne
  if dir > 0 then
    for i=2,n-1 do
      data.spos[idx-2+i] = sdata.spos[i] + pos
      data.epos[idx-2+i] = sdata.epos[i] + pos
      assert(data[idx-2+i] == sdata[i], "unexpected corrupted flat sequence")
    end
  elseif dir < 0 then
    local l = sseq.l
    for i=2,n-1 do
      local sp, el = sdata.spos[n+1-i], sdata[n+1-i].l
      data.spos[idx-2+i] = l - (sp + el                           ) + pos
      data.epos[idx-2+i] = l - (sp + el - (sdata.epos[n+1-i] - sp)) + pos
      assert(data[idx-2+i] == sdata[n+1-i], "unexpected corrupted flat sequence")
    end
  else
    error("invalid direction (1 or -1 expected)")
  end

  if seq.dir ~= sseq.dir then -- changedir patch
    data.spos[idx+n] = sdata.spos[n] + pos
    data.epos[idx+n] = sdata.epos[n] + pos
  end
end

-- compute elements positions
local function build_pos (seq, sref)
  local data = var_raw(seq,_data)
  local n, idx, pos = data.ne, 1, 0
  sref = sref or {}
  for i=1,n do
    if data[i].from == 'selected' then
      seq_error("invalid from='selected' detected", seq, i, data[i])
    end
    data.spos[i], data.epos[i] = uninitialized, uninitialized
  end
  while idx <= n do
    local sseq = sref[idx]
    if is_nil(sseq) then     -- element
      elem_pos(seq, idx)
      if pos-minlen > data.spos[idx] then
        seq_poserr('element', seq, idx, pos)
      elseif data[idx].is_thin and data[idx].l ~= 0 then
        seq_lenerr("element", seq, idx, data[idx].l)
      end
      if data[idx].shared == true then -- shared element
        data[idx] = check_shared(seq, idx)
      end
      pos = data.spos[idx] + data[idx].l
      idx = idx + 1
    else                     -- subsequence
      sequ_pos(seq, sseq, idx, sref.sdir[idx])
      if pos-minlen > data.spos[idx] then
        seq_poserr('subsequence', seq, idx, pos)
      end
      local sdata = var_raw(sseq,_data)
      pos = data.spos[idx] - sdata.spos[2] + sseq.l
      idx = idx + sdata.ne-2
    end
  end
  assert(n == idx-1, "unexpected corrupted flat sequence")

  local len = data.spos[n]
  if seq.l == uninitialized then
    seq.l = len
  elseif seq.l < len then
    error("invalid sequence length "..seq.l.."m for "..seq.__id)
  end
end

-- flatten sequence -----------------------------------------------------------o

-- copy sub sequence
local function copy_ssequ (seq, flat, sref, idx, dir)
  check_mark(seq)
  local data = var_raw(seq,_data)
  if data.ne <= 2 then return idx end

  sref[idx], sref.sdir[idx] = seq, dir -- link subsequence

  if sref.dir ~= seq.dir then -- insert changedir patch
    idx, flat[idx] = idx+1, changedir(seq.__id.."_chdir", {})
  end

  local n = data.ne
      if dir ==  1 then
    for i=2,n-1 do flat[idx-2+i] = data[i    ] end
  elseif dir == -1 then
    for i=2,n-1 do flat[idx-2+i] = data[n+1-i] end
  else
    error("invalid direction (1 or -1 expected)")
  end

  if sref.dir ~= seq.dir then
    idx, flat[idx-2+n] = idx+1, flat[idx-1] -- share patch
  end
  return idx-2+n
end

-- flatten lines and subsequence
local function flatten_line (line, flat, sref, idx, dir)
  local n, rep = #line, (line.__rep or 1) * dir
  if n == 0 or rep == 0 then return idx end

  local start, stop, step
  if rep < 0
  then rep, start, stop, step = -rep, n, 1, -1
  else rep, start, stop, step =  rep, 1, n,  1
  end

  for i=1,rep do
  for j=start,stop,step do
    local elm = line[j]
    if not (is_element(elm) or is_rawtable(elm)) then
      seq_error("invalid element detected", line, j)
    elseif elm.is_bline == true or is_rawtable(elm) then
      idx = flatten_line(elm, flat, sref, idx, step)
    elseif not is_nil(sref) and is_sequence(elm) then
      idx = copy_ssequ  (elm, flat, sref, idx, step)
    else -- other elements
      idx, flat[idx] = idx+1, elm
    end
  end end
  return idx
end

-- flatten sequence
local function flatten_sequ (seq, flat, sref)
  local n, idx = seq:raw_len(), 2
  flat[1] = mkstart {at=0}
  for i=1,n do
    local elm = seq:raw_get(i)
    if not (is_element(elm) or is_rawtable(elm)) then
      seq_error("invalid element detected", seq, i)
    elseif elm.is_bline == true or is_rawtable(elm) then
      idx = flatten_line(elm, flat, sref, idx, 1)
    elseif is_sequence(elm) then
      idx = copy_ssequ  (elm, flat, sref, idx, 1)
    else -- other elements
      idx, flat[idx] = idx+1, elm
    end
  end
  flat[idx] = mkend {at= seq.l~=uninitialized and seq.l or nil}
  assert(n <= idx, "unexpected corrupted flat sequence")
end

-- dict helper ----------------------------------------------------------------o

-- build dictionnary name -> idx
local function build_idx (data)     -- must be very fast
  local eidx = data.eidx
  table.clear(eidx)                 -- reuse main storage
  for idx,elm in ipairs(data) do
    local nam = elm.__id
    local val = eidx[nam]
    if is_nil(val) then             -- none: scalar
      eidx[nam] = idx
    elseif is_number(val) then      -- one : scalar to array
      eidx[nam] = {val, idx, n=2}
    else                            -- many: append
      local n = val.n+1
      val[n], val.n = idx, n
    end
  end
end

-- build sequence -------------------------------------------------------------o

-- finalize sequence
local function finish_sequ (seq)
  local data = var_raw(seq,_data)

  -- clear memoization
  data.last_from    = nil
  data.last_frompos = nil

  -- $start/$end markers aliases
  local ei, ne = data.eidx, data.ne
  ei['#s'], ei['#S'] =  1,  1
  ei['#e'], ei['#E'] = ne, ne

  check_mark(seq)

  -- sanity checks
  if MAD.option.debug >= 2 then
    check_sequ(seq)
  end
end

-- sequence init (build)
local function sequ_init (seq)
  local n, owner = seq:raw_len(), raw_get(seq, 'owner')
  if n == 0 and not owner then return seq end -- empty

  local sref = { dir=seq.dir, sdir={} }
  local data = table.new(n+2,8)
  flatten_sequ(seq, data, sref)
  seq:clear_array()

  local ne = #data
  data.eidx = table.new(0,ne)
  data.epos = table.new(ne,0)
  data.spos = table.new(ne,0)
  seq[_data], data.ne = data, ne

  build_idx (data)
  build_pos  (seq, sref)
  finish_sequ(seq)
  return seq
end

-- sequence metamethods -------------------------------------------------------o

-- count proxy
local _idx = {}

local function cnt_iter (s, i)
  i = i+1
  local ei = s[_idx][i]
  if ei then return i, s[_data][ei] end
end

local cnt_mt = set_concept({
  __len       =\s   -> s[_idx].n,
  __index     =\s,i -> s[_data][s[_idx][i]],
  __ipairs    =\s   -> (cnt_iter, s, 0),
  __tostring  =\s   -> string.format("sequence count: %p", s),
}, not_mappable + not_extendable + not_mutable)

-- number of elements
local function len_mm (seq)
  return var_raw(seq,_data).ne
end

-- read access precedence: element index, variable key, element name.
local function index_mm (seq, key)
  -- element index
  if type(key) == 'number' then                              -- see index_of_idx
    local data = var_raw(seq,_data)
    return data[ reflect(key, data.ne) ]
  elseif type(key) == 'string' then
    -- method
    local mth = mth_get(seq, key)
    if mth then return mth end
  end
  -- variable
  local var = var_raw(seq, key)
  if not is_nil(var) then return var_val(seq, key, var) end
  -- element name
  local data = var_raw(seq,_data)
  local idx = data.eidx[key]
  if is_number(idx) then
    return data[idx]
  elseif is_table(idx) then
    return setmetatable({[_idx]=idx, [_data]=data}, cnt_mt)
  end
end

local function newindex_mm (seq, key, val)
  -- element index or name
  if is_number(key) or var_raw(seq,_data).eidx[key] then
    error("invalid sequence write access (use replace method)")
  end
  -- variable
  var_set(seq, key, val)
end

-- readonly protection --------------------------------------------------------o

local function set_readonly (seq, set_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local data = raw_get(seq,_data)
  if data then
    set_ = set_ ~= false and true or false
    if set_ ~= seq:is_readonly() then
      data.ro = set_
    end
  end
  return readonly(seq, set_)
end

-- methods (readonly) ---------------------------------------------------------o

local function index (seq, idx)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  assert(is_integer (idx), "invalid argument #2 (integer expected)")
  return index_of_idx(seq, idx)
end

local function name_of (seq, idx, ref_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  assert(is_integer (idx), "invalid argument #2 (integer expected)")
  return name_of_idx(seq, idx, ref_)
end

local function index_of (seq, a, ref_, dir_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
      if is_number (a) then return index_of_num(seq, a, dir_)
  elseif is_string (a) then return index_of_str(seq, a, ref_, dir_)
  elseif is_element(a) then return index_of_elm(seq, a, ref_)
  end
  error("invalid argument #2 (number, string or element expected)")
end

local function range_of (seq, rng_, ref_, dir_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local start, stop, step, istart, istop, doidx
  if is_nil(rng_) then
    local dir = dir_ or 1
        if dir ==  1 then return 1, #seq
    elseif dir == -1 then return #seq, 1
    else error("invalid range direction (1 or -1 expected)")
    end
  elseif is_number(rng_) then
    start, istart = rng_, index_of_num(seq, rng_, dir_)
    stop , istop  = start, istart
  elseif is_string(rng_) then
    local s1, i2 = strsplit(rng_, "/")
    local s2 = i2 == 0 and s1 or strtrim(rng_, i2+1)
    doidx, start, stop = true, s1, s2
  elseif is_range(rng_) then
    doidx, start, stop, step = true, rng_:ranges()
    dir_ = dir_ or step
  elseif is_table(rng_) then
    start, stop, ref_, dir_ = rng_[1], rng_[2] or rng_[1], ref_ or rng_[3],
                                                           dir_ or rng_[4]
    if ref_ == 'idx' then
      assert(is_integer(start) and is_integer(stop),
             "invalid argument #2 (range of integers expected)")
      istart, istop = index_of_idx(seq, start), index_of_idx(seq, stop)
    else doidx = true
    end
  else error("invalid argument #2 (number, string, table or range expected)")
  end
  local sstart, sstop
  if doidx then
    local dir = dir_ or 1
    assert(dir == 1 or dir == -1, "invalid range direction (1 or -1 expected)")
    istart, sstart = index_of(seq, start, ref_,  dir)
    istop , sstop  = index_of(seq, stop , ref_, -dir)
  end
  if not istart then errorf("invalid range start '%s'", tostring(start)) end
  if not istop  then errorf("invalid range stop '%s'" , tostring(stop )) end
  if sstart and sstop and (istart-istop)*(sstart-sstop) < 0 then
    return nil -- empty range
  end
  return istart, istop
end

local function length_of (seq, rng_, ntrn_, dir_) -- see iter
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local start, stop = range_of(seq, rng_, nil, dir_)
  if is_nil(start) then return 0 end
  local dir = dir_ or 1
  local siz, trn = (stop-start)*dir, ntrn_ or 1
  return 1 + siz + #seq * (trn-1 + (siz < 0 and 1 or 0))
end

-- functional methods ---------------------------------------------------------o

local pcls   = is_instanceOf
local psel   = marker.is_selected
local pnam   = \pat, e,i -> string.match(e.__id, pat) ~= nil
local pand   = \p,p2,e,i -> p(e,i) and p2(e,i)
local ptrue  = \p,_ ,e,i -> p(e,i) and true
local pfalse = \p,_ ,e,i -> p(e,i) or false

local function foreach (seq, act, rng_, sel_, not_) -- action, range, selection, default
  local f, p

  -- foreach(sel) -> foreach(sel.action, sel)
  if is_nil(rng_) and is_rawtable(act) then
    f, rng_ = act.action, act     -- extract action + right shift
  else
    f = act
  end
  -- foreach(act,sel) -> foreach(act, sel.range, sel)
  if is_nil(sel_) and is_rawtable(rng_) and is_nil(rng_[1]) then
    rng_, sel_ = rng_.range, rng_ -- extract range  + right shift
  end

  if is_rawtable(sel_) then       -- logically and'ed selections
    if is_nil(not_) and (sel_.default == 'none' or sel_.default == true) then
      not_ = true
    end
    local op = not_ ~= true and ptrue or pfalse
    if sel_.select then
      assert(is_callable(sel_.select), "invalid select (callable expected)")
      op, p = pand, bind2st(op, sel_.select, p)
    end
    if sel_.class then
      assert(is_element(sel_.class), "invalid class (element expected)")
      op, p = pand, bind2st(op, bind2nd(pcls, sel_.class), p)
    end
    if sel_.pattern then
      assert(is_string(sel_.pattern), "invalid pattern (string expected)")
      op, p = pand, bind2st(op, bind1st(pnam, sel_.pattern), p)
    end
    if sel_.flag then
      assert(is_number(sel_.flag), "invalid flag (number expected)")
      op, p = pand, bind2st(op, bind2nd(psel, sel_.flag), p)
    end
  elseif not is_nil(sel_) then    -- build the selection
    p = is_number  (sel_) and bind2nd(psel, sel_) or
        is_string  (sel_) and bind1st(pnam, sel_) or
        is_element (sel_) and bind2nd(pcls, sel_) or
        is_callable(sel_) and sel_                or nil
  end
  if is_nil(p) then p = (not_ ~= true or rng_) and ltrue or lfalse end

  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  assert(is_callable(f)  , "invalid argument #2 (callable expected)")
  assert(is_callable(p)  , "invalid argument #4 (callable expected)")

  if p ~= lfalse then
    for idx,elm in seq:iter(rng_) do
      if p(elm,idx) then f(elm,idx) end
    end
  end
  return seq
end

local do_select = marker.select

local function select (seq, flg_, rng_, sel_, not_)
  if is_rawtable(flg_) and is_nil(rng_) and is_nil(sel_) then
    rng_, flg_ = flg_ -- right shift
  end
  local f = bind2nd(do_select, flg_)
  return seq:foreach(f, rng_, sel_, not_)
end

local do_deselect = marker.deselect

local function deselect (seq, flg_, rng_, sel_, not_)
  if is_rawtable(flg_) and is_nil(rng_) and is_nil(sel_) then
    rng_, flg_ = flg_ -- right shift
  end
  local f = bind2nd(do_deselect, flg_)
  return seq:foreach(f, rng_, sel_, not_)
end

local do_filter = \ei,_,i => local n=ei.n+1 ; ei[n], ei.n = i, n end

local function filter (seq, rng_, sel_, not_)
  local ei = table.new(8,1)
  local f = bind1st(do_filter, ei)
  ei.n = 0
  seq:foreach(f, rng_, sel_, not_)
  local n = ei.n ; ei.n = nil
  return ei, n
end

-- methods (R/W, rebuild dict) ------------------------------------------------o

local function build_index (seq)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local data = var_raw(seq,_data)
  build_idx (data)
  finish_sequ(seq)
  return seq
end

local function remove (seq, rng_, sel_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local data = var_raw(seq,_data)
  assert(not (data.ro or seq:is_readonly()), "invalid write access to readonly sequence")

  -- collect indexes of elements to remove
  local idx_r, nr = filter(seq, rng_, sel_, true)
  if nr == 0 then return end

  assert(idx_r[nr]-idx_r[1] >= nr-1, "invalid range, indexes must be increasing")
  assert(idx_r[1] > 1              , "invalid range, $start marker selected")
  assert(idx_r[nr] < data.ne       , "invalid range, $end marker selected")

  -- remove elements by decreasing indexes -- to optimize to avoid O(N^2) removal
  local elm_r = table.new(nr,0)
  for i=nr,1,-1 do
    local ii = idx_r[i]
    elm_r[i] = data[ii]    -- backup
    table.remove(data     , ii)
    table.remove(data.spos, ii)
    table.remove(data.epos, ii)
  end
  data.ne = #data

  build_index(seq)
  return elm_r, idx_r
end

local function replace (seq, elm, rng_, sel_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local data = var_raw(seq,_data)
  assert(not (data.ro or seq:is_readonly()), "invalid write access to readonly sequence")

  if is_rawtable(elm) and is_nil(rng_) and is_nil(sel_) and elm.elements then
    rng_, elm = elm, elm.elements -- extract elements + right shift
  end

  if is_element(elm) then elm = {elm} end
  assert(is_rawtable(elm), "invalid argument #2 (elements list expected)")
  local ne = #elm
  if ne == 0 then return end

  -- check for elements only
  for i=1,ne do
    if not is_element(elm[i]) then
      error("item is not an element '"..
        (is_object(elm[i]) and (elm[i].__id or '?') or type(elm[i])).."'")
    elseif is_sequence(elm[i]) then
      error("element is a sequence '"..(elm[i].__id or '?').."'")
    elseif elm[i].is_bline == true then
      error("element is a beam line '"..(elm[i].__id or '?').."'")
    end
  end

  -- collect indexes of elements to replace
  local idx_r, nr = filter(seq, rng_, sel_, true)
  if nr == 0 then return end
  assert(idx_r[nr]-idx_r[1] >= nr-1, "invalid range, indexes must be increasing")

  local elm_r = table.new(nr,0)
  for i=1,nr do                                -- replace elements
    local ii, ie = idx_r[i], (i-1)%ne+1        -- recycle list of elements
    data[ii], elm_r[i] = elm[ie], data[ii]     -- backup
    data.spos[ii], data.epos[ii] = uninitialized, uninitialized
  end
  for i=1,nr do elem_pos(seq, idx_r[i]) end -- recompute the positions
  for i=1,nr do
    local idx = idx_r[i]
    if data[idx].shared == true then         -- shared element
      data[idx] = check_shared(seq, idx)
    end
    check_drift(seq, idx)                   -- check surrounding drifts
  end

  build_index(seq)
  return elm_r, idx_r
end

local function install (seq, elm, rng_, sel_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local data = var_raw(seq,_data)
  assert(not (data.ro or seq:is_readonly()), "invalid write access to readonly sequence")

  if is_rawtable(elm) and is_nil(rng_) and is_nil(sel_) and elm.elements then
    rng_, elm = elm, elm.elements -- extract elements + right shift
  end

  if is_element(elm) then elm = {elm} end
  assert(is_rawtable(elm), "invalid argument #2 (elements list expected)")
  local ne = #elm
  if ne == 0 then return seq end

  -- collect indexes of reference where to insert
  local idx_r, nr = filter(seq, rng_, sel_, true)
  if nr > 0 then
    assert(idx_r[nr]-idx_r[1] >= nr-1, "invalid range, indexes must be increasing")
  end

  -- collect elements and subsequences to install
  local ins = table.new(ne,0) -- no sref -> keep subsequence as-is
  flatten_line(elm, ins, nil, 1, 1)
  elm, ne, ins = ins, #ins -- update

  -- precompute number of elements with from='selected'
  local ns = 0
  for i=1,ne do
    if elm[i].from == 'selected' then
      if is_sequence(elm[i]) then
        error("invalid from 'selected' for sequence "..(elm[i].__id or '?'))
      end
      ns = ns+1
    end
  end

  -- precompute position of each element
  -- ne: #element to install, ns: #element with from='selected', nr: #element selected
  -- ne-ns: #element to install once, ns*nr: ns elements to install nr times
  local i, ni = 0, ne-ns + ns*nr
  local ins, spos, epos = table.new(ni,0), table.new(ni,0), table.new(ni,0)
  for ie=1,ne do
    if elm[ie].from ~= 'selected' then
      i = i + 1
      ins[i], spos[i], epos[i] = elm[ie], elem_pos(seq, 2        , elm[ie])
    else for ir=1,nr do
      i = i + 1
      ins[i], spos[i], epos[i] = elm[ie], elem_pos(seq, idx_r[ir], elm[ie])
    end end
  end

  -- insert elements -- to optimize to avoid O(N^2) insertion
  for ie=1,i do
    local idx = bsearch(data.spos, spos[ie], 2, data.ne)
    if is_sequence(ins[ie]) and #ins[ie] > 2 then
      local sdata = var_raw(ins[ie],_data)
      table.move(data     , idx, data.ne, idx+sdata.ne-2)
      table.move(data.spos, idx, data.ne, idx+sdata.ne-2)
      table.move(data.epos, idx, data.ne, idx+sdata.ne-2)
      for j=2,sdata.ne-1 do -- see sequ_pos
        data     [idx+j-2] = sdata     [j]
        data.spos[idx+j-2] = sdata.spos[j]+spos[ie]
        data.epos[idx+j-2] = sdata.epos[j]+spos[ie]
      end
      data.ne = data.ne + sdata.ne - 2
      check_drift(seq, idx+sdata.ne - 3) -- check surrounding drifts of lst data
    else
      table.insert(data     , idx, ins [ie])
      table.insert(data.spos, idx, spos[ie])
      table.insert(data.epos, idx, epos[ie])
      data.ne = data.ne + 1
      if data[idx].shared == true then    -- shared element
        data[idx] = check_shared(seq, idx)
      end
      check_drift(seq, idx)              -- check surrounding drifts
    end
  end

  build_index(seq)
  return seq
end

local function copy (seq, name_, owner_)
  if is_nil(owner_) and is_boolean(name_) then
    owner_, name_ = name_
  end
  assert(not rawequal(seq, sequence), "invalid argument #1 (cannot copy 'sequence')")
  assert(is_sequence(seq)           , "invalid argument #1 (sequence expected)")
  local cpy = seq_cpy(seq,name_)
  if is_view(seq) and not owner_ then return cpy end

  local data = var_raw(seq,_data)
  local ne = data.ne
  local cdata = table.new(ne,5)  -- see sequ_init
  cdata.eidx  = table.new(0,ne)
  cdata.epos  = table.new(ne,0)
  cdata.spos  = table.new(ne,0)
  cpy[_data], cdata.ne = cdata, ne

  for i=1,ne do
    cdata[i] = data[i]:copy()
    cdata.spos[i], cdata.epos[i] = data.spos[i], data.epos[i]
  end

  build_index(cpy)
  return cpy
end

-- special --------------------------------------------------------------------o

local function cycle (seq, a)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  assert(index_of(seq, a), "invalid argument #2 (reference expected)")
  seq.start_at = a
  return seq
end

local function share (seq1, seq2)
  assert(is_sequence(seq1), "invalid argument #1 (sequence expected)")
  assert(is_sequence(seq2), "invalid argument #2 (sequence expected)")
  check_mark(seq1) check_mark(seq2)
  local data1 = var_raw(seq1,_data)
  local data2 = var_raw(seq2,_data)
  assert(not (data1.ro or seq1:is_readonly()), "invalid write access to readonly sequence")
  assert(not (data2.ro or seq2:is_readonly()), "invalid write access to readonly sequence")

  local elm_r, idx_r, nr = {}, {}, 1
  for i=2,data1.ne-1 do
    local nam = data1[i].__id   -- share by (unique) name
    if data2.eidx[nam] then     -- element name found in seq2
      local i1, i2 = data1.eidx[nam], data2.eidx[nam]
      -- ensure that elements are unique in both sequences
      assert(is_integer(i1) and is_integer(i2), "invalid shared element (must be unique)")
      local e1, e2 = data1[i1], data2[i2]
      if e1 ~= e2 then
        assert(e1.__id == nam and e2.__id == nam, "unexpected corrupted dictionnary")
        local ds1 = data1.epos[i1]-data1.spos[i1]
        local ds2 = data2.epos[i2]-data2.spos[i2]
        assert(abs(e1.l-e2.l) < minlen, "incompatible shared elements (lengths differ)")
        assert(abs(ds1 -ds2 ) < minlen, "incompatible shared elements (epos-spos differ)")
        -- update arrays
        data2[i2], elm_r[nr], idx_r[nr], nr = e1, e2, i2, nr+1
      end
    end
  end
  finish_sequ(seq1) finish_sequ(seq2)
  return elm_r, idx_r
end

local function unique (seq, fmt_)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  if is_string(fmt_) then fmt_ = bind1st(string.format, fmt_) end
  assert(is_nil(fmt_) or is_callable(fmt_), "invalid argument #2 (callable expected)")
  local data, lst = var_raw(seq,_data), table.new(0,100)
  assert(not (data.ro or seq:is_readonly()), "invalid write access to readonly sequence")

  for en,ei in pairs(data.eidx) do
    if is_table(ei) then
      table.clear(lst)
      for i=1,ei.n do
        local idx = ei[i]
        local elm = data[idx]
        lst[elm] = (lst[elm] or 0)+1
      end
      for i=1,ei.n do
        local idx, nam = ei[i]
        local elm = data[idx]
        if fmt_ then
          nam = fmt_(elm.__id, i, idx)
          if data.eidx[nam] ~= nil then
            error("cannot rename uniquely element '"..nam.."' (already in use)")
          end
          data.eidx[nam] = idx
        end
        if lst[elm] > 1 then
          data[idx] = elm(nam,{})    -- replaced by unique child
        elseif fmt_ then
          elm:raw_set('__id', nam)   -- override with unique name
        end
      end
      if fmt_ then data.eidx[en] = nil end
    end
  end
  finish_sequ(seq)
  return seq
end

-- iterators ------------------------------------------------------------------o

local function is_implicit (elm)
  return test_flag(elm, implicit)
end

local function niliter (state, i)
  return nil
end

local function fwditer (state, i)
  if i == state.stop then
    if state.turn == 0 then return nil end
    state.turn = state.turn-1
  end
  if i < state.ne then
    i = i+1
  else
    i, state.soff = 1, state.soff+state.seq_l
  end
  return i, state.data[i], state.spos[i]+state.soff
end

local function bwditer (state, i)
  if i == state.stop then
    if state.turn == 0 then return nil end
    state.turn = state.turn-1
  end
  if i > 1 then
    i = i-1
  else
    i, state.soff = state.ne, state.soff+state.seq_l
  end
  return i, state.data[i], state.spos[i]+state.data[i].l-state.soff
end

---

local function fwdsiter (state, i)
  if i == state.stop and not is_implicit(state.elm) then
    if state.turn == 0 then return nil end
    state.turn = state.turn-1
  end
  if i < state.ne then
    if is_implicit(state.elm) then -- last elm was the implicit drift
      i = i+1
      state.pos = state.spos[i]
      state.elm = state.data[i]
    else
      local dl = state.spos[i+1] - (state.spos[i]+state.data[i].l)
      if dl < minlen then                  -- implicit drift is too small
        if dl < -minlen then
          errorf("negative implicit drift of %sm in %s['%s'] at %sm",
                  dl, state.seq.name, state.data[i+1].name, state.spos[i+1])
        end
        i = i+1
        state.pos = state.spos[i]
        state.elm = state.data[i]
      else                                 -- update implicit drift
        state.pos   = state.spos[i]+state.data[i].l
        state.elm   = state.dft
        state.elm_l = dl
        state.elm_s = 'drift__'..i
      end
    end
  else
    i, state.elm    , state.pos    , state.soff =
    1, state.data[1], state.spos[1], state.soff+state.seq_l
  end
  return i, state.elm, state.pos+state.soff
end

local function bwdsiter (state, i)
  if i == state.stop and not is_implicit(state.elm) then
    if state.turn == 0 then return nil end
    state.turn = state.turn-1
  end
  if i > 1 then
    if is_implicit(state.elm) then -- last elm was the implicit drift
      i = i-1
      state.pos = state.spos[i]+state.data[i].l
      state.elm = state.data[i]
    else
      local dl = state.spos[i] - (state.spos[i-1]+state.data[i-1].l)
      if dl < minlen then                  -- implicit drift is too small
        if dl < -minlen then
          errorf("negative implicit drift of %sm in %s['%s'] at %sm",
                  dl, state.seq.name, state.data[i-1].name, state.spos[i-1])
        end
        i = i-1
        state.pos = state.spos[i]+state.data[i].l
        state.elm = state.data[i]
      else                                 -- update implicit drift
        state.pos   = state.spos[i]
        state.elm   = state.dft
        state.elm_l = dl
        state.elm_s = 'drift__'..i
      end
    end
  else
    i, state.soff = state.ne, state.soff+state.seq_l
    state.elm, state.pos = state.data[i], state.spos[i]+state.data[i].l
  end
  return i, state.elm, state.pos-state.soff
end

---

local function iter (seq, rng_, ntrn_, dir_)
  local nturn, dir = ntrn_ or 1, dir_ or 1
  assert(is_sequence(seq)                ,"invalid argument #1 (sequence expected)")
  assert(is_integer(nturn) and nturn > 0 ,"invalid argument #3 (integer >1 expected)")
  assert(dir == 1 or dir == -1           ,"invalid argument #4 (1 or -1 expected)")

  if #seq == 0 then return niliter end

  local data, start, stop = var_raw(seq,_data)
  if is_nil(rng_) then
    local idx1, idxn = 1, data.ne
    if dir < 0 then idx1, idxn = idxn, idx1 end
    if is_nil(seq.start_at) then
      start, stop = idx1, idxn
    else
      start = assert(index_of(seq, seq.start_at), "invalid cycle reference")
      stop  = start == idx1 and idxn or start-dir
    end
  else
    start, stop = range_of(seq, rng_, nil, dir_)
    if is_nil(start) then return niliter end
  end
  if start == stop+dir then nturn = nturn+1 end

  local soff = dir > 0 and -data.spos[start] or data.spos[start]+data[start].l
  return dir > 0 and fwditer or bwditer, {data=data, spos=data.spos, soff=soff,
    seq=seq, seq_l=seq.l, elm_l=0, elm_s='', ne=data.ne, stop=stop, turn=nturn-1},
    start-dir
end

local function siter (seq, rng_, ntrn_, dir_)
  local iter, state, start = iter(seq, rng_, ntrn_, dir_)
  if iter == niliter then return iter end
  -- implicit drift (reused)
  state.dft = drift { l := state.elm_l, name := state.elm_s }
  state.elm = state.dft :set_flag(implicit) :set_readonly()
  if start == state.stop then state.turn = state.turn-1 end
  return dir_ and dir_ < 0 and bwdsiter or fwdsiter, state, start
end

-- flags ----------------------------------------------------------------------o

local function save_flags (seq)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local data = var_raw(seq,_data)
  local flgs = table.new(data.ne,0)
  for i=1,data.ne do flgs[i] = data[i]:get_flags() end
  if is_nil(data.flgs) then data.flgs = { n=0 } end
  local n = data.flgs.n+1
  data.flgs[n], data.flgs.n = flgs, n
end

local function drop_flags (seq)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local data = var_raw(seq,_data)
  assert(not (is_nil(data.flgs) or data.flgs.n == 0), "saved flags not found")
  local n = data.flgs.n
  data.flgs[n], data.flgs.n = nil, n-1
end

local function restore_flags (seq)
  assert(is_sequence(seq), "invalid argument #1 (sequence expected)")
  local data = var_raw(seq,_data)
  assert(not (is_nil(data.flgs) or data.flgs.n == 0), "saved flags not found")
  local n = data.flgs.n
  local flgs = data.flgs[n]
  for i=1,data.ne do data[i]:clear_flags(-1):set_flags(flgs[i]) end
  data.flgs[n], data.flgs.n = nil, n-1
end

-- I/O ------------------------------------------------------------------------o

-- dump seq positions
local function dumpseq (seq, filnam_)
  local res = table.new(#seq,0)

  -- header
  res[1] = 'sequence: ' .. seq.name .. ', ' ..
           'l=' .. (seq.l == uninitialized and 'uninitialized' or seq.l)
  res[2] = 'idx    name                        l         spos         epos         ds'
  -- elements
  seq:foreach \e,i =>
    res[#res+1] = string.format('%03d    %-15s    %10.3f   %10.3f   %10.3f   %8.3f',
                  i, e.__id, e.l, seq:spos(i), seq:epos(i), seq:epos(i)-seq:spos(i))
    end

  -- return result as a string
  if filnam_ == '-' then return table.concat(res, '\n') end

  -- dump to file
  local file = openfile(filnam_, 'w', '.dat')
  for _,s in ipairs(res) do file:write(s,'\n') end
  if is_string(filnam_) then file:close() else file:flush() end

  return seq
end

-- members --------------------------------------------------------------------o

sequence.original = original

sequence :set_methods {
  -- elem, spos, epos, canonical index
  elem          = \s,i -> var_raw(s, _data)     [i],
  spos          = \s,i -> var_raw(s, _data).spos[i],
  epos          = \s,i -> var_raw(s, _data).epos[i],
  index         = index,

  -- elements manipulation
--  getelm       = get_elm,
--  addelm       = add_elm,
--  setelm       = set_elm,
--  remelm       = rem_elm,
--  inselm       = ins_elm,

  -- sequence-like methods
  name_of       = name_of,
  index_of      = index_of,
  range_of      = range_of,
  length_of     = length_of,

  foreach       = foreach,
  filter        = filter,

  replace       = replace,
  install       = install,

  cycle         = cycle,
  share         = share,
  unique        = unique,
  iter          = iter,
  siter         = siter,

  -- flags
  save_flags    = save_flags,
  drop_flags    = drop_flags,
  restore_flags = restore_flags,

  -- read/write/dump
  read         := error("NYI", 2), -- TODO (possible?)
  write        := error("NYI", 2), -- TODO (useful?)
  dumpseq       = dumpseq,

  -- ownership
  is_owner      = is_owner,
  is_view       = is_view,

  -- for debugging
  check_sequ    = check_sequ,

} :set_methods ({
  -- overridden methods
  copy          = copy,
  remove        = remove,
  select        = select,
  deselect      = deselect,
  set_readonly  = set_readonly,

  -- disable method
  is_selected  := error("invalid sequence operation", 2),

}, true) :set_metamethods ({
  __len         = len_mm,
  __index       = index_mm,
  __newindex    = newindex_mm,
-- __pairs      = pairs_mm , default from object
-- __ipairs     = ipairs_mm, default from object
  __copy        = copy,
  __init        = sequ_init,

}, true) :set_readonly()

-- env ------------------------------------------------------------------------o

MAD.typeid.is_sequence = is_sequence

-- end -------------------------------------------------------------------------
return { sequence = sequence }

--[=[ TODO?
SEQUENCE DISPLAY

local function show_fields(t, lst)
  local a, k, s
  lst = lst or sequence_fields
  for _,v in ipairs(lst) do
    if is_list(v) then k, s = v[1], v[2] else k, s = v, v end
    a = t[k]
    if a then io.write(', ', s, '= ', tostring(a)) end
  end
end

function M:show(disp)
  io.write("sequence '", self.__id,"' { ")
  show_list(self, disp)
  io.write(' }\n')
  for _,v in ipairs(self) do v:show(disp) end
  io.write('endsequence\n')
end

function M:show_madx(disp)
  io.write("'", self.__id, "': sequence, ")
  show_list(self, disp)
  io.write(';\n')
  for _,v in ipairs(self) do v:show_madx(disp) end
  io.write('endsequence;\n')
end
--]=]
