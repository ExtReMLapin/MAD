--[=[
 o-----------------------------------------------------------------------------o
 |
 | MAD environment (sandbox)
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Load in order all the modules in the MAD environment.

 o-----------------------------------------------------------------------------o
]=]

local M = {}

-- modules --------------------------------------------------------------------o

-- list of modules to import in MAD

local modules = {
  -- Lua modules --

  -- Strict, LPEG, LuaFun, LuaFileSystem, LuaUnit
  'strict', 'regex', 'lfun', 'lfs', -- 'utest',

  -- MAD modules (order matters!) --

  -- utilities
  'typeid', 'constant', 'gfunc', 'gutil',
  -- maths
  'gmath', 'range', 'complex', 'matrix', 'mono', 'gtpsa',
  -- objects
  'object', 'beam', 'element', 'sequence', 'mtable',
  -- physics
  'gphys', 'damap', 'geomap', 'dynmap', 'symint',
  -- commands
  'command', 'survey', 'track', 'cofind', 'twiss', 'plot',
  -- environments
  'madx',
}

-- list of global variables to cleanup after import
local globals = {
  'lpeg', 're', 'lfs',
}

-- locals ---------------------------------------------------------------------o

local ffi    = require 'ffi'
local _C     = require 'madl_cmad'
local typeid = require 'madl_typeid' .typeid

local is_nil, is_boolean, is_number, is_string, is_mappable,
      is_callable, wprotect, wrestrict, set_concept, concept     in typeid
local not_iterable                                               in concept

-- implementation -------------------------------------------------------------o

-- hidden key.
local _hlp = {}

M[_hlp]   = {}  -- backup for help
M._C      = _C  -- C symbol access

-- env

local env = _M ; _M = nil

env.arg            =  arg
env.is_tty         = \ -> _C.mad_stdin_is_tty   ~= 0
env.is_interactive = \ -> _C.mad_is_interactive ~= 0

M.env = wprotect(setmetatable(env, {__tostring := "MAD.env"}))

-- option

local option = {

  format   = "%.15g",
  debug    = nil, -- proxy for mad_trace_level
  location = nil, -- proxy for mad_trace_location

}

M.option = setmetatable(option, {
  __tostring = \-> "MAD.option",
  __index    = \_,k =>   if k == 'debug'    then return _C.mad_trace_level
                     elseif k == 'location' then return _C.mad_trace_location
               end end,
  __newindex = \_,k,v => if k == 'debug'    then _C.mad_trace_level    = v
                     elseif k == 'location' then _C.mad_trace_location = v
                     else error("invalid write access to object <MAD.option>",2)
               end end,
})

-- trace, warning

local ctrace = trace ; trace = nil
local cwarn  = warn  ; warn  = nil

M.warn  = \fmt,...     => cwarn(string.format(fmt, ...)) end
M.trace = \lvl,fmt,... => if lvl >= _C.mad_trace_level then
                            ctrace(lvl, string.format(fmt, ...))
                          end end

-- atexit (and finalizer)

local _final = { n=0 } -- __gc not applicable to table (added in 5.2)

_final[_final] = ffi.gc(ffi.new('int[1]'),
  function ()
    if M.option.debug >= 2 then
      io.write('MAD finalizer called...\n')
    end
    for i=_final.n,1,-1 do
      local ret, err = pcall(_final[i])
      if ret ~= true then
         io.stderr:write('finalizer failed: ', err, '\n')
      end
    end
  end)

function M.atexit (f, uniq_)
  assert(is_callable(f), "invalid argument #1 (callable expected)")

  -- check if not already registered
  if uniq_ and _final[f] then return end

  -- register
  local n = _final.n+1
  _final[f], _final[n], _final.n = f, f, n

  -- override os.exit to force gc to call finalizers
  if n == 1 then
    local exit = os.exit
    os.exit = \code -> exit(code, true)
  end
end

-- import

local loaded_mod = {}

local function loadreq (modnam)
  local status, mod = pcall(require, modnam)
  local err

  if not status then
    if not string.find(mod, "module '"..modnam.."' not found:") then
      error('<'..mod .. '> while loading module ' .. modnam)
    end
    mod, err = nil, mod
  end
  return mod, err
end

local function loadmod(modnam)
  local mod, hlp, err

  hlp, mod, err = true, loadreq('madl_'..modnam)    -- 1st attempt
  if not mod then
    hlp, mod, err = false, loadreq(modnam)          -- 2nd attempt
  end
  assert(mod, err)

  if loaded_mod[mod] then return nil end

  if hlp then
    hlp, err = loadreq('madh_'..modnam)                 -- 1st attempt for help
    if not hlp then hlp, err = loadreq('help.madh_'..modnam) end -- 2nd attempt
    assert(hlp, err)
    assert(not mod.__help, "help already registered")
    mod.__help = hlp
  end

  loaded_mod[mod] = mod
  return mod
end

function M.import (to, from, override_)
  if to ~= MAD and is_nil(override_) then
    to, from, override_ = MAD, to, from -- right shift
  end

  -- load module first
  if is_string(from) then
    from = loadmod(from)
    if is_nil(from) then return MAD end -- module already loaded
  end

  local override = override_ or false
  assert(to == MAD           , "invalid argument #1 (MAD expected)")
  assert(is_mappable(from)   , "invalid argument #2 (mappable expected)")
  assert(is_boolean(override), "invalid argument #3 (boolean expected)")

  -- collect and check first (make a copy in case of error)
  local obj = {}
  for k,v in pairs(from) do
    if is_string(k) and string.sub(k,1,2) ~= '__' then
      if M.option.debug >= 2 then
        io.write(string.format('import: %-25s %-25s\n',k,v))
      end
      assert(is_nil(MAD[k]) or MAD[k] == v or override == true,
             "cannot override definition for " .. tostring(k))
      obj[k] = v
    end
  end
  -- finalize the import
  for k,v in pairs(obj) do M[k] = v end
  -- record the help
  if is_mappable(from.__help) then
    M[_hlp][from.__help] = from.__help
  end
  return MAD
end

-- export

function M.export (from, what_, to_, override_)
  if from ~= MAD and is_nil(override_) then
    from, what_, to_, override_ = MAD, from, what_, to_ -- right shift
  end
  if (is_nil(what_) or is_boolean(what_)) and is_nil(override_) then
    what_, override_ = MAD, what_ -- right shift
  end
  if (is_nil(to_) or is_boolean(to_)) and is_nil(override_) then
    to_, override_ = _G, to_ -- right shift
  end
  local what     = is_string(what_) and {what_} or what_ or MAD
  local to       = to_       or _G
  local override = override_ or false
  assert(from == MAD         , "invalid argument #1 (MAD expected)")
  assert(is_mappable(what)   , "invalid argument #2 (mappable expected)")
  assert(is_mappable(to)     , "invalid argument #3 (mappable expected)")
  assert(is_boolean(override), "invalid argument #4 (boolean expected)")

  -- collect and check first (make a copy in case of error)
  local obj = {}
  for k,v in pairs(what) do
    if is_number(k) and is_string(v) then
      k, v = v, MAD[v]
    end
    if is_string(k) and string.sub(k,1,2) ~= '__' then
      if M.option.debug >= 2 then
        io.write(string.format('export: %-25s %-25s\n',k,v))
      end
      assert(is_nil(to[k]) or to[k] == v or override == true,
             "cannot override definition for " .. tostring(k))
      obj[k] = v
    end
  end

  -- finalize the export
  for k,v in pairs(obj) do to[k] = v end
  return MAD
end

-- help

local function help_grab (tt)
  local lst = {}
  for _,t in pairs(tt) do
  for k,v in pairs(t ) do
      assert(is_nil(lst[k]), "unexpected duplicated data for "..k)
      lst[k] = v
  end end
  return lst
end

local function help_fmt (tt, n)
  local len = 2 -- tab
  for i,v in ipairs(tt) do
    len = len + #v + 2 -- sep
    if len > n then tt[i] = '\n  '..v ; len = #v + 2 end
  end
  return table.concat(tt, ', ')
end

function M.help (from, pattern_)
  if from ~= MAD and is_nil(pattern_) then
    from, pattern_ = MAD, from  -- right shift
  end
  local pattern = pattern_ or "^([%w_]+)$"
  assert(from == MAD       , "invalid argument #1 (MAD expected)")
  assert(is_string(pattern), "invalid argument #2 (string expected)")

  local hlp, sel, key = help_grab(MAD[_hlp]), {}, nil
  for k,v in pairs(hlp) do
    assert(is_string(v), "invalid data for "..k.." (string expected)")
    local kl = string.lower(k)
    if k == pattern or kl == pattern then
      key = k
    elseif string.match(k, pattern) or string.match(kl, pattern) then
      sel[#sel+1] = k
    end
  end

  if #sel == 0 and is_nil(key) then
    io.write("  No help found for '" .. pattern .. "'.")
  elseif not is_nil(key) then
    io.write(hlp[key])
  end

  table.sort(sel)
  local str = help_fmt(sel, 80)
  if str ~= '' then
    io.write("\nRelated topics:\n  ", str, ".\n")
  end
  io.write("\n")
end

-- show

local function show_cmp (ka, kb)
  if type(ka) == type(kb) then
    return ka < kb
  else
    return tostring(ka) < tostring(kb)
  end
end

function M.show (a, strict_)
  assert(is_mappable(a), "invalid argument #1 (mappable expected)")
  local is_object in MAD.typeid
  local keys
  if is_object(a) and is_object(strict_) then
    keys = a:get_varkeys(strict_)
  else
    keys = {}
    for k in pairs(a) do
      if is_string(k) and k:sub(1,2) ~= '__' or strict_ == false then
        keys[#keys+1] = k
      end
    end
  end
  table.sort(keys, show_cmp)
  for i=1,#keys do
    io.write(string.format("%-25s", tostring(  keys[i] )..':'),
                                    tostring(a[keys[i]])  , '\n')
  end
end

-- environment ----------------------------------------------------------------o

-- protect MAD
MAD = wprotect(setmetatable(M, {__tostring := "MAD"}))

-- import MAD as a self reference
MAD:import {
  MAD    = MAD,
--  __help = require 'madh_main',
}

-- load modules
for _,m in ipairs(modules) do MAD:import(m) end

-- cleanup globals
for i,v in ipairs(globals) do _G[v] = nil end

-- useful as globals
_M   = MAD
help = MAD.help
show = MAD.show

-- check _G pollution ---------------------------------------------------------o

local _G_env = {
  -- Lua
  '_G', '_PROMPT', '_PROMPT2', '_VERSION',
  'arg', 'assert',
  'collectgarbage', 'coroutine',
  'debug', 'dofile',
  'error',
  'getmetatable',
  'io', 'ipairs',
  'load', 'loadfile', 'loadstring',
  'math', 'module',
  'next',
  'os',
  'package', 'pairs', 'pcall', 'print',
  'rawequal', 'rawget', 'rawlen', 'rawset', 'require',
  'select', 'setmetatable', 'string',
  'table', 'tonumber', 'tostring', 'type',
  'unpack',
  'xpcall',
  -- 5.1
  'gcinfo', 'getfenv', 'setfenv',
  -- 5.2
  'bit32',
  -- 5.3
  'utf8',
  -- LJ 2.1
  'bit', 'jit', 'newproxy',
  -- MAD
  '_M', 'MAD', 'MADX',
  'help', 'show',
}
for i,v in ipairs(_G_env) do _G_env[v] = i end

local function check_G (extra)
  extra = extra or {}
  for k,v in pairs(_G) do
    if not (_G_env[k] or extra[k]) then
      io.write("unexpected global variable: ",
               tostring(k), ' -> ', tostring(v), '\n')
    end
  end
end

-- check _M pollution ---------------------------------------------------------o

local _M_env = {
  '_C', 'MAD', 'MADX', 'check_globals',
  'atexit',
  'beam',
  'cdamap', 'cmatrix', 'cofind', 'command', 'complex', 'constant', 'ctpsa', 'cvector',
  'damap', 'dynmap',
  'element', 'env', 'export',
  'filesys', 'fun',
  'geomap', 'gfunc', 'gmath', 'gphys', 'gplot', 'gtpsad',
  'help',
  'import',
  'linspace', 'logrange', 'logspace',
  'matrix', 'monomial', 'mtable',
  'nlogrange', 'nrange',
  'object', 'operator', 'option',
  'plot',
  'range', 'regex',
  'sequence', 'show', 'strict', 'survey', 'symint',
  'toboolean', 'tocomplex', 'torange', 'tostring', 'totable',
  'tpsa', 'trace', 'track', 'twiss', 'typeid',
  'unstrict', 'utest', 'utility',
  'vector',
  'warn',
  [_hlp] = true, [_final] = true,
}
for i,v in ipairs(_M_env) do _M_env[v] = i end

local function check_M ()
  for k,v in pairs(_M) do
    if not _M_env[k] then
      io.write("unexpected MAD variable: ",
               tostring(k), ' -> ', tostring(v), '\n')
    end
  end
end

M.check_globals = \extra => check_G(extra) ; check_M() end

-- execute after loading MAD env
M.check_globals()

-- end ------------------------------------------------------------------------o
