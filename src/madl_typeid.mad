--[=[
 o-----------------------------------------------------------------------------o
 |
 | Generic type identification module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide a set of function to identify types
  - Includes duck typing checks (i.e. concept checks)

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

-- Note: this module is used by MAD env, hence it cannot rely on MAD env.

-- load 'new' and 'clear' in table (side effect)
require 'table.new'
require 'table.clear'

local ffi = require 'ffi'
local bit = require 'bit'

local band, rol       in bit
local typeof, miscmap in ffi
local abs, huge       in math  -- math.huge is infinity

local type, getmetatable, tostring = type, getmetatable, tostring

-- implementation -------------------------------------------------------------o

assert(miscmap, "missing MAD extension (no cdata metatable access)")

--[[
Metamethods notes:
------------------
 - list of metanames from lj_obj.h, augmented with
   copy + exec + init + same + totable
 - API extended to retrieve metatables of cdata for concepts checks.
]]

local metaname = {
  '__add', '__call', '__concat', '__copy', '__div', '__eq', '__exec', '__gc',
  '__index', '__init', '__ipairs', '__le', '__len', '__lt', '__metatable',
  '__mod', '__mode', '__mul', '__new', '__newindex', '__pairs', '__pow',
  '__same', '__sub', '__tostring', '__totable', '__unm',
}
for _,v in ipairs(metaname) do metaname[v] = v end -- build dict of metaname

local function invalid_use (a)
  error("invalid use of object <" .. tostring(a) .. ">", 2)
end

local function get_metatable (a)
  return type(a) == 'cdata' and (a.__metatable or miscmap[-tonumber(typeof(a))])
         or getmetatable(a)
end

local function has_metatable (a)
  return not not get_metatable(a)
end

local function get_metamethod (a, f)
  local mt = get_metatable(a)
  return mt and rawget(mt,f)
end

local function has_metamethod (a, f)
  local mt = get_metatable(a)
  local mm = mt and rawget(mt,f)
  return not not mm and mm ~= invalid_use
end

-- can be used for events defined after newindex in concept list
local function has_metamethod_ (a, f)
  local mt = get_metatable(a)
  local mm = mt and rawget(mt,f)
  return not not mm -- false or nil -> false
end

--[[
Concept notes:
--------------
- not_indexable prevents to read at keys *not already defined*.
- not_scannable prevents all forms of scan (index and {i,k,_}pairs).
- not_extendable prevents to write at keys *not already defined*.
- not_mutable sets the metatable __metatable to itself and not_extendable.
- default is set to invalid_use up to newindex, and to nil after.
]]

local concept = {                             --     1,        2,       4
  not_lengthable   = 2^0,         '__len',    -- __len,         ,
  not_iterable     = 2^1,         '__ipairs', --      , __ipairs,
  not_mappable     = 2^1+2^2,     '__pairs',  --      , __ipairs, __pairs
  not_scannable    = 2^0+2^1+2^2,             -- __len, __ipairs, __pairs
  not_indexable    = 2^3,         '__index',
  not_extendable   = 2^4,         '__newindex',

  not_callable     = 2^5,         '__call',   -- from here, default is nil
  not_orderable    = 2^6+2^7,     '__lt', '__le',
  not_comparable   = 2^6+2^7+2^8, '__eq',     -- __lt, __le, __eq
  not_concatenable = 2^9,         '__concat',
  not_copiable     = 2^10+2^11,   '__copy', '__same',
  not_tablable     = 2^12,        '__totable',
  not_stringable   = 2^13,        '__tostring',
  not_mutable      = 2^14,        '__metatable',
}
for _,v in ipairs(concept) do -- build dict of concepts
  concept[v] = invalid_use
  if v == '__newindex' then break end -- nil is enough after __newindex
end

local not_iterable, not_mappable, not_mutable in concept

local function set_concept (mt, cncpt, strict_)
  local mt = mt or {}
  assert(mt.__metatable == nil, "invalid argument #1 (mutable metatable expected)")
  for i,v in ipairs(concept) do
    if band(cncpt, rol(1, i-1)) ~= 0 and (mt[v] == nil or strict_ == false) then
      mt[v] = concept[v]
    end
  end
  if band(cncpt, not_mappable) ~= 0 and mt.__ipairs ~= nil then
    mt.__pairs = mt.__ipairs -- pairs is a superset of ipairs
  end
  if band(cncpt, not_mutable) ~= 0 then
    mt.__metatable = mt
    setmetatable(mt, {__newindex=invalid_use, __metatable=false})
  end
  return mt
end

--[[
Classification of primitive types:
----------------------------------
- nil  : can be shared, cannot be modified (but may contain shared states).
- true : can be copied, cannot be modified.
- false: can be shared, can be modified.
]]

local typeclass = {
  -- false
  table = false, lightuserdata = false, userdata = false, cdata = false,
  -- true
  ['nil'] = true,  boolean = true, number = true, string = true,
  -- nil
  ['function'] = nil, thread = nil,
}

-- typeid ---------------------------------------------------------------------o

local typeid = {
  -- primitive types

  is_nil         = \a -> type(a) == 'nil',
  is_boolean     = \a -> type(a) == 'boolean',
  is_number      = \a -> type(a) == 'number',
  is_string      = \a -> type(a) == 'string',
  is_function    = \a -> type(a) == 'function',
  is_table       = \a -> type(a) == 'table',
  is_userdata    = \a -> type(a) == 'userdata',
  is_coroutine   = \a -> type(a) == 'thread',
  is_cdata       = \a -> type(a) == 'cdata',

  -- specialisations

  is_true        = \a -> rawequal(a, true ),
  is_false       = \a -> rawequal(a, false),

  is_nan         = \a -> type(a) == 'number' and a ~= a,
  is_finite      = \a -> type(a) == 'number' and abs(a) <  huge,
  is_infinite    = \a -> type(a) == 'number' and abs(a) == huge,
  is_positive    = \a -> type(a) == 'number' and a > 0,
  is_negative    = \a -> type(a) == 'number' and a < 0,
  is_decimal     = \a -> type(a) == 'number' and (a < -2^52 or  a >  2^52 or  (a%1) ~= 0),
  is_integer     = \a -> type(a) == 'number' and a >= -2^52 and a <= 2^52 and (a%1) == 0,
  is_even        = \a -> type(a) == 'number' and a >= -2^52 and a <= 2^52 and (a%2) == 0,
  is_odd         = \a -> type(a) == 'number' and a >= -2^52 and a <= 2^52 and (a%2) == 1,

  is_emptystring = \a -> type(a) == 'string' and a == '',

  is_rawtable    = \a -> type(a) == 'table'  and rawequal(getmetatable(a),nil),
  is_emptytable  = \a -> type(a) == 'table'  and rawequal(next        (a),nil),

  is_file        = \a -> io.type(a) ~= nil,
  is_emptyfile   = \a -> io.type(a) ~= nil   and a:seek('end') == 0,

  is_value       = \a -> typeclass[type(a)],

  is_metaname    = \a -> metaname[a] == a,

  -- metamethods

  get_metatable  = get_metatable,
  has_metatable  = has_metatable,
  get_metamethod = get_metamethod,
  has_metamethod = has_metamethod,
  set_concept    = set_concept,

  -- concepts

  is_lengthable   = \a -> type(a) == 'string'   or
                          type(a) == 'table'    or has_metamethod (a,'__len'),
  is_iterable     = \a -> type(a) == 'table'    or has_metamethod (a,'__ipairs'),
  is_mappable     = \a -> type(a) == 'table'    or has_metamethod (a,'__pairs'),
  is_indexable    = \a -> type(a) == 'table'    or has_metamethod (a,'__index'),
  is_extendable   = \a -> type(a) == 'table'    or has_metamethod (a,'__newindex'),

  is_callable     = \a -> type(a) == 'function' or has_metamethod_(a,'__call'),
  is_orderable    = \a -> type(a) == 'number'   or
                          type(a) == 'string'   or has_metamethod_(a,'__lt'),
  is_comparable   = \a -> type(a) == 'number'   or
                          type(a) == 'string'   or has_metamethod_(a,'__eq'),
  is_concatenable = \a -> type(a) == 'string'   or has_metamethod_(a,'__concat'),
  is_copiable     = \a ->                          has_metamethod_(a,'__copy'),
  is_sameable     = \a ->                          has_metamethod_(a,'__same'),
  is_tablable     = \a ->                          has_metamethod_(a,'__totable'),
  is_stringable   = \a ->                          has_metamethod_(a,'__tostring'),
  is_mutable      = \a ->                          has_metamethod_(a,'__metametable'),

  -- concepts for numeric

  is_negatable    = \a -> type(a) == 'number'   or has_metamethod_(a,'__unm'),
  is_addable      = \a -> type(a) == 'number'   or has_metamethod_(a,'__add'),
  is_subtractable = \a -> type(a) == 'number'   or has_metamethod_(a,'__sub'),
  is_multipliable = \a -> type(a) == 'number'   or has_metamethod_(a,'__mul'),
  is_dividable    = \a -> type(a) == 'number'   or has_metamethod_(a,'__div'),
  is_modulable    = \a -> type(a) == 'number'   or has_metamethod_(a,'__mod'),
  is_powerable    = \a -> type(a) == 'number'   or has_metamethod_(a,'__pow'),

  -- concepts for containers

  is_empty        = \a -> has_metamethod(a,'__pairs') and
                 rawequal(get_metamethod(a,'__pairs')(a),nil)
              or type(a) == 'table' and rawequal(next(a),nil),

  -- comparison of types

  is_same = \a,b -> type(a) == type(b) and get_metatable(a) == get_metatable(b),

  -- members

  has_member = \a,b -> ((has_metamethod(a,'__index') or type(a) == 'table') and
                                                     not rawequal(a[b], nil)),
  -- methods = callable members

  has_method = \a,b -> ((has_metamethod(a,'__index') or type(a) == 'table') and
                  (type(a[b]) == 'function' or has_metamethod_(a[b],'__call'))),
}

-- protection -----------------------------------------------------------------o

--[[
Write protection:
-----------------
  Protect an object against modification:
  - wprotect  : protect against writing
  - wrestrict : protect against writing into existing keys
  - wunprotect: remove protection, i.e. return orignal object
]]

local mm_msg = \k,s -> "invalid write access to "..k.." object <"..s..">"
local mm_err = \s   -> error(mm_msg("restricted", tostring(s)), 2)
local mm_erp = \s   -> error(mm_msg("protected" , tostring(s)), 2)
local mm_obj = {}
local mm_fun = { -- default for concepts up to newindex
  __index    = \s -> s,
  __len      = \s -> \_ -> #s,
  __ipairs   = \s -> \_ -> ipairs(s),
  __pairs    = \s -> \_ ->  pairs(s),
  __newindex = \s -> \_,k,v =>
      if rawequal(s[k],nil) then s[k] = v else mm_err(s) end
    end
}

local is_table in typeid

local function wrestrict (a)
  assert(typeclass[type(a)] == false,"invalid argument #1 (non-value expected)")
  assert(not rawequal(a,_G), "_G cannot be protected against update (see strict)")

  local amt, omt = get_metatable(a) or {}, table.new(0,8)

  for _,k in ipairs(metaname) do
    if not amt[k] then
      omt[k] = mm_fun[k] and mm_fun[k](a) -- capture and forward to default
    elseif amt[k] ~= invalid_use then
      omt[k] = \_,... -> amt[k](a,...)    -- capture and forward to original
    else
      omt[k] = invalid_use                -- blocked
    end
  end
  omt[mm_obj] = \-> a                     -- capture object
  omt.__metatable = omt                   -- protect metatable
  setmetatable(omt, {__newindex=invalid_use, __metatable=false})
  return setmetatable({}, omt)
end

local function wprotect (a)
  assert(not rawequal(a,_G), "_G cannot be protected against update (see strict)")
  local obj = wrestrict(a)
  getmetatable(obj).__newindex = mm_erp   -- error for protected object
  return obj
end

local function wunprotect (a)
  local amt = getmetatable(a)
  return assert(amt and amt[mm_obj] and amt[mm_obj](),
                "invalid argument #1 (protected object expected)")
end

-- env ------------------------------------------------------------------------o

setmetatable(typeid   , {__tostring := "MAD.typeid"   })
setmetatable(concept  , {__tostring := "MAD.concept"  })
setmetatable(typeclass, {__tostring := "MAD.typeclass"})

typeid            = wrestrict(typeid   ) -- extendable
typeid.concept    = wprotect (concept  ) -- readonly
typeid.typeclass  = wrestrict(typeclass) -- extendable

typeid.wprotect   = wprotect
typeid.wrestrict  = wrestrict
typeid.wunprotect = wunprotect

-- end ------------------------------------------------------------------------o
return {
  typeid = typeid,
  -- __help = require 'madh_typeid',
}
