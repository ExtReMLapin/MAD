--[=[
 o-----------------------------------------------------------------------------o
 |
 | Generic math module
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Extends math module and provides object-oriented dispatch to math functions.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local ffi = require 'ffi'
local complex = ffi.typeof 'complex'

local _C, option in MAD
local second                                                in MAD.gfunc
local is_nil, is_number, wrestrict, set_concept, concept    in MAD.typeid
local not_mappable, not_extendable, not_mutable             in concept

local abs, acos, asin, atan, atan2, ceil, cos, cosh, deg, exp, floor, fmod,
      frexp, ldexp, log, log10, max, min, modf, pow, rad, random,
      randomseed, sin, sinh, sqrt, tan, tanh, pi in math

-- t={}; for k in pairs(math) do t[#t+1]=k end;
-- table.sort(t); print(table.concat(t,', '))

-- number metatable -----------------------------------------------------------o

assert(is_nil(getmetatable(0)), "metatable for number type is already set")

debug.setmetatable(0, {
  __index = {
    emul = \x,y,r_ -> y.__emul(x,y,r_),
    ediv = \x,y,r_ -> y.__ediv(x,y,r_),
    emod = \x,y,r_ -> y.__emod(x,y,r_),
    epow = \x,y,r_ -> y.__epow(x,y,r_),
  },
})

-- implementation -------------------------------------------------------------o

local gmath = {

  -- generic operators
  unm    = \x   ->  -x,
  sqr    = \x   -> x * x,
  add    = \x,y -> x + y,
  sub    = \x,y -> x - y,
  mul    = \x,y -> x * y,
  div    = \x,y -> x / y,
  mod    = \x,y -> x % y,
  pow    = \x,y -> x ^ y,
  emul   = \x,y -> x:emul(y), -- .*
  ediv   = \x,y -> x:ediv(y), -- ./
  emod   = \x,y -> x:emod(y), -- .%
  epow   = \x,y -> x:epow(y), -- .^

  -- generic functions
  angle = \x,y -> is_number(x) and atan2(y,x) or x:angle(y),

  ceil  = \x -> is_number(x) and ceil (x)        or x:ceil (),
  floor = \x -> is_number(x) and floor(x)        or x:floor(),
  frac  = \x -> is_number(x) and second(modf(x)) or x:frac (),
  trunc = \x -> is_number(x) and modf(x)         or x:trunc(),
  round = \x -> is_number(x) and (x>0 and floor(x+0.5) or x<0 and ceil(x-0.5) or x) or x:round(),

  abs   = \x -> is_number(x) and abs     (x)   or x:abs  (),
  sqrt  = \x -> is_number(x) and sqrt    (x)   or x:sqrt (),
  exp   = \x -> is_number(x) and exp     (x)   or x:exp  (),
  log   = \x -> is_number(x) and log     (x)   or x:log  (),
  log10 = \x -> is_number(x) and log10   (x)   or x:log10(),

  sin   = \x -> is_number(x) and sin     (x)   or x:sin  (),
  cos   = \x -> is_number(x) and cos     (x)   or x:cos  (),
  tan   = \x -> is_number(x) and tan     (x)   or x:tan  (),
  cot   = \x -> is_number(x) and 1/tan   (x)   or x:cot  (),
  sinh  = \x -> is_number(x) and sinh    (x)   or x:sinh (),
  cosh  = \x -> is_number(x) and cosh    (x)   or x:cosh (),
  tanh  = \x -> is_number(x) and tanh    (x)   or x:tanh (),
  coth  = \x -> is_number(x) and 1/tanh  (x)   or x:coth (),
  asin  = \x -> is_number(x) and asin    (x)   or x:asin (),
  acos  = \x -> is_number(x) and acos    (x)   or x:acos (),
  atan  = \x -> is_number(x) and atan    (x)   or x:atan (),
  acot  = \x -> is_number(x) and atan  (1/x)   or x:acot (),
  asinh = \x -> is_number(x) and _C.asinh(x)   or x:asinh(),
  acosh = \x -> is_number(x) and _C.acosh(x)   or x:acosh(),
  atanh = \x -> is_number(x) and _C.atanh(x)   or x:atanh(),
  acoth = \x -> is_number(x) and _C.atanh(1/x) or x:acoth(),

  sinc  = \x -> is_number(x) and (abs(x)<1e-10 and 1 or sin(x)/x) or x:sinc(),

  erf   = \x,tol -> is_number(x) and _C.mad_num_erf (x) or x:erf (tol),
  erfc  = \x,tol -> is_number(x) and _C.mad_num_erfc(x) or x:erfc(tol),

  tgamma= \x,tol -> is_number(x) and _C.tgamma(x) or x:tgamma(tol),
  lgamma= \x,tol -> is_number(x) and _C.lgamma(x) or x:lgamma(tol),

  -- complex generic functions
  carg  = \x -> is_number(x) and (x>=0 and 0 or x<0 and pi or x) or x:carg(),
  real  = \x -> is_number(x) and x                               or x:real(),
  imag  = \x -> is_number(x) and 0                               or x:imag(),
  conj  = \x -> is_number(x) and x                               or x:conj(),
  proj  = \x -> is_number(x) and (x+0i):proj()                   or x:proj(),
  rect  = \x -> is_number(x) and x                               or x:rect(),
  polar = \x -> is_number(x) and abs(x)+(x>=0 and 0 or x<0 and pi or x)*1i or x:polar(),

  -- non-generic functions
  hypot  = _C.hypot,
  atan2  = atan2,
  ldexp  = ldexp,
  frexp  = frexp,
  fpow   = pow,
  fmod   = fmod,
  modf   = modf,
  max    = max,
  min    = min,
  deg    = deg,
  rad    = rad,

  sign   = \x -> x>=0 and 1 or x<0 and -1 or x,
  step   = \x -> x>=0 and 1 or x<0 and  0 or x,

  hypot3 = \x,y,z -> _C.hypot(_C.hypot(x,y),z),

  deg2rad = \x -> x*pi/180,
  rad2deg = \x -> x*180/pi,

  -- default uniform RNG
  random     = random,
  randomseed = randomseed,
}

do
  local abs, sinc in gmath

  gmath.cord2arc = \l,a -> l / sinc(0.5*a)
  gmath.arc2cord = \l,a -> l * sinc(0.5*a)

  gmath.sumsqr = \x,y -> x + y*y
  gmath.sumabs = \x,y -> x + abs(y)
  gmath.minabs = \x,y -> min(x,abs(y))
  gmath.maxabs = \x,y -> max(x,abs(y))
end

-- random number generators ---------------------------------------------------o

local is_nan in MAD.typeid
local nan    in MAD.constant
local istype in ffi

-- MAD XorShift1024* (improved Marsagliaâ€™s xorshift generator). -- see mad_num.c
-- generates 64 pseudo-random bits in [0,ULLONG_MAX].
-- generates 52 pseudo-random bits in [0,1).
-- support 2^512 jumps by 2^512 to create independent streams.
-- period is 2^1024 for a single stream, and 2^512 for multiple streams.

ffi.cdef [[
struct rng_state {
  u64_t s[16];
  int   p, id;
  num_t x;
};
]]

local    randgen = ffi.typeof 'rng_state_t'
local is_randgen = \a -> istype(randgen, a)

local randseed = \r,x  => _C.mad_num_randseed(r, x or 0); r.x=nan; return r end
local randjump = \r,r_ => _C.mad_num_randjump(r, r_)    ; r.x=nan; return r end

local gref = randseed(ffi.new 'rng_state_t') -- reference stream
local grng = randseed(ffi.new 'rng_state_t') -- global generator

local function randnewgen ()
  local rng = ffi.new 'rng_state_t'
  rng.id = gref.id + 1
  ffi.copy(gref, randjump(rng, gref), ffi.sizeof 'rng_state_t')
  return rng
end

local function randsetgen (rng)
  assert(is_randgen(rng), "invalid argument #1 (randgen expected)")
  grng, rng = rng, grng
  return rng
end

local function rand (rng)
  assert(is_randgen(rng), "invalid argument #1 (randgen expected)")
  return _C.mad_num_rand(rng)
end

local function randi (rng)
  assert(is_randgen(rng), "invalid argument #1 (randgen expected)")
  return _C.mad_num_randi(rng)
end

-- Box-Muller transformation (Marsaglia's polar form)
-- generates pseudo-random gaussian numbers (pairs of, cached)
local function randn (rng)
  assert(is_randgen(rng), "invalid argument #1 (randgen expected)")
  local x1, x2, w
  if not is_nan(rng.x) then
    x1, rng.x = rng.x, nan
    return x1
  end
  repeat
    x1 = 2*rand(rng) - 1
    x2 = 2*rand(rng) - 1
    w = x1*x1 + x2*x2
  until w < 1
  w = sqrt( -2 * log(w) / w )
  rng.x = x2*w
  return x1*w
end

-- Truncated normal distribution (TODO: use direct formula for cut < ~0.7)
local function randtn (rng, cut_)
  if is_nil(cut_) then return randn(rng) end
  assert(is_randgen(rng), "invalid argument #1 (randgen expected)")
  assert(is_number(cut_), "invalid argument #2 (number expected)")
  local c, r = abs(cut_)
  repeat r = randn(rng) until abs(r) <= c
  return r
end

-- Inverse transform sampling (for 'small' lamdba in O(lambda))
-- Discrete Univariate Distributions, L. Devroye, p505
local function randp (rng, lmb_)
  local lmb = lmb_ or 1
  assert(is_randgen(rng), "invalid argument #1 (randgen expected)")
  assert(is_number(lmb) and lmb > 0 and lmb < 30,
                          "invalid argument #2 (0 < lambda < 30 expected)")
  local x, p = 0, exp(-lmb)
  local s, u = p, rand(rng)
  while u > s do
    x = x + 1
    p = p * lmb/x
    s = s + p
  end
  return x
end

-- RNG as an infinite stream
local function iter (rng, i)
  return i+1, rng:rand()
end

local rng_mt = set_concept({
  __index = {
    rand     = rand,
    randi    = randi,
    randn    = randn,
    randp    = randp,
    randtn   = randtn,
    randseed = randseed,
  },
  __ipairs   = \r -> (iter, r, 0),
  __tostring = \r -> string.format("RNG: %p", r),
}, not_mappable + not_extendable + not_mutable)

ffi.metatype('rng_state_t', rng_mt)

-- gmath ----------------------------------------------------------------------o

gmath.is_randgen = is_randgen
gmath.randnewgen = randnewgen
gmath.randsetgen = randsetgen

gmath.rand     = \     -> grng:rand    ()
gmath.randi    = \     -> grng:randi   ()
gmath.randn    = \     -> grng:randn   ()
gmath.randp    = \lmb_ -> grng:randp   (lmb_)
gmath.randtn   = \cut_ -> grng:randtn  (cut_)
gmath.randseed = \seed -> grng:randseed(seed)

-- env ------------------------------------------------------------------------o

MAD.typeid.is_randgen = gmath.is_randgen

gmath = wrestrict(setmetatable(gmath, {__tostring := "MAD.gmath"}))

-- end ------------------------------------------------------------------------o
return {
  gmath  = gmath,
  -- __help = require 'madh_gmath',
}
