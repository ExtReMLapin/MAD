--[=[
 o-----------------------------------------------------------------------------o
 |
 | Survey tests
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the survey module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local assertNotNil, assertEquals, assertAlmostEquals, assertAllAlmostEquals,
      assertStrContains, assertErrorMsgContains in MAD.utest

local survey, option, filesys in MAD
local eps                     in MAD.constant

local toolbox = require 'toolbox'

local refdir = \s -> 'survey_ref/'..s
local rundir = \s -> 'survey_run/'..s

-- regression test suite ------------------------------------------------------o

TestSurvey = {}

local function loadLHC()
  return toolbox.loadLHC()
end

function TestSurvey:setUp ()
  filesys.mkdir(rundir(''))
  self.optfmt = option.format
  option.format = "%-.10g"
end

function TestSurvey:tearDown ()
  option.format = self.optfmt
  if MADX:is_open_env() == true then
    MADX:reset_env()
  end
end

function TestSurvey:testSurveyLHC1()
  local lhcb1 = loadLHC()
  local mtbl = survey { sequence=lhcb1 }
  assertEquals(#mtbl, 13269)
  mtbl:write(rundir('survey_lhcb1'))
end

function TestSurvey:testSurveyLHC2()
  local _, lhcb2 = loadLHC()
  local mtbl = survey { sequence=lhcb2 }
  assertEquals(#mtbl, 13267)
  mtbl:write(rundir('survey_lhcb2'))
end

local function atslice (elm, mflw, lw, si)
  if si == 1 then mflw.fill(elm, mflw, 1) end
end

function TestSurvey:testSurveySlicedLHC1()
  local lhcb1 = loadLHC()
  local mtbl = survey { sequence=lhcb1,
                        nslice=2, atslice=atslice, nofill=true }
  assertEquals(#mtbl, 13192)
  mtbl:write(rundir('survey_lhcb1_slice'))
end

function TestSurvey:testSurveySlicedLHC2()
  local _, lhcb2 = loadLHC()
  local mtbl = survey { sequence=lhcb2,
                        nslice=2, atslice=atslice, implicit=false, nofill=true }
  assertEquals(#mtbl, 6599)
  mtbl:write(rundir('survey_lhcb2_slice'))
end

function TestSurvey:testSurveySlicedBwdLHC1()
  local lhcb1 = loadLHC()
  local mtbl = survey { sequence=lhcb1, sdir=-1,
                        nslice=2, atslice=atslice, nofill=true }
  assertEquals(#mtbl, 13192)
  mtbl:write(rundir('survey_lhcb1_slice_bwd'))
end

function TestSurvey:testSurveySlicedBwdLHC2()
  local _, lhcb2 = loadLHC()
  local mtbl = survey { sequence=lhcb2, sdir=-1,
                        nslice=2, atslice=atslice, implicit=false, nofill=true }
  assertEquals(#mtbl, 6599)
  mtbl:write(rundir('survey_lhcb2_slice_bwd'))
end

function TestSurvey:testSurveyFwdBwdLHC1()
  local lhcb1 = loadLHC()
  local _, mflw = survey { sequence=lhcb1, sdir= 1, save=false }

  local idx, spos, V, A in mflw
  assertEquals(idx, #lhcb1)

  local _, mflw = survey { sequence=lhcb1, sdir=-1, save=false, -- bwd
                           s0=spos, X0=V, A0=A }

  local idx, spos, V, A in mflw
  assertEquals         ( idx , 1 )
  assertAlmostEquals   ( spos, 0 )
  assertAllAlmostEquals( V:totable(), 0, 1e-9  )
  assertAllAlmostEquals( A:totable(), 0, 1e-14 )
end

function TestSurvey:testSurveyFwdBwdLHC2()
  local _, lhcb2 = loadLHC()
  local _, mflw = survey { sequence=lhcb2, sdir= 1, save=false }

  local idx, spos, V, A in mflw
  assertEquals(idx, #lhcb2)

  local _, mflw = survey { sequence=lhcb2, sdir=-1, save=false, -- bwd
                           s0=spos, X0=V, A0=A }

  local idx, spos, V, A in mflw
  assertEquals         ( idx , 1 )
  assertAlmostEquals   ( spos, 0 )
  assertAllAlmostEquals( V:totable(), 0, 1e-9  )
  assertAllAlmostEquals( A:totable(), 0, 1e-14 )
end

function TestSurvey:testSurveyIterLHC1()
  local lhcb1 = loadLHC()
  local mtbl, mflw, elm = survey { sequence=lhcb1, nstep=0 }
  repeat
    mtbl, mflw, elm = survey { mflow=mflw, nstep=1 }
  until not elm
  assertEquals(#mtbl, 13269)
  mtbl:write(rundir('survey_lhcb1_iter'))
end

function TestSurvey:testSurveyIterLHC2()
  local _, lhcb2 = loadLHC()
  local mtbl, mflw, elm = survey { sequence=lhcb2, nstep=0 }
  repeat
    mtbl, mflw, elm = survey { mflow=mflw, nstep=1 }
  until not elm
  assertEquals(#mtbl, 13267)
  mtbl:write(rundir('survey_lhcb2_iter'))
 end

function TestSurvey:testSurveyFullRangeIterLHC1()
  local lhcb1 = loadLHC()
  local mtbl, mflw, elm = survey { sequence=lhcb1, range='#s/#e', nstep=0 }
  repeat
    mtbl, mflw, elm = survey { mflow=mflw, nstep=1 }
  until not elm
  mtbl:write(rundir('survey_lhcb1_range_iter'))
end

function TestSurvey:testSurveyRangeIterLHC1()
  local lhcb1 = loadLHC()
  local mtbl, mflw, elm = survey { sequence=lhcb1, range='IP2/IP3', nstep=0 }
  repeat
    mtbl, mflw, elm = survey { mflow=mflw, nstep=1 }
  until not elm
  mtbl:write(rundir('survey_lhcb1_range_iter'))
end

function TestSurvey:testSurveyRangeIterLHC2()
  local _, lhcb2 = loadLHC()
  local mtbl, mflw, elm = survey { sequence=lhcb2, range='IP2/IP3', nstep=0 }
  repeat
    mtbl, mflw, elm = survey { mflow=mflw, nstep=1 }
  until not elm
  mtbl:write(rundir('survey_lhcb2_range_iter'))
end

function TestSurvey:testSurveyRangeLHC1()
  local lhcb1 = loadLHC()
  local mtbl = survey { sequence=lhcb1, range={'IP2','IP3'} }
  mtbl:write(rundir('survey_lhcb1_range'))
end

function TestSurvey:testSurveyRangeLHC2()
   local _, lhcb2 = loadLHC()
 local mtbl = survey { sequence=lhcb2, range={'IP2','IP3'} }
  mtbl:write(rundir('survey_lhcb2_range'))
end

function TestSurvey:testSurveyRangeSetLHC1()
  local lhcb1 = loadLHC()
  local survey_ip23 = survey { sequence=lhcb1, range={'IP2','IP3'}, exec=false }
  lhcb1:setv { survey_ip23 := survey_ip23 {} }
  local mtbl = lhcb1.survey_ip23
  mtbl:write(rundir('survey_lhcb1_range_method'))
  lhcb1:setv { survey_ip23 = nil }
end

function TestSurvey:testSurveyRangeSetLHC2()
  local _, lhcb2 = loadLHC()
  local survey_ip23 = survey { sequence=lhcb2, range={'IP2','IP3'}, exec=false }
  lhcb2:setv { survey_ip23 := survey_ip23 {} }
  local mtbl = lhcb2.survey_ip23
  mtbl:write(rundir('survey_lhcb2_range_method'))
  lhcb2:setv { survey_ip23 = nil }
end

-- From Irina's code

function TestSurvey:testFODO()
  local drift, marker, quadrupole, sequence in MAD.element
  local lcell  = 20
  local lquad  = 5

  local kqf  =  1.4631475E-02
  local kqd  = -1.4643443E-02

  local ip   = marker 'ip' {}
  local qf   = quadrupole 'qf' { l = lquad, k1 := kqf, tilt = 4e-6 }
  local qd   = quadrupole 'qd' { l = lquad, k1 := kdf }

  local seq = sequence 'fodo1' { l = lcell, refer = 'entry',
    ip 'IP1' { at = 0 },
    qf 'QF1' { at = 0 },
    qd 'QD1' { at = 15 },
    ip 'IP2' { at = lcell },
  }
  assertEquals(seq.dir, 1)

  local actual, expected, margin

  local mtbl = survey { sequence=seq, X0={-1e-4, 2e-6, 0}, A0={0, 0, 3e-7} }
--check quad 'QF1'
  actual   = { mtbl.QF1.angle, mtbl.QF1.tilt, mtbl.QF1.x, mtbl.QF1.y, mtbl.QF1.z, mtbl.QF1.theta, mtbl.QF1.phi, mtbl.QF1.psi, mtbl.QF1.globaltilt }
  expected = { 0               , 4e-6            , -1e-4       , 2e-6        , 5           , 0               , 0             , 3e-7          , 4.3e-6}
  margin   = { 0               , 0               , 1e-15       , 1e-15       , 0           , 0               , 0             , 0             , 1e-21}
  assertAllAlmostEquals (actual, expected, margin)
--check the whole cell
  actual   = { mtbl.angle[#mtbl], mtbl.tilt [#mtbl], mtbl.x[#mtbl], mtbl.y[#mtbl], mtbl.z[#mtbl], mtbl.theta[#mtbl], mtbl.phi[#mtbl], mtbl.psi[#mtbl], mtbl.globaltilt[#mtbl]}
  expected = { 0              , 0              , -1e-4      , 2e-6       , lcell      , 0              , 0            , 3e-7         , 3e-7}
  margin   = { 0              , 0              , 1e-15      , 1e-15      , 0          , 0              , 0            , 0            , 0}
  assertAllAlmostEquals (actual, expected, margin)
end

function TestSurvey:testFODODir()
  local drift, marker, quadrupole, sequence  in MAD.element
  local lcell  = 20
  local lquad  = 5

  local ip   = marker 'ip' {}
  local kqf  =  1.4631475E-02
  local kqd  = -1.4643443E-02
  local qf   = quadrupole 'qf'{ l=lquad, k1:= kqf, tilt=0.3}
  local qd   = quadrupole 'qd'{ l=lquad, k1:= kdf }

  local seq = sequence 'fodo1' {l = lcell, refer = 'entry',
    ip 'IP1' { at = 0     },
    qf 'QF1' { at = 0},
    qd 'QD1' { at = 15},
    ip 'IP2' { at = lcell },
  }
  assertEquals(seq.dir, 1)

  local mtbl = survey { sequence=seq, X0={0, 0, 0}, A0={0, 0, 0}}

  option.format = "%-18.16g"
  mtbl:write(rundir('fodo_p1'))
  seq.dir = -1
  assertEquals(seq.dir, -1)
  option.format = "%-18.16g"
  mtbl:write(rundir('fodo_m1'))
end

function TestSurvey:testFODOPatch()
  local drift, marker, quadrupole, srotation, sequence in MAD.element
  local lcell = 20
  local lquad = 5
  local kqf =  1.4631475E-02
  local kqd = -1.4643443E-02

  local ip = marker 'ip' {}
  local qf = quadrupole 'qf'{ l=lquad, k1:=kqf, tilt=0.3 }
  local qd = quadrupole 'qd'{ l=lquad, k1:=kdf }
  local sr = srotation { tilt=0.03 }
  local seq = sequence 'fodo1' { l=lcell, refer='entry',
    ip 'IP1' { at = 0 },
    sr 'SR1' { at = 0 },
    qf 'QF1' { at = 0 },
    qd 'QD1' { at = 15},
    ip 'IP2' { at = lcell },
  }
  assertEquals(seq.dir, 1)

  local mtbl = survey { sequence=seq, X0={0.01, -0.02, 0}, A0={0, 0, 0}}
  local actual   = { mtbl.angle[#mtbl], mtbl.tilt[#mtbl], mtbl.x[#mtbl], mtbl.y[#mtbl], mtbl.z[#mtbl], mtbl.theta[#mtbl], mtbl.phi[#mtbl], mtbl.psi[#mtbl], mtbl.globaltilt[#mtbl]}
  local expected = { 0              , 0             , 0.01       , -0.02      , lcell      , 0              , 0            , 0            , 0}
  local margin   = { 0              , 0             , 1e-15      , 1e-15      , 0          , 0              , 0            , 0            , 0}
  assertAllAlmostEquals (actual, expected, margin)

--dir =-1
  seq.dir = -1
  assertEquals(seq.dir, -1)
  actual   = { mtbl.angle[#mtbl], mtbl.tilt [#mtbl], mtbl.x[#mtbl], mtbl.y[#mtbl], mtbl.z[#mtbl], mtbl.theta[#mtbl], mtbl.phi[#mtbl], mtbl.psi[#mtbl], mtbl.globaltilt[#mtbl]}
  expected = { 0              , 0              , 0.01       , -0.02      , lcell      , 0              , 0            , 0            , 0}
  margin   = { 0              , 0              , 1e-15      , 1e-15      , 0          , 0              , 0            , 0            , 0}
  assertAllAlmostEquals (actual, expected, margin)
end


function TestSurvey:testSPSLine()
  local pi in math
  local marker, drift, monitor, hkicker, vkicker, multipole,
        sbend, quadrupole,  sextupole, patch, sequence in MAD.element

-- total length
  local circum = 6912.0
-- number of cells and therefore cell length
  local ncell  = 108
  local lcell  = circum/ncell
--lengths of elements and half lengths
  local lsb    = 3.       -- arc length of dipole
  local lquad  = 3.085
  local lquad2 = lquad/2.
  local lsex   = 1.0
--marker
  local ip = marker 'ip' {}
--drift (just to check if it works and gives the same results)
  local dr = drift 'dr' {}
--sbend
--  local asb = 0.010 -- angle
  local asb = 2.0*pi/(8*108)
--  local sb  = sbend 'sb'{ l:=lsb, angle = asb }
  local sb  = multipole 'sb' { knl = {asb} }
--quads
  local kqf =  1.4631475E-02
  local kqd = -1.4643443E-02
  local qf  = quadrupole 'qf' { l=lquad, k1:= kqf }
  local qd  = quadrupole 'qd' { l=lquad, k1:= kdf }
--sextupole
  local ksf =  2.0284442E-02
  local ksd = -3.8394267E-02
  local sf  = sextupole  'sf' {l=lsex,   k2:=ksf }
  local sd  = sextupole  'sd' {l=lsex,   k2:=ksd }
-- orbit correctors and beam position monitors
  local bpm = monitor 'bpm' {l=0.1}
  local ch  = hkicker 'ch'  {l=0.1}
  local cv  = vkicker 'vh'  {l=0.1}
--sequence
  local seq = sequence 'fodo1' {l = lcell, dir =1, refer = 'centre',
      ip  'IP1'  { at = 0            },
      qf  'QF1'  { at = lquad2       },
      sf  'SF1'  { at = lquad2 + 2.5 },
      ch  'CH1'  { at = lquad2 + 3.1 },
      bpm 'BPM1' { at = lquad2 + 3.2 },
      sb  'SB1'  { at = lquad2 + 3.5 },
      sb  'SB2'  { at = lquad2 + 9.9 },
      sb  'SB3'  { at = lquad2 + 22.1},
      sb  'SB4'  { at = lquad2 + 28.5},
      qd  'QD1'  { at = lquad2 + 32. },
      sd  'SD1'  { at = lquad2 + 34.5},
      cv  'CV1'  { at = lquad2 + 35.1},
      bpm 'BPM2' { at = lquad2 + 35.2},
      sb  'SB1'  { at = lquad2 + 35.5},
      sb  'SB2'  { at = lquad2 + 41.9},
      sb  'SB3'  { at = lquad2 + 54.1},
      sb  'SB4'  { at = lquad2 + 60.5},
      ip  'IP2'  { at = lcell        },
  }
  local mtbl = survey { sequence=seq,  X0={0, 0, 0}, A0={0, 0, 0}}
  option.format = "%-18.16g"
  mtbl:write(rundir('sps_cell1'))
  seq.dir = -1

  mtbl = survey { sequence=seq, X0={0, 0, 0}, A0={0, 0, 0}}
  option.format = "%-18.16g"
  mtbl:write(rundir('sps_cell2'))

  local actual   = { mtbl.angle[#mtbl], mtbl.tilt [#mtbl], mtbl.x[#mtbl], mtbl.y[#mtbl], mtbl.z[#mtbl], mtbl.theta[#mtbl], mtbl.phi[#mtbl], mtbl.psi[#mtbl], mtbl.globaltilt[#mtbl]}
  local expected = { 0              , 0              , 0          , 0          , lcell      , 0              , 0            , 0            , 0}
  local margin   = { 0              , 0              , 1e-15      , 1e-15      , 0          , 0              , 0            , 0            , 0}
  assertAllAlmostEquals (actual, expected, margin)
end

-- end ------------------------------------------------------------------------o
