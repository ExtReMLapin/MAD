--[=[
 o-----------------------------------------------------------------------------o
 |
 | MTable tests
 |
 | Methodical Accelerator Design - Copyright CERN 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 |          A. Bloch,  aurelien.bloch at cern.ch
 | Contrib: -
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide regression test suites for the mtable module.

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local toolbox  = require "toolbox"
local assertFalse, assertTrue, assertNil, assertNotNil, assertEquals,
  assertErrorMsgContains, assertAlmostEquals                     in MAD.utest
local mtable, filesys                                            in MAD
local is_vector, is_cvector, is_mtable, is_number                in MAD.typeid
local eps, pi                                                    in MAD.constant
local abs, random, min                                           in MAD.gmath
local tblcpy, strsplitall                                        in MAD.utility
local check_kpairs                                               in toolbox

local generate = false
local refdir   = \s -> "mtable_ref/"..(s or "")
local rundir   = \s -> "mtable_run/"..(s or "")
local _msg     = {
  "invalid write access to readonly mtable",
  "nil reference value",
  "no reference column found",
}

-- helpers --------------------------------------------------------------------o

local function getEmptyTables()
  local tbl1  = mtable "tbl1" { "x", "y", "z" }
  local tbl2  = mtable "tbl2" { {"dict"}, "x", "y", "z" }
  local tbl3  = mtable "tbl3" { "x", "y", "z", {"dict"} }
  return tbl1, tbl2, tbl3
end

local function getRows(i, j)
  local row1, row2, row3
  i = i or 1
  if j then
    row1, row2, row3 = {}, {}, {}
    local s = 1
    for i=i,i+j-1 do
      row1[s] = { i        , -i, pi*i            }
      row2[s] = { 'name'..i, -i, pi*i, i         }
      row3[s] = { i        , -i, pi*i, 'name'..i }
      s = s + 1
    end
  else
    row1 = { i        , -i, pi*i            }
    row2 = { 'name'..i, -i, pi*i, i         }
    row3 = { i        , -i, pi*i, 'name'..i }
  end
  return row1, row2, row3
end

local function getCols(n)
  n = n or 4
  local coli, col2, col3, coldict = {}, {}, {}, {}
  for i=1,n do
    coli[i]    =  i
    col2[i]    = -i
    col3[i]    =  i*pi
    coldict[i] = (i == 2) and "name2" or "name1"
  end
  return coli, col2, col3, coldict
end

local function getIdxTbl()
  local tbl1, tbl2,  tbl3   = getEmptyTables()
  local row11, row21, row31 = getRows(1)
  local row12, row22, row32 = getRows(2)
  local row13, row23, row33 = getRows(3)
  local row14, row24, row34 = getRows(4)
  row21[1] = "name1"; row31[4] = "name1"
  row22[1] = "name2"; row32[4] = "name2"
  row23[1] = "name1"; row33[4] = "name1"
  row24[1] = "name1"; row34[4] = "name1"
  tbl1:addrow(row11); tbl2:addrow(row21); tbl3:addrow(row31)
  tbl1:addrow(row12); tbl2:addrow(row22); tbl3:addrow(row32)
  tbl1:addrow(row13); tbl2:addrow(row23); tbl3:addrow(row33)
  tbl1:addrow(row14); tbl2:addrow(row24); tbl3:addrow(row34)
  return tbl1, tbl2, tbl3
end

local function assertVecEquals (actual, expected)
  for i=1,#expected do
    assertEquals(actual[i], expected[i])
  end
end

local function assertFiles (name)
  if generate then return end
  local ref  = assert(io.open(refdir(name), "r"))
  local run  = assert(io.open(rundir(name), "r"))
  local reftbl, sref = strsplitall(ref:read("*all"), " \n,:;[]")
  local runtbl, srun = strsplitall(run:read("*all"), " \n,:;[]")
  assertEquals(srun, sref)
  for i=1,sref do
    reftbl[i] = tonumber(reftbl[i]) or reftbl[i]
    runtbl[i] = tonumber(runtbl[i]) or runtbl[i]
    if is_number(reftbl[i]) then
      local approx = abs(runtbl[i]-reftbl[i])
      if 14*eps < approx then
        local div = min(runtbl[i], reftbl[i])
        if div == 0 then
          assertAlmostEquals(approx, 0, 1.1e-5)
        else
          assertAlmostEquals((runtbl[i]-reftbl[i])/div, 0, 1.1e-6)
        end
      end
    else
      assertEquals(runtbl[i], reftbl[i])
    end
  end
  if not generate then
    os.remove(rundir(name))
    filesys.rmdir(rundir())
  end
end

local function testWrite(tbl, filname, ...)
  filesys.mkdir(rundir())
  tbl:write(...)
  assertFiles(filname)
end

local function newrow(i)
  return { 'name'..i, i, -i, pi*i }
end

local function newtbl(n)
  local t = mtable { {'name'}, 'x', 'y', 'z' }
  for i=1,n do t = t+newrow(i) end
  return t
end

local function chkrow(tbl, i)
    local x = tbl.x[i]
    assertEquals(tbl.x[i],    x)
    assertEquals(tbl.y[i],   -x)
    assertEquals(tbl.z[i], pi*x)
    assertEquals(tbl[i].name, 'name'..x)
end

local function checktbl(tbl, n)
  assertEquals(#tbl, n)
  for i=1,n do chkrow(tbl, i) end
  tbl:check_index()
end

-- regression test suite ------------------------------------------------------o

TestMTable = {}

function TestMTable:testCtor0()
  local t = newtbl(0)
  -- print() t:write()
  checktbl(t, 0)
end

function TestMTable:testCtor1()
  local t = newtbl(1)
  -- print() t:write()
  checktbl(t, 1)
end

function TestMTable:testCtorN()
  local t = newtbl(10)
  -- print() t:write()
  checktbl(t, 10)
end

function TestMTable:testAddRow0()
  local t = newtbl(0)
  t:addrow(newrow(0))
  -- print() t:write()
  checktbl(t, 1)
end

function TestMTable:testAddRow1()
  local t = newtbl(1)
  t:addrow(newrow(1))
  -- print() t:write()
  checktbl(t, 2)
end

function TestMTable:testAddRowN()
  local t = newtbl(10)
  t:addrow(newrow(11))
  -- print() t:write()
  checktbl(t, 11)
end

function TestMTable:testInsRow1()
  local t = newtbl(1)
  t:insrow('name1', newrow(0))
  -- print() t:write()
  checktbl(t, 2)
end

function TestMTable:testInsRowN()
  local t = newtbl(10)
  t:insrow('name1' , newrow(0))
  t:insrow('name3' , newrow(2.5))
  t:insrow('name10', newrow(9.5))
  -- print() t:write()
  checktbl(t, 13)
end

function TestMTable:testRemRow1()
  local t = newtbl(1)
  t:remrow'name1'
  -- print() t:write()
  checktbl(t, 0)
end

function TestMTable:testRemRowN()
  local t = newtbl(10)
  t:remrow'name1'
  t:remrow'name5'
  t:remrow'name10'
  -- print() t:write()
  checktbl(t, 7)
end

function TestMTable:testRemoveRow0()
  local t = newtbl(0)
  local sel = {name1=1}
  t:remove { select=\r -> sel[r.name] }
  -- print() t:write()
  checktbl(t, 0)
end

function TestMTable:testRemoveRow1()
  local t = newtbl(1)
  local sel = {name1=1}
  t:remove { select=\r -> sel[r.name] }
  -- print() t:write()
  checktbl(t, 0)
end

function TestMTable:testRemoveRowN()
  local t = newtbl(10)
  local sel = {name1=1, name2=1, name5=1, name6=1, name7=1, name9=1,name10=1}
  t:remove { select=\r -> sel[r.name] }
  -- print() t:write()
  checktbl(t, 3)
end

function TestMTable:testRemoveRow1st()
  local t = newtbl(10)
  local sel = {name1=1}
  t:remove { select=\r -> sel[r.name] }
  -- print() t:write()
  checktbl(t, 9)
end

function TestMTable:testRemoveRowNth()
  local t = newtbl(10)
  local sel = {name10=1}
  t:remove { select=\r -> sel[r.name] }
  -- print() t:write()
  checktbl(t, 9)
end

function TestMTable:testNameOf()
  local t = newtbl(10)
  for i=1,5 do t:insrow(5, newrow(5)) end
  -- print() t:write()
  checktbl(t, 15)
  for i=1,2 do assertEquals(t:name_of(4+i, 7), 'name5{'..(i-3)..'}') end
  for i=3,5 do assertEquals(t:name_of(4+i, 7), 'name5{'..(i-2)..'}') end
end

-------------------------------------------------------------------------------o

function TestMTable:testConstructor()
  local tbl1  = mtable "tbl1"  { }
  local tbl2  = mtable "tbl2"  { "x", "y", "z" }
  local tbl3  = mtable "tbl3"  { {"dict"}, "x", "y", "z" }
  local tbl4  = mtable "tbl4"  { "x", "y", "z", {"dict"} }
  local tbl42 = tbl4   "tbl42" { }

  assertEquals(#tbl1,  0)
  assertEquals(#tbl2,  0)
  assertEquals(#tbl3,  0)
  assertEquals(#tbl4,  0)
  assertEquals(#tbl42, 0)

  assertEquals(tbl1.name, "tbl1")
  assertEquals(tbl2.name, "tbl2")
  assertEquals(tbl3.name, "tbl3")
  assertEquals(tbl4.name, "tbl4")
  assertEquals(tbl42.name, "tbl42")

  for _,col in ipairs{"x", "y", "z"} do
    assertNil(tbl1[col])
    assertNotNil(tbl2[col])
    assertNotNil(tbl3[col])
    assertNotNil(tbl4[col])
    assertNotNil(tbl42[col])
  end

  assertNotNil(tbl3.dict)
  assertNotNil(tbl4.dict)
  assertNotNil(tbl42.dict)
end

function TestMTable:testIsMtable()
  local tbl1  = mtable "tbl1"  { }
  local tbl2  = mtable "tbl2"  { "x", "y", "z" }
  local tbl3  = mtable "tbl3"  { {"dict"}, "x", "y", "z" }
  local tbl32 = tbl3   "tbl32" { }
  assertTrue(is_mtable(mtable))
  assertTrue(is_mtable(tbl1))
  assertTrue(is_mtable(tbl2))
  assertTrue(is_mtable(tbl3))
  assertTrue(is_mtable(tbl32))
end

function TestMTable:testIsOwner()
  local tbl1  = mtable "tbl1"  { }
  local tbl2  = mtable "tbl2"  { "x", "y", "z" }
  local tbl3  = mtable "tbl3"  { {"dict"}, "x", "y", "z" }
  local tbl32 = tbl3   "tbl32" { }
  assertTrue(mtable:is_owner())
  assertFalse(tbl1:is_owner())
  assertTrue(tbl2:is_owner())
  assertTrue(tbl3:is_owner())
  assertFalse(tbl32:is_owner())
end

function TestMTable:testIsView()
  local tbl1  = mtable "tbl1"  { }
  local tbl2  = mtable "tbl2"  { "x", "y", "z" }
  local tbl3  = mtable "tbl3"  { {"dict"}, "x", "y", "z" }
  local tbl32 = tbl3   "tbl32" { }
  assertFalse(mtable:is_view())
  assertTrue(tbl1:is_view())
  assertFalse(tbl2:is_view())
  assertFalse(tbl3:is_view())
  assertTrue(tbl32:is_view())
end

function TestMTable:testAddOperator()
  local tbl1, tbl2, tbl3 = getEmptyTables()
  local row1, row2, row3 = getRows()
  local tbl22 = tbl2   "tbl22" { }
  local tbl4  = mtable "tbl4"  { }
  local add = \a,b -> a + b

  tbl1  = tbl1  + row1
  tbl2  = tbl2  + row2
  tbl22 = tbl22 + row2
  tbl3  = tbl3  + row3
  assertErrorMsgContains(_msg[1], add, mtable, row2)
  assertErrorMsgContains(_msg[1], add, tbl4  , row2)

  assertEquals(#tbl1  , 1)
  assertEquals(#tbl2  , 2)
  assertEquals(#tbl3  , 1)
  assertEquals(#tbl4  , 0)
  assertEquals(#tbl22 , 2)
  assertEquals(#mtable, 0)
end

function TestMTable:testAddRow1st()
  local tbl1, tbl2, tbl3 = getEmptyTables()
  local row1, row2, row3 = getRows()
  local tbl22 = tbl2   "tbl22" { }
  local tbl4  = mtable "tbl4"  { }

  tbl1 :addrow(row1)
  tbl2 :addrow(row2)
  tbl22:addrow(row2)
  tbl3 :addrow(row3)
  assertErrorMsgContains(_msg[1], mtable.addrow, mtable, row2)
  assertErrorMsgContains(_msg[1], mtable.addrow, tbl4  , row2)

  assertEquals(#tbl1  , 1)
  assertEquals(#tbl2  , 2)
  assertEquals(#tbl3  , 1)
  assertEquals(#tbl4  , 0)
  assertEquals(#tbl22 , 2)
  assertEquals(#mtable, 0)
end

function TestMTable:testGetSimple()
  local tbl1, tbl2, tbl3 = getEmptyTables()
  local row1, row2, row3 = getRows()
  tbl1:addrow(row1); tbl2:addrow(row2); tbl3:addrow(row3)
  for i,v in ipairs(row1) do assertEquals(tbl1:get(1, i), row1[i]) end
  for i,v in ipairs(row2) do assertEquals(tbl2:get(1, i), row2[i]) end
  for i,v in ipairs(row3) do assertEquals(tbl3:get(1, i), row3[i]) end
end

function TestMTable:testAddRows()
  local tbl1, tbl2, tbl3 = getEmptyTables()
  local tbl22 = tbl2   "tbl22" { }
  for i=1,10 do
    local row1, row2, row3 = getRows(i)
    tbl1:addrow(row1) ; tbl2:addrow(row2) ; tbl3:addrow(row3)
    tbl1:check_index(); tbl2:check_index(); tbl3:check_index()
    tbl22:check_index()
  end
  for i=1,10 do
    local row1, row2, row3 = getRows(i)
    for j=1,3 do assertEquals(tbl1:get(i, j), row1[j]) end
    for j=1,4 do
      assertEquals(tbl2 :get(i, j), row2[j])
      assertEquals(tbl22:get(i, j), row2[j])
      assertEquals(tbl3 :get(i, j), row3[j])
    end
  end
end

function TestMTable:testAddRowNil()
  local tbl1, tbl2, tbl3 = getEmptyTables()

  assertErrorMsgContains(_msg[2], mtable.addrow, tbl2, {  })
  assertErrorMsgContains(_msg[2], mtable.addrow, tbl3, {  })
  tbl2:addrow { "name1", nil, nil, nil     }
  tbl3:addrow {     nil, nil, nil, "name1" }
  assertEquals(#tbl2, 1)
  assertEquals(#tbl3, 1)
  for j=1,3 do
    assertEquals(tbl2:get(1,j+1), nil)
    assertEquals(tbl3:get(1,j  ), nil)
  end
  tbl1:check_index()
  tbl2:check_index()
  tbl3:check_index()
end

function TestMTable:testAddRowsByColName()
  local tbl1, tbl2, tbl3 = getEmptyTables()
  local row1 = { x = 1, y = 2, z = 3         }
  local row2 = { x = 1, y = 2, z = 3, dict = "name"}
  local row3 = { x = 1, y = 2, z = 3, dict = "name"}
  tbl1:addrow(row1)
  tbl2:addrow(row2)
  tbl3:addrow(row3)
  assertEquals(tbl1:getrow(1), { 1     , 2, 3         })
  assertEquals(tbl2:getrow(1), { "name", 1, 2, 3      })
  assertEquals(tbl3:getrow(1), { 1     , 2, 3, "name" })
end

function TestMTable:testAccessPriority()
  local tbl = mtable "tbl" { {"name1"}, "name2", name1 = 42 }
  tbl:addrow{ "name1", 1 }
  tbl:addrow{ "name2", 2 }
  tbl:addrow{ "name3", 3 }

  -- rows idx
  assertEquals(tbl[1], {"name1", 1})
  -- vars
  assertEquals(tbl.name1, 42)
  -- cols
  assertVecEquals(tbl.name2, {1, 2, 3})
  -- rows
  assertEquals(tbl.name3, {"name3", 3})
end

function TestMTable:testAccessInvalid()
  local tbl = mtable "tbl" { {"name1"}, "x" }
  local assign = \tbl,a,b => tbl[a] = b end
  local msg = {
    "invalid mtable write access (use 'set' methods)",
  }
  tbl:addrow{ "name2", 1 }

  assertErrorMsgContains(msg[1], assign, tbl, 1, 42)
  assertErrorMsgContains(msg[1], assign, tbl, "name1", 42)
  assertErrorMsgContains(msg[1], assign, tbl, "name2", 42)
end

function TestMTable:testIndexOfInt()
  local tbl1, tbl2, tbl3  = getEmptyTables()
  local msg = {
    "invalid argument #2 (integer or string expected)",
  }
  for i=1,4 do
    local row1, row2, row3 = getRows(i)
    tbl1:addrow(row1);
    tbl2:addrow(row2);
    tbl3:addrow(row3);
  end
  for i, tbl in ipairs{tbl1, tbl2, tbl3} do
    assertNil(tbl:index_of(0   ))
    assertNil(tbl:index_of(5   ))
    assertNil(tbl:index_of(100 ))
    assertNil(tbl:index_of(-100))
    assertEquals(tbl:index_of(1) , 1)
    assertEquals(tbl:index_of(4) , 4)
    assertEquals(tbl:index_of(-1), 4)
    assertEquals(tbl:index_of(-3), 2)
    assertErrorMsgContains(msg[1], mtable.index_of, tbl, 1.5)
  end
end

function TestMTable:testIndexOfString()
  local _, tbl2, tbl3 = getIdxTbl()
  local msg = {
    "invalid argument #2 (non-zero count expected)",
  }
  for i,tbl in ipairs{tbl2, tbl3} do
    assertNil   (tbl:index_of("name100  "   )   )
    assertNil   (tbl:index_of("name1[4] "   )   )
    assertNil   (tbl:index_of("name2[2] "   )   )
    assertNil   (tbl:index_of("name1[-4]"   )   )
    assertNil   (tbl:index_of("name2[-2]"   )   )
    assertNil   (tbl:index_of("name1{3} ", 2)   )
    assertNil   (tbl:index_of("name1{3} ",-3)   )
    assertNil   (tbl:index_of("name1{-2}", 1)   )
    assertNil   (tbl:index_of("name1{-2}",-4)   )
    assertNil   (tbl:index_of("name1{-3}", 3)   )
    assertNil   (tbl:index_of("name1{-3}",-2)   )
    assertEquals(tbl:index_of("name1"       ), 1)
    assertEquals(tbl:index_of("name2"       ), 2)
    assertEquals(tbl:index_of("name1[1]"    ), 1)
    assertEquals(tbl:index_of("name2[1]"    ), 2)
    assertEquals(tbl:index_of("name1[2]"    ), 3)
    assertEquals(tbl:index_of("name1[3]"    ), 4)
    assertEquals(tbl:index_of("name1[-1]"   ), 4)
    assertEquals(tbl:index_of("name2[-1]"   ), 2)
    assertEquals(tbl:index_of("name1[-3]"   ), 1)
    assertEquals(tbl:index_of("name1{1}" , 1), 1)
    assertEquals(tbl:index_of("name1{1}" ,-4), 1)
    assertEquals(tbl:index_of("name1{1}" , 2), 3)
    assertEquals(tbl:index_of("name1{1}" ,-3), 3)
    assertEquals(tbl:index_of("name1{2}" , 2), 4)
    assertEquals(tbl:index_of("name1{2}" ,-3), 4)
    assertEquals(tbl:index_of("name1{-1}", 2), 1)
    assertEquals(tbl:index_of("name1{-1}",-3), 1)
    assertEquals(tbl:index_of("name1{-1}", 1), 1)
    assertEquals(tbl:index_of("name1{-1}",-4), 1)
    assertEquals(tbl:index_of("name1{-2}", 3), 1)
    assertEquals(tbl:index_of("name1{-2}",-2), 1)
    assertEquals(tbl:index_of("name1{-1}", 3), 3)
    assertEquals(tbl:index_of("name1{-1}",-2), 3)
    assertEquals(tbl:index_of("name1{-2}", 4), 3)
    assertEquals(tbl:index_of("name1{-2}",-1), 3)
    assertEquals(tbl:index_of("name1{-3}", 4), 1)
    assertEquals(tbl:index_of("name1{-3}",-1), 1)
    assertEquals(tbl:index_of("name2{-1}", 3), 2)
    assertEquals(tbl:index_of("name2{-1}",-2), 2)
    assertErrorMsgContains(msg[1], mtable.index_of, tbl, "name1{0}", 2)
  end
end

function TestMTable:testIndexOfStringNoDict()
  local tbl1 = getIdxTbl()
  assertErrorMsgContains(_msg[3], mtable.index_of, tbl1, "name1"      )
  assertErrorMsgContains(_msg[3], mtable.index_of, tbl1, "name1[1]"   )
  assertErrorMsgContains(_msg[3], mtable.index_of, tbl1, "name1{1}", 1)
end

function TestMTable:testNameOfDirect()
  local _, tbl2, tbl3  = getEmptyTables()
  local msg = {
    "invalid argument #2 (integer expected)",
  }
  for i=1,4 do
    local _, row2, row3 = getRows(i)
    tbl2:addrow(row2);
    tbl3:addrow(row3);
  end
  for i, tbl in ipairs{tbl2, tbl3} do
    assertNil(tbl:name_of(0   ))
    assertNil(tbl:name_of(5   ))
    assertNil(tbl:name_of(100 ))
    assertNil(tbl:name_of(-100))
    assertEquals(tbl:name_of(1) , "name1")
    assertEquals(tbl:name_of(4) , "name4")
    assertEquals(tbl:name_of(-1), "name4")
    assertEquals(tbl:name_of(-3), "name2")
    assertErrorMsgContains(msg[1], mtable.name_of, tbl, 1.5)
  end
end

function TestMTable:testNameOfCnt()
  local _, tbl2, tbl3 = getIdxTbl()
  for i,tbl in ipairs{tbl2, tbl3} do
    assertEquals(tbl:name_of(2   ), "name2"    )
    assertEquals(tbl:name_of(1   ), "name1[1]" )
    assertEquals(tbl:name_of(3   ), "name1[2]" )
    assertEquals(tbl:name_of(4   ), "name1[3]" )
    assertEquals(tbl:name_of(1, 1), "name1{1}" )
    assertEquals(tbl:name_of(1,-4), "name1{1}" )
    assertEquals(tbl:name_of(3, 2), "name1{1}" )
    assertEquals(tbl:name_of(3,-3), "name1{1}" )
    assertEquals(tbl:name_of(4, 2), "name1{2}" )
    assertEquals(tbl:name_of(4,-3), "name1{2}" )
    assertEquals(tbl:name_of(1, 2), "name1{-1}")
    assertEquals(tbl:name_of(1,-3), "name1{-1}")
    assertEquals(tbl:name_of(1, 3), "name1{-1}")
    assertEquals(tbl:name_of(1,-2), "name1{-1}")
    assertEquals(tbl:name_of(1, 4), "name1{-2}")
    assertEquals(tbl:name_of(1,-1), "name1{-2}")
  end
end

function TestMTable:testNameOfCntNoDict()
  local tbl1  = getIdxTbl()
  assertErrorMsgContains(_msg[3], mtable.name_of, tbl1, 2   )
  assertErrorMsgContains(_msg[3], mtable.name_of, tbl1, 1   )
  assertErrorMsgContains(_msg[3], mtable.name_of, tbl1, 1, 1)
end

function TestMTable:testRangeOfInt()
  local tbl1, tbl2, tbl3  = getEmptyTables()
  local msg = {
    "invalid range start",
    "invalid argument #2 (integer, string, table or range expected)",
    "invalid range direction (1 or -1 expected)",
  }
  for i=1,4 do
    local row1, row2, row3 = getRows(i)
    tbl1:addrow(row1);
    tbl2:addrow(row2);
    tbl3:addrow(row3);
  end
  for i, tbl in ipairs{tbl1, tbl2, tbl3} do
    assertEquals(table.pack(tbl:range_of(nil,nil, 1)), {1,4, n=2})
    assertEquals(table.pack(tbl:range_of(nil,nil,-1)), {4,1, n=2})
    assertEquals(table.pack(tbl:range_of( 1        )), {1,1, n=2})
    assertEquals(table.pack(tbl:range_of( 4        )), {4,4, n=2})
    assertEquals(table.pack(tbl:range_of(-1        )), {4,4, n=2})
    assertEquals(table.pack(tbl:range_of(-3        )), {2,2, n=2})
    assertErrorMsgContains(msg[1], mtable.range_of, tbl, 0         )
    assertErrorMsgContains(msg[1], mtable.range_of, tbl, 5         )
    assertErrorMsgContains(msg[1], mtable.range_of, tbl, 100       )
    assertErrorMsgContains(msg[1], mtable.range_of, tbl,-100       )
    assertErrorMsgContains(msg[2], mtable.range_of, tbl, 1.5       )
    assertErrorMsgContains(msg[3], mtable.range_of, tbl, nil,nil, 0)
    assertErrorMsgContains(msg[3], mtable.range_of, tbl, nil,nil,-2)
  end
end

function TestMTable:testRangeOfStringInt()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    assertEquals(table.pack(tbl:range_of(" 1/ 1")), {1,1, n=2})
    assertEquals(table.pack(tbl:range_of(" 2/ 2")), {2,2, n=2})
    assertEquals(table.pack(tbl:range_of("-1/ 1")), {4,1, n=2})
    assertEquals(table.pack(tbl:range_of("-1/ 4")), {4,4, n=2})
    assertEquals(table.pack(tbl:range_of(" 1/-1")), {1,4, n=2})
    assertEquals(table.pack(tbl:range_of(" 4/-1")), {4,4, n=2})
  end
end

function TestMTable:testRangeOfStringPositive()
  local _, tbl2, tbl3 = getIdxTbl()
  for i,tbl in ipairs{tbl2, tbl3} do
    assertEquals(table.pack(tbl:range_of("name1    /name1    "   )), {1,1, n=2})
    assertEquals(table.pack(tbl:range_of("name1    /name2    "   )), {1,2, n=2})
    assertEquals(table.pack(tbl:range_of("name1[2] /name1[2] "   )), {3,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1[-2]/name1[-2]"   )), {3,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1[1] /name1[3] "   )), {1,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1[-3]/name1[-1]"   )), {1,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1[2] /name1[3] "   )), {3,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1[-2]/name1[-1]"   )), {3,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1[1] /name1[-1]"   )), {1,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1{1} /name1{2} ", 2)), {3,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1{1} /name1{2} ",-3)), {3,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1{1} /name1{2} ", 3)), {3,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1{1} /name1{2} ",-2)), {3,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1{-1}/name1{1} ", 3)), {3,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1{-1}/name1{1} ",-2)), {3,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1{-2}/name1{-1}", 4)), {3,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1{-2}/name1{-1}",-1)), {3,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1{-1}/name1{1} ", 2)), {1,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1{-1}/name1{1} ",-3)), {1,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1{-1}/name1{2} ", 2)), {1,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1{-1}/name1{2} ",-3)), {1,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1[2] /name1{2} ", 2)), {3,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1[2] /name1{2} ",-3)), {3,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1[-2]/name1{2} ", 2)), {3,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1[-2]/name1{2} ",-3)), {3,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1{-1}/name1[3] ", 2)), {1,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1{-1}/name1[3] ",-3)), {1,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1{1} /name1[3] ", 2)), {3,4, n=2})
    assertEquals(table.pack(tbl:range_of("name1{1} /name1[3] ",-3)), {3,4, n=2})
  end
end

function TestMTable:testRangeOfStringNegative()
  local _, tbl2, tbl3 = getIdxTbl()
  for i,tbl in ipairs{tbl2, tbl3} do
    assertEquals(table.pack(tbl:range_of("name2    /name1    "   )), {2,1, n=2})
    assertEquals(table.pack(tbl:range_of("name1[3] /name1[1] "   )), {4,1, n=2})
    assertEquals(table.pack(tbl:range_of("name1[-1]/name1[-3]"   )), {4,1, n=2})
    assertEquals(table.pack(tbl:range_of("name1[3] /name1[2] "   )), {4,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1[-1]/name1[-2]"   )), {4,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1[-1]/name1[1] "   )), {4,1, n=2})
    assertEquals(table.pack(tbl:range_of("name1{2} /name1{1} ", 2)), {4,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1{2} /name1{1} ",-3)), {4,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1{2} /name1{1} ", 3)), {4,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1{2} /name1{1} ",-2)), {4,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1{-1}/name1{-2}", 4)), {4,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1{-1}/name1{-2}",-1)), {4,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1{1}/name1{-1} ", 2)), {3,1, n=2})
    assertEquals(table.pack(tbl:range_of("name1{1}/name1{-1} ",-3)), {3,1, n=2})
    assertEquals(table.pack(tbl:range_of("name1{2}/name1{-1} ", 2)), {4,1, n=2})
    assertEquals(table.pack(tbl:range_of("name1{2}/name1{-1} ",-3)), {4,1, n=2})
    assertEquals(table.pack(tbl:range_of("name1{2}/name1[2]  ", 2)), {4,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1{2}/name1[2]  ",-3)), {4,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1{2}/name1[-2] ", 2)), {4,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1{2}/name1[-2] ",-3)), {4,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1[3]/name1{-1} ", 2)), {4,1, n=2})
    assertEquals(table.pack(tbl:range_of("name1[3]/name1{-1} ",-3)), {4,1, n=2})
    assertEquals(table.pack(tbl:range_of("name1[3]/name1{1}  ", 2)), {4,3, n=2})
    assertEquals(table.pack(tbl:range_of("name1[3]/name1{1}  ",-3)), {4,3, n=2})
  end
end

function TestMTable:testRangeOfStringInvalid()
  local _, tbl2, tbl3 = getIdxTbl()
  local range_of      = mtable.range_of
  local msg = {
    "invalid range start",
    "invalid range stop",
    "invalid argument #2 (integer or string expected)",
  }
  for i,tbl in ipairs{tbl2, tbl3} do
    assertErrorMsgContains(msg[3], range_of, tbl, "                   "   )
    assertErrorMsgContains(msg[1], range_of, tbl, "         /         "   )
    assertErrorMsgContains(msg[2], range_of, tbl, "name1    /         "   )
    assertErrorMsgContains(msg[1], range_of, tbl, "name100  /name1    "   )
    assertErrorMsgContains(msg[2], range_of, tbl, "name1    /name200  "   )
    assertErrorMsgContains(msg[1], range_of, tbl, "name100  /name200  "   )
    assertErrorMsgContains(msg[1], range_of, tbl, "name1[-4]/name1[3] "   )
    assertErrorMsgContains(msg[2], range_of, tbl, "name1[1] /name1[4] "   )
    assertErrorMsgContains(msg[1], range_of, tbl, "name1[4] /name1[3] "   )
    assertErrorMsgContains(msg[2], range_of, tbl, "name1[1] /name1[-4]"   )
    assertErrorMsgContains(msg[1], range_of, tbl, "name1{-2}/name1{1} ", 2)
    assertErrorMsgContains(msg[2], range_of, tbl, "name1{-1}/name1{3} ", 2)
    assertErrorMsgContains(msg[1], range_of, tbl, "name1{3} /name1{1} ", 2)
    assertErrorMsgContains(msg[2], range_of, tbl, "name1{-1}/name1{-3}", 2)
  end
end

function TestMTable:testRangeOfTableInt()
  local tbl1, tbl2, tbl3  = getEmptyTables()
  for i=1,4 do
    local row1, row2, row3 = getRows(i)
    tbl1:addrow(row1);
    tbl2:addrow(row2);
    tbl3:addrow(row3);
  end
  for i, tbl in ipairs{tbl1, tbl2, tbl3} do
    assertEquals(table.pack(tbl:range_of({1 , 1})), {1,1, n=2})
    assertEquals(table.pack(tbl:range_of({1 ,-1})), {1,4, n=2})
    assertEquals(table.pack(tbl:range_of({2 , 2})), {2,2, n=2})
    assertEquals(table.pack(tbl:range_of({-1, 1})), {4,1, n=2})
    assertEquals(table.pack(tbl:range_of({-1, 4})), {4,4, n=2})
    assertEquals(table.pack(tbl:range_of({4 ,-1})), {4,4, n=2})
  end
end

function TestMTable:testRangeOfTableStringInt()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local tpack         = table.pack
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    assertEquals(tpack(tbl:range_of({" 1", " 1"})), {1,1, n=2})
    assertEquals(tpack(tbl:range_of({" 1", "-1"})), {1,4, n=2})
    assertEquals(tpack(tbl:range_of({" 2", " 2"})), {2,2, n=2})
    assertEquals(tpack(tbl:range_of({"-1", " 1"})), {4,1, n=2})
    assertEquals(tpack(tbl:range_of({"-1", " 4"})), {4,4, n=2})
    assertEquals(tpack(tbl:range_of({" 4", "-1"})), {4,4, n=2})
    assertEquals(tpack(tbl:range_of({" 1", " 1"})), {1,1, n=2})
    assertEquals(tpack(tbl:range_of({"-1", " 1"})), {4,1, n=2})
    assertEquals(tpack(tbl:range_of({" 2", " 2"})), {2,2, n=2})
    assertEquals(tpack(tbl:range_of({" 1", "-1"})), {1,4, n=2})
    assertEquals(tpack(tbl:range_of({" 4", "-1"})), {4,4, n=2})
    assertEquals(tpack(tbl:range_of({"-1", " 4"})), {4,4, n=2})
  end
end

function TestMTable:testRangeOfTableStringPositiveAbsolute()
  local _, tbl2, tbl3 = getIdxTbl()
  local tpack         = table.pack
  for i,tbl in ipairs{tbl2, tbl3} do
    assertEquals(tpack(tbl:range_of({"name1    ", "name1    "})), {1,1, n=2})
    assertEquals(tpack(tbl:range_of({"name1    ", "name2    "})), {1,2, n=2})
    assertEquals(tpack(tbl:range_of({"name1[2] ", "name1[2] "})), {3,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1[-2]", "name1[-2]"})), {3,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1[1] ", "name1[3] "})), {1,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1[-3]", "name1[-1]"})), {1,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1[2] ", "name1[3] "})), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1[-2]", "name1[-1]"})), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1[1] ", "name1[-1]"})), {1,4, n=2})
  end
end

function TestMTable:testRangeOfTableStringPositiveRelative()
  local _, tbl2, tbl3 = getIdxTbl()
  local tpack         = table.pack
  for i,tbl in ipairs{tbl2, tbl3} do
    assertEquals(tpack(tbl:range_of({"name1{1} ", "name1{2} "}, 2)), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{1} ", "name1{2} "},-3)), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{1} ", "name1{2} "}, 3)), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{1} ", "name1{2} "},-2)), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1{1} "}, 3)), {3,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1{1} "},-2)), {3,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-2}", "name1{-1}"}, 4)), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-2}", "name1{-1}"},-1)), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1{1} "}, 2)), {1,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1{1} "},-3)), {1,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1{2} "}, 2)), {1,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1{2} "},-3)), {1,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1[2] ", "name1{2} "}, 2)), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1[2] ", "name1{2} "},-3)), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1[-2]", "name1{2} "}, 2)), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1[-2]", "name1{2} "},-3)), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1[3] "}, 2)), {1,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1[3] "},-3)), {1,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{1} ", "name1[3] "}, 2)), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{1} ", "name1[3] "},-3)), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{1} ", "name1{2} ", 2})), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{1} ", "name1{2} ",-3})), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{1} ", "name1{2} ", 3})), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{1} ", "name1{2} ",-2})), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1{1} ", 3})), {3,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1{1} ",-2})), {3,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-2}", "name1{-1}", 4})), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-2}", "name1{-1}",-1})), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1{1} ", 2})), {1,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1{1} ",-3})), {1,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1{2} ", 2})), {1,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1{2} ",-3})), {1,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1[2] ", "name1{2} ", 2})), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1[2] ", "name1{2} ",-3})), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1[-2]", "name1{2} ", 2})), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1[-2]", "name1{2} ",-3})), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1[3] ", 2})), {1,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1[3] ",-3})), {1,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{1} ", "name1[3] ", 2})), {3,4, n=2})
    assertEquals(tpack(tbl:range_of({"name1{1} ", "name1[3] ",-3})), {3,4, n=2})
  end
end

function TestMTable:testRangeOfTableStringNegativeAbsolute()
  local _, tbl2, tbl3 = getIdxTbl()
  local tpack         = table.pack
  for i,tbl in ipairs{tbl2, tbl3} do
    assertEquals(tpack(tbl:range_of({"name1    ", "name1    "})), {1,1, n=2})
    assertEquals(tpack(tbl:range_of({"name2    ", "name1    "})), {2,1, n=2})
    assertEquals(tpack(tbl:range_of({"name1[2] ", "name1[2] "})), {3,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1[-2]", "name1[-2]"})), {3,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1[3] ", "name1[1] "})), {4,1, n=2})
    assertEquals(tpack(tbl:range_of({"name1[-1]", "name1[-3]"})), {4,1, n=2})
    assertEquals(tpack(tbl:range_of({"name1[3] ", "name1[2] "})), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1[-1]", "name1[-2]"})), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1[-1]", "name1[1] "})), {4,1, n=2})
  end
end

function TestMTable:testRangeOfTableStringNegativeRelative()
  local _, tbl2, tbl3 = getIdxTbl()
  local tpack         = table.pack
  for i,tbl in ipairs{tbl2, tbl3} do
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1{1} "}, 2)), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1{1} "},-3)), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1{1} "}, 3)), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1{1} "},-2)), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1{-2}"}, 4)), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1{-2}"},-1)), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{1} ", "name1{-1}"}, 2)), {3,1, n=2})
    assertEquals(tpack(tbl:range_of({"name1{1} ", "name1{-1}"},-3)), {3,1, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1{-1}"}, 2)), {4,1, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1{-1}"},-3)), {4,1, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1[2] "}, 2)), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1[2] "},-3)), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1[-2]"}, 2)), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1[-2]"},-3)), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1[3] ", "name1{-1}"}, 2)), {4,1, n=2})
    assertEquals(tpack(tbl:range_of({"name1[3] ", "name1{-1}"},-3)), {4,1, n=2})
    assertEquals(tpack(tbl:range_of({"name1[3] ", "name1{1} "}, 2)), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1[3] ", "name1{1} "},-3)), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1{1} ", 2})), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1{1} ",-3})), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1{1} ", 3})), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1{1} ",-2})), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1{-2}", 4})), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{-1}", "name1{-2}",-1})), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{1} ", "name1{-1}", 2})), {3,1, n=2})
    assertEquals(tpack(tbl:range_of({"name1{1} ", "name1{-1}",-3})), {3,1, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1{-1}", 2})), {4,1, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1{-1}",-3})), {4,1, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1[2] ", 2})), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1[2] ",-3})), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1[-2]", 2})), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1{2} ", "name1[-2]",-3})), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1[3] ", "name1{-1}", 2})), {4,1, n=2})
    assertEquals(tpack(tbl:range_of({"name1[3] ", "name1{-1}",-3})), {4,1, n=2})
    assertEquals(tpack(tbl:range_of({"name1[3] ", "name1{1} ", 2})), {4,3, n=2})
    assertEquals(tpack(tbl:range_of({"name1[3] ", "name1{1} ",-3})), {4,3, n=2})
  end
end

function TestMTable:testRangeOfTableInvalid()
  local _, tbl2, tbl3 = getIdxTbl()
  local range_of      = mtable.range_of
  local msg = {
    "invalid range start",
    "invalid range stop",
    "invalid argument #2 (integer or string expected)",
  }
  for i,tbl in ipairs{tbl2, tbl3} do
    assertErrorMsgContains(msg[1], range_of, tbl, { 0         , 2          }   )
    assertErrorMsgContains(msg[2], range_of, tbl, { 1         , 5          }   )
    assertErrorMsgContains(msg[1], range_of, tbl, {-100       , 2          }   )
    assertErrorMsgContains(msg[2], range_of, tbl, { 1         , 100        }   )
    assertErrorMsgContains(msg[3], range_of, tbl, { 1.5       , 2          }   )
    assertErrorMsgContains(msg[3], range_of, tbl, { 1         , 2.5        }   )
    assertErrorMsgContains(msg[1], range_of, tbl, {"         ", "         "}   )
    assertErrorMsgContains(msg[2], range_of, tbl, {"name1    ", "         "}   )
    assertErrorMsgContains(msg[1], range_of, tbl, {"name100  ", "name1    "}   )
    assertErrorMsgContains(msg[2], range_of, tbl, {"name1    ", "name200  "}   )
    assertErrorMsgContains(msg[1], range_of, tbl, {"name100  ", "name200  "}   )
    assertErrorMsgContains(msg[1], range_of, tbl, {"name1[-4]", "name1[3] "}   )
    assertErrorMsgContains(msg[2], range_of, tbl, {"name1[1] ", "name1[4] "}   )
    assertErrorMsgContains(msg[1], range_of, tbl, {"name1[4] ", "name1[3] "}   )
    assertErrorMsgContains(msg[2], range_of, tbl, {"name1[1] ", "name1[-4]"}   )
    assertErrorMsgContains(msg[1], range_of, tbl, {"name1{-2}", "name1{1} "}, 2)
    assertErrorMsgContains(msg[2], range_of, tbl, {"name1{-1}", "name1{3} "}, 2)
    assertErrorMsgContains(msg[1], range_of, tbl, {"name1{3} ", "name1{1} "}, 2)
    assertErrorMsgContains(msg[2], range_of, tbl, {"name1{-1}", "name1{-3}"}, 2)
    assertErrorMsgContains(msg[1], range_of, tbl, {"name1{-2}", "name1{1} ", 2})
    assertErrorMsgContains(msg[2], range_of, tbl, {"name1{-1}", "name1{3} ", 2})
    assertErrorMsgContains(msg[1], range_of, tbl, {"name1{3} ", "name1{1} ", 2})
    assertErrorMsgContains(msg[2], range_of, tbl, {"name1{-1}", "name1{-3}", 2})
  end
end

function TestMTable:testRangeOfRange()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    assertEquals(table.pack(tbl:range_of( 1 ..  4)), {1,4, n=2})
    assertEquals(table.pack(tbl:range_of(-4 .. -1)), {1,4, n=2})
    assertEquals(table.pack(tbl:range_of( 2 ..  3)), {2,3, n=2})
    assertEquals(table.pack(tbl:range_of( 4 ..  1)), {4,1, n=2})
    assertEquals(table.pack(tbl:range_of(-1 .. -4)), {4,1, n=2})
    assertEquals(table.pack(tbl:range_of( 3 ..  2)), {3,2, n=2})
  end
end

function TestMTable:testLengthOf0TrnPositive()
  local _, tbl2, tbl3 = getIdxTbl()
  local length_of     = mtable.length_of
  local msg = {
    "invalid range start",
    "invalid range stop",
  }
  for i,tbl in ipairs{tbl2, tbl3} do
    assertEquals(tbl:length_of(                                  ), 4)
    assertEquals(tbl:length_of( "1         /  4       "          ), 4)
    assertEquals(tbl:length_of( "name1[1]  /  name1[3]"          ), 4)
    assertEquals(tbl:length_of({"name1[1] ", "name1[3]"   }      ), 4)
    assertEquals(tbl:length_of({"name1{-1}", "name1{2}", 2}      ), 4)
    assertEquals(tbl:length_of({2          , 3            }      ), 2)
    assertEquals(tbl:length_of( nil                        , 1   ), 4)
    assertEquals(tbl:length_of( "1         /  4       "    , 1   ), 4)
    assertEquals(tbl:length_of( "name1[1]  /  name1[3]"    , 1   ), 4)
    assertEquals(tbl:length_of({"name1[1] ", "name1[3]"   }, 1   ), 4)
    assertEquals(tbl:length_of({"name1{-1}", "name1{2}", 2}, 1   ), 4)
    assertEquals(tbl:length_of({2          , 3            }, 1   ), 2)
    assertEquals(tbl:length_of( nil                        , 1,-1), 4)
    assertEquals(tbl:length_of( "1         /  4       "    , 1,-1), 2)
    assertEquals(tbl:length_of( "name1[1]  /  name1[3]"    , 1,-1), 2)
    assertEquals(tbl:length_of({"name1[1] ", "name1[3]"   }, 1,-1), 2)
    assertEquals(tbl:length_of({"name1{-1}", "name1{2}", 2}, 1,-1), 2)
    assertEquals(tbl:length_of({2          , 3            }, 1,-1), 4)
    assertErrorMsgContains(msg[1], length_of, tbl,  "name1[-4] / name1[3] "    )
    assertErrorMsgContains(msg[2], length_of, tbl, {"name1{-1}","name1{-3}", 2})
  end
end

function TestMTable:testLengthOf0TrnNegative()
  local _, tbl2, tbl3 = getIdxTbl()
  local length_of     = mtable.length_of
  local msg = {
    "invalid range start",
    "invalid range stop",
  }
  for i,tbl in ipairs{tbl2, tbl3} do
    assertEquals(tbl:length_of( "4        /  1       "           ), 2)
    assertEquals(tbl:length_of( "name1[3] /  name1[1]"           ), 2)
    assertEquals(tbl:length_of({3         , 2             }      ), 4)
    assertEquals(tbl:length_of({"name1[3]", "name1[1] "   }      ), 2)
    assertEquals(tbl:length_of({"name1{2}", "name1{-1}", 2}      ), 2)
    assertEquals(tbl:length_of( "4        /  1        "    , 1   ), 2)
    assertEquals(tbl:length_of( "name1[3] /  name1[1] "    , 1   ), 2)
    assertEquals(tbl:length_of({"name1[3]", "name1[1] "   }, 1   ), 2)
    assertEquals(tbl:length_of({"name1{2}", "name1{-1}", 2}, 1   ), 2)
    assertEquals(tbl:length_of({3          , 2            }, 1   ), 4)
    assertEquals(tbl:length_of( "4        /  1        "    , 1,-1), 4)
    assertEquals(tbl:length_of( "name1[3] /  name1[1] "    , 1,-1), 4)
    assertEquals(tbl:length_of({"name1[3]", "name1[1] "   }, 1,-1), 4)
    assertEquals(tbl:length_of({"name1{2}", "name1{-1}", 2}, 1,-1), 4)
    assertEquals(tbl:length_of({3          , 2            }, 1,-1), 2)
    assertErrorMsgContains(msg[1], length_of, tbl, {"name1{-3}","name1{-1}", 2})
    assertErrorMsgContains(msg[2], length_of, tbl,  "name1[3] / name1[-4] "    )
  end
end

function TestMTable:testLengthOfNTrnPositive()
  local _, tbl2, tbl3 = getIdxTbl()
  for i,tbl in ipairs{tbl2, tbl3} do
    assertEquals(tbl:length_of( nil                        , 6   ), 24)
    assertEquals(tbl:length_of( "1         /  4       "    , 6   ), 24)
    assertEquals(tbl:length_of( "name1[1]  /  name1[3]"    , 6   ), 24)
    assertEquals(tbl:length_of({"name1[1] ", "name1[3]"   }, 6   ), 24)
    assertEquals(tbl:length_of({"name1{-1}", "name1{2}", 2}, 6   ), 24)
    assertEquals(tbl:length_of({2          , 3            }, 6   ), 22)
    assertEquals(tbl:length_of( nil                        , 6,-1), 24)
    assertEquals(tbl:length_of( "1         /  4       "    , 6,-1), 22)
    assertEquals(tbl:length_of( "name1[1]  /  name1[3]"    , 6,-1), 22)
    assertEquals(tbl:length_of({"name1[1] ", "name1[3]"   }, 6,-1), 22)
    assertEquals(tbl:length_of({"name1{-1}", "name1{2}", 2}, 6,-1), 22)
    assertEquals(tbl:length_of({2          , 3            }, 6,-1), 24)
  end
end

function TestMTable:testLengthOfNTrnNegative()
  local _, tbl2, tbl3 = getIdxTbl()
  for i,tbl in ipairs{tbl2, tbl3} do
    assertEquals(tbl:length_of( "4        /  1        "    , 6   ), 22)
    assertEquals(tbl:length_of( "name1[3] /  name1[1] "    , 6   ), 22)
    assertEquals(tbl:length_of({"name1[3]", "name1[1] "   }, 6   ), 22)
    assertEquals(tbl:length_of({"name1{2}", "name1{-1}", 2}, 6   ), 22)
    assertEquals(tbl:length_of({3         , 2             }, 6   ), 24)
    assertEquals(tbl:length_of( "4        /  1        "    , 6,-1), 24)
    assertEquals(tbl:length_of( "name1[3] /  name1[1] "    , 6,-1), 24)
    assertEquals(tbl:length_of({"name1[3]", "name1[1] "   }, 6,-1), 24)
    assertEquals(tbl:length_of({"name1{2}", "name1{-1}", 2}, 6,-1), 24)
    assertEquals(tbl:length_of({3         , 2             }, 6,-1), 22)
  end
end

function TestMTable:testGetRowIdx()
  local tbl1, tbl2, tbl3 = getEmptyTables()
  for i=1,4 do
    local row1, row2, row3 = getRows(i)
    tbl1:addrow(row1); tbl2:addrow(row2); tbl3:addrow(row3)
  end
  for i=1,4 do
    local row1, row2, row3 = getRows(i)
    assertEquals(tbl1:getrow(i), row1)
    assertEquals(tbl2:getrow(i), row2)
    assertEquals(tbl3:getrow(i), row3)
  end
end

function TestMTable:testGetRowName()
  local tbl1, tbl2, tbl3 = getEmptyTables()
  for i=1,4 do
    local row1, row2, row3 = getRows(i)
    tbl1:addrow(row1); tbl2:addrow(row2); tbl3:addrow(row3)
  end
  for i=1,4 do
    local row1, row2, row3 = getRows(i)
    assertEquals(tbl2:getrow(row2[1]), row2)
    assertEquals(tbl3:getrow(row3[4]), row3)
  end
end

function TestMTable:testGetRowNameRef()
  local _, tbl2, tbl3 = getIdxTbl()
  local _, row2, row3 = getRows(3)
  row2[1], row3[4] = "name1", "name1"
  assertEquals(tbl2:getrow("name1", 2), row2)
  assertEquals(tbl3:getrow("name1", 2), row3)
end

function TestMTable:testGetColIdx()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local coli    = { 1       ,  2     , 3      , 4       }
  local coldict = { "name1" , "name2", "name1", "name1" }
  local col2    = {-1       ,-2      ,-3      ,-4       }
  local col3    = { pi      , 2*pi   , 3*pi   , 4*pi    }
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    assertVecEquals(tbl:getcol(2), col2)
    assertVecEquals(tbl:getcol(3), col3)
    local nc = (i == 1) and 3 or 4
    assertVecEquals(tbl:getcol(1-nc), col2)
    assertVecEquals(tbl:getcol(2-nc), col3)
  end
  assertVecEquals(tbl1:getcol( 1), coli   )
  assertVecEquals(tbl1:getcol(-3), coli   )
  assertVecEquals(tbl2:getcol( 4), coli   )
  assertVecEquals(tbl2:getcol(-1), coli   )
  assertVecEquals(tbl3:getcol( 1), coli   )
  assertVecEquals(tbl3:getcol(-4), coli   )
  assertVecEquals(tbl2:getcol( 1), coldict)
  assertVecEquals(tbl2:getcol(-4), coldict)
  assertVecEquals(tbl3:getcol( 4), coldict)
  assertVecEquals(tbl3:getcol(-1), coldict)
end

function TestMTable:testGetColInvalid()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  assertNil(tbl1:getcol( 4    ))
  assertNil(tbl2:getcol( 5    ))
  assertNil(tbl3:getcol( 5    ))
  assertNil(tbl1:getcol(-5    ))
  assertNil(tbl2:getcol(-6    ))
  assertNil(tbl3:getcol(-6    ))
  assertNil(tbl1:getcol("none"))
  assertNil(tbl2:getcol("none"))
end

function TestMTable:testGetColName()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local coli    = { 1       ,  2     , 3      , 4       }
  local coldict = { "name1" , "name2", "name1", "name1" }
  local col2    = {-1       ,-2      ,-3      ,-4       }
  local col3    = { pi      , 2*pi   , 3*pi   , 4*pi    }
  for i,tbl in ipairs{tbl1, tbl3} do
    assertVecEquals(tbl:getcol("x"), coli)
    assertVecEquals(tbl:getcol("y"), col2)
    assertVecEquals(tbl:getcol("z"), col3)
  end
  assertVecEquals(tbl2:getcol("x"   ), col2   )
  assertVecEquals(tbl2:getcol("y"   ), col3   )
  assertVecEquals(tbl2:getcol("z"   ), coli   )
  assertVecEquals(tbl2:getcol("dict"), coldict)
  assertVecEquals(tbl3:getcol("dict"), coldict)
end

function TestMTable:testGetIdx()
  local tbl1, tbl2, tbl3          = getIdxTbl()
  local coli, col2, col3, coldict = getCols()
  local val1    = { coli    , col2   , col3             }
  local val2    = { coldict , col2   , col3   , coli    }
  local val3    = { coli    , col2   , col3   , coldict }
  -- positive idx
  for i=1,4 do
    for j=1,3 do assertEquals(tbl1:get(i,j), val1[j][i]) end
    for j=1,4 do
      assertEquals(tbl2:get(i,j), val2[j][i])
      assertEquals(tbl3:get(i,j), val3[j][i])
    end
  end
  -- negative idx
  for i=-4,-1 do
    for j=-3,-1 do assertEquals(tbl1:get(i,j), val1[4+j][5+i]) end
    for j=-4,-1 do
      assertEquals(tbl2:get(i,j), val2[5+j][5+i])
      assertEquals(tbl3:get(i,j), val3[5+j][5+i])
    end
  end
end

function TestMTable:testGetNamedCol()
  local tbl1, tbl2, tbl3          = getIdxTbl()
  local coli, col2, col3, coldict = getCols()
  for i=1,4 do
    assertEquals(tbl1:get(i, "x"   ), coli[i]   )
    assertEquals(tbl1:get(i, "y"   ), col2[i]   )
    assertEquals(tbl1:get(i, "z"   ), col3[i]   )
    assertEquals(tbl2:get(i, "dict"), coldict[i])
    assertEquals(tbl2:get(i, "x"   ), col2[i]   )
    assertEquals(tbl2:get(i, "y"   ), col3[i]   )
    assertEquals(tbl2:get(i, "z"   ), coli[i]   )
    assertEquals(tbl3:get(i, "x"   ), coli[i]   )
    assertEquals(tbl3:get(i, "y"   ), col2[i]   )
    assertEquals(tbl3:get(i, "z"   ), col3[i]   )
    assertEquals(tbl3:get(i, "dict"), coldict[i])
  end
end

function TestMTable:testGetNamedRow()
  local _, tbl2, tbl3 = getIdxTbl()
  for i,tbl in ipairs{tbl2, tbl3} do
    assertEquals(tbl:get("name1",2), -1)
    assertEquals(tbl:get("name2",2), -2)
  end
end

function TestMTable:testGetNamedRowRef()
  local _, tbl2, tbl3 = getIdxTbl()
  for i,tbl in ipairs{tbl2, tbl3} do
    assertEquals(tbl:get("name1",2, 1), -1)
    assertEquals(tbl:get("name1",2,-3), -1)
    assertEquals(tbl:get("name1",2, 2), -3)
    assertEquals(tbl:get("name1",2,-2), -3)
    assertEquals(tbl:get("name1",2, 3), -4)
    assertEquals(tbl:get("name1",2,-1), -4)
  end
end

function TestMTable:testGetInvalid()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    assertNil(tbl:get( 6    , 1     ))
    assertNil(tbl:get(-6    , 1     ))
    assertNil(tbl:get( 1    , "none"))
    assertNil(tbl:get( 1    , 6     ))
    assertNil(tbl:get( 1    ,-6     ))
  end
  for i,tbl in ipairs{tbl2, tbl3} do
    assertNil(tbl:get("name1"   , 1, 4))
    assertNil(tbl:get("name1[2]", 1   ))
    assertNil(tbl:get("name1"   , 1,-4))
  end
end

function TestMTable:testGetDict()
  local _, tbl2, tbl3 = getIdxTbl()
  for _,tbl in ipairs{tbl2, tbl3} do
    local col = tbl:getcol("dict")
    col[2] = "name3"
    col[4] = "name4"
    assertEquals(tbl:get("name3", 2), -2)
    assertEquals(tbl:get("name4", 2), -4)
  end
end

function TestMTable:testSetIdx()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local last = 1
  local r = \ => last = random() return last end
  for i=1,4 do
    for j=1,3 do
      tbl1:set(i  , j  , r()); assertEquals(tbl1:get(i  , j  ), last)
      tbl1:set(i-5, j-4, r()); assertEquals(tbl1:get(i-5, j-4), last)
      tbl3:set(i  , j  , r()); assertEquals(tbl3:get(i  , j  ), last)
      tbl3:set(i-5, j-5, r()); assertEquals(tbl3:get(i-5, j-5), last)
    end
    for j=2,4 do
      tbl2:set(i  , j  , r()); assertEquals(tbl2:get(i  , j  ), last)
      tbl2:set(i-5, j-5, r()); assertEquals(tbl2:get(i-5, j-5), last)
    end
  end
end

function TestMTable:testSetNamedCol()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local last = 1
  local r    = \ => last = random() return last end
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    for _,key in ipairs{"x", "y", "z"} do
      for i=1,4 do
        tbl:set(i, key, r()); assertEquals(tbl:get(i, key),last)
      end
    end
  end
end

function TestMTable:testSetNamedRow()
  local _, tbl2, tbl3 = getIdxTbl()
  local last = 1
  local r    = \ => last = random() return last end
  for i,tbl in ipairs{tbl2, tbl3} do
    tbl:set("name1", 2, r()); assertEquals(tbl:get("name1", 2), last)
    tbl:set("name2", 2, r()); assertEquals(tbl:get("name2", 2), last)
  end
end

function TestMTable:testSetNamedRowRef()
  local _, tbl2, tbl3 = getIdxTbl()
  local last = 1
  local r    = \ => last = random() return last end
  for i,tbl in ipairs{tbl2, tbl3} do
    tbl:set("name1", 2, r(), 1); assertEquals(tbl:get("name1", 2, 1), last)
    tbl:set("name1", 2, r(),-3); assertEquals(tbl:get("name1", 2,-3), last)
    tbl:set("name1", 2, r(), 2); assertEquals(tbl:get("name1", 2, 2), last)
    tbl:set("name1", 2, r(),-2); assertEquals(tbl:get("name1", 2,-2), last)
    tbl:set("name1", 2, r(), 3); assertEquals(tbl:get("name1", 2, 3), last)
    tbl:set("name1", 2, r(),-1); assertEquals(tbl:get("name1", 2,-1), last)
  end
end

function TestMTable:testSetInvalid()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local v   = 241
  local msg = {
    "row index out of bounds",
    "invalid argument #3 (valid column expected)",
    "invalid argument #2 (valid row[cnt] expected)",
    "invalid argument #2 (valid row expected)",
    "invalid argument #4 (valid reference key expected)",
  }
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    assertErrorMsgContains(msg[1], mtable.set, tbl,  6        , 1     , v)
    assertErrorMsgContains(msg[1], mtable.set, tbl, -6        , 1     , v)
    assertErrorMsgContains(msg[2], mtable.set, tbl,  1        , "none", v)
    assertErrorMsgContains(msg[2], mtable.set, tbl,  1        , 6     , v)
    assertErrorMsgContains(msg[2], mtable.set, tbl,  1        ,-6     , v)
  end
  for i,tbl in ipairs{tbl2, tbl3} do
    assertErrorMsgContains(msg[3], mtable.set, tbl, "name1"   , 1     , v, 4)
    assertErrorMsgContains(msg[3], mtable.set, tbl, "name1"   , 1     , v,-4)
    assertErrorMsgContains(msg[4], mtable.set, tbl, "name1[2]", 1     , v   )
    assertErrorMsgContains(msg[5], mtable.set, tbl, 1         , "dict", nil )
  end
end

function TestMTable:testSetDict()
  local _, tbl2, tbl3 = getIdxTbl()
  for i,tbl in ipairs{tbl2, tbl3} do
    tbl:set("name1", "dict", "name5"   ); assertEquals(tbl:get("name5", 2),-1)
    tbl:set("name1", "dict", "name6", 2); assertEquals(tbl:get("name6", 2),-4)
    tbl:set("name1", "dict", "name7", 1); assertEquals(tbl:get("name7", 2),-3)
  end
end

function TestMTable:testNoVector()
  local tbl1 = mtable "tbl1" { "x", "y", "z", novector = true }
  local tbl2 = mtable "tbl2" { "x", "y", "z", novector = {"x", "y"} }
  local row  = { 1, 2, 3 }
  for i=1,4 do tbl1:addrow(row); tbl2:addrow(row) end
  assertFalse(is_vector(tbl1:getcol(1)))
  assertFalse(is_vector(tbl1:getcol(2)))
  assertFalse(is_vector(tbl1:getcol(3)))
  assertFalse(is_vector(tbl2:getcol(1)))
  assertFalse(is_vector(tbl2:getcol(2)))
  assertTrue (is_vector(tbl2:getcol(3)))
end

function TestMTable:testNoVectorComplex()
  local tbl1 = mtable "tbl1" { "x", "y", "z", novector = true }
  local tbl2 = mtable "tbl2" { "x", "y", "z", novector = {"x", "y"} }
  local row  = { 1+1i, 2+2i, 3+3i }
  for i=1,4 do tbl1:addrow(row); tbl2:addrow(row) end
  assertFalse(is_cvector(tbl1:getcol(1)))
  assertFalse(is_cvector(tbl1:getcol(2)))
  assertFalse(is_cvector(tbl1:getcol(3)))
  assertFalse(is_cvector(tbl2:getcol(1)))
  assertFalse(is_cvector(tbl2:getcol(2)))
  assertTrue (is_cvector(tbl2:getcol(3)))
end

function TestMTable:testNoVectorInheritance()
  local parent1 = mtable  "parent1" { "w", "x", novector = true  }
  local parent2 = mtable  "parent2" { "w", "x", novector = {"w"} }
  local child1  = parent1 "child1"  { "y", "z", novector = {"y"} }
  local child2  = parent2 "child2"  { "y", "z", novector = {"y"} }
  local child3  = parent2 "child3"  { "y", "z", novector = true  }
  local row     = { 1, 2, 3, 4 }

  for i=1,4 do child1:addrow(row); child2:addrow(row); child3:addrow(row) end

  assertFalse(is_vector(child1:getcol(1)))
  assertFalse(is_vector(child1:getcol(2)))
  assertFalse(is_vector(child1:getcol(3)))
  assertTrue (is_vector(child1:getcol(4)))

  assertFalse(is_vector(child2:getcol(1)))
  assertTrue (is_vector(child2:getcol(2)))
  assertFalse(is_vector(child2:getcol(3)))
  assertTrue (is_vector(child2:getcol(4)))

  assertFalse(is_vector(child3:getcol(1)))
  assertFalse(is_vector(child3:getcol(2)))
  assertFalse(is_vector(child3:getcol(3)))
  assertFalse(is_vector(child3:getcol(4)))
end

function TestMTable:testNoVectorComplexInheritance()
  local parent1 = mtable  "parent1" { "w", "x", novector = true  }
  local parent2 = mtable  "parent2" { "w", "x", novector = {"w"} }
  local child1  = parent1 "child1"  { "y", "z", novector = {"y"} }
  local child2  = parent2 "child2"  { "y", "z", novector = {"y"} }
  local child3  = parent2 "child3"  { "y", "z", novector = true  }
  local row     = { 1+1i, 2+2i, 3+3i, 4+4i }

  for i=1,4 do child1:addrow(row); child2:addrow(row); child3:addrow(row) end

  assertFalse(is_cvector(child1:getcol(1)))
  assertFalse(is_cvector(child1:getcol(2)))
  assertFalse(is_cvector(child1:getcol(3)))
  assertTrue (is_cvector(child1:getcol(4)))

  assertFalse(is_cvector(child2:getcol(1)))
  assertTrue (is_cvector(child2:getcol(2)))
  assertFalse(is_cvector(child2:getcol(3)))
  assertTrue (is_cvector(child2:getcol(4)))

  assertFalse(is_cvector(child3:getcol(1)))
  assertFalse(is_cvector(child3:getcol(2)))
  assertFalse(is_cvector(child3:getcol(3)))
  assertFalse(is_cvector(child3:getcol(4)))
end

function TestMTable:testAddCol()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local col1 = { "v1", "v2", "v3", "v4" }
  local col2 = \i -> i
  local col3 = { 10  , 20  , 30  , 40   }
  local col4 = \i -> i+1
  local col5 = {}
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    tbl:addcol("col2", col2)
    tbl:addcol("col1", col1)
    tbl:addcol("col4", col4)
    tbl:addcol("col3", col3)
    tbl:addcol("col5", col5)
    -- test value
    for i=1,4 do
      assertEquals(tbl:getcol("col1")[i], col1[i])
      assertEquals(tbl:getcol("col2")[i], col2(i))
      assertEquals(tbl:getcol("col3")[i], col3[i])
      assertEquals(tbl:getcol("col4")[i], col4(i))
      assertEquals(tbl:getcol("col5")[i], col5[i])
    end
    -- test order
    assertEquals(tbl:getcol("col1"), tbl:getcol(-5))
    assertEquals(tbl:getcol("col2"), tbl:getcol(-2))
    assertEquals(tbl:getcol("col3"), tbl:getcol(-4))
    assertEquals(tbl:getcol("col4"), tbl:getcol(-1))
    assertEquals(tbl:getcol("col5"), tbl:getcol(-3))
  end
end

function TestMTable:testAddColEmpty()
  local tbl1, tbl2, tbl3 = getEmptyTables()
  local row1, row2, row3 = getRows()
  local col1 = { }
  local col2 = \i -> i
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    tbl:addcol("col1", col1)
    tbl:addcol("col2", col2)
    assertEquals(tbl:getcol("col1"), col1)
    assertNotNil(tbl:getcol("col2"))
  end
  tbl1:addrow(row1)
  tbl2:addrow(row2)
  tbl3:addrow(row3)
  assertEquals(tbl1:getcol("col1"), { })
  assertEquals(tbl2:getcol("col1"), { })
  assertEquals(tbl3:getcol("col1"), { })
  assertEquals(tbl1:getcol("col2"), {1})
  assertEquals(tbl2:getcol("col2"), {1})
  assertEquals(tbl3:getcol("col2"), {1})
end

function TestMTable:testAddColNvec()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local col1 = {10  , "v2", nil , true }
  local col2 = {10  , 20  , 30  , 40   }
  local col3 = { "v1", "v2", "v3", "v4" }
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    tbl:addcol("col1", col1, true )
    tbl:addcol("col2", col2, true )
    tbl:addcol("col3", col3, false)
    tbl:addcol("col4", col2, false)
    for i=1,4 do
      assertEquals(tbl:getcol("col1")[i], col1[i])
      assertEquals(tbl:getcol("col2")[i], col2[i])
      assertEquals(tbl:getcol("col3")[i], col3[i])
      assertEquals(tbl:getcol("col4")[i], col2[i])
    end
    assertFalse(is_vector(tbl:getcol("col1")))
    assertFalse(is_vector(tbl:getcol("col2")))
    assertFalse(is_vector(tbl:getcol("col3")))
    assertTrue (is_vector(tbl:getcol("col4")))
  end
end

function TestMTable:testAddColNvecComplex()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local col1 = {10+10i, "v2"  , nil   , true  }
  local col2 = {10+10i, 20+20i, 30+30i, 40+40i}
  local col3 = { "v1" , "v2"  , "v3"  , "v4"  }
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    tbl:addcol("col1", col1, true )
    tbl:addcol("col2", col2, true )
    tbl:addcol("col3", col3, false)
    tbl:addcol("col4", col2, false)
    for i=1,4 do
      assertEquals(tbl:getcol("col1")[i], col1[i])
      assertEquals(tbl:getcol("col2")[i], col2[i])
      assertEquals(tbl:getcol("col3")[i], col3[i])
      assertEquals(tbl:getcol("col4")[i], col2[i])
    end
    assertFalse(is_cvector(tbl:getcol("col1")))
    assertFalse(is_cvector(tbl:getcol("col2")))
    assertFalse(is_cvector(tbl:getcol("col3")))
    assertTrue (is_cvector(tbl:getcol("col4")))
  end
end

function TestMTable:testAddColInvalid()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local msg = {
    "invalid argument #3 (column name 'col1' already in use)",
    "invalid argument #3 (column name 'col2' already in use)",
    "incompatible container size",
  }
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    tbl:addcol("col1", {}  )
    tbl:addcol("col2", \ ())
    assertErrorMsgContains(msg[1], mtable.addcol, tbl, "col1", {   })
    assertErrorMsgContains(msg[2], mtable.addcol, tbl, "col2", \ ( ))
    assertErrorMsgContains(msg[3], mtable.addcol, tbl, "col3", { 1 })
  end
end

function TestMTable:testRemColEmptyIdxPositive()
  local tbl1  = mtable "tbl1"  { "x" }
  local tbl2  = mtable "tbl2"  { "x", "y" }
  local tbl3  = mtable "tbl2"  { "x", "y" }

  tbl1:remcol(1)
  assertNil(tbl1:getcol(1))

  tbl2:remcol(1)
  assertNil(tbl2:getcol("x"))
  assertEquals(tbl2:getcol("y"), {})

  tbl3:remcol(2)
  assertEquals(tbl3:getcol("x"), {})
  assertNil(tbl3:getcol("y"))
end

function TestMTable:testRemColEmptyIdxNegative()
  local tbl1  = mtable "tbl1"  { "x" }
  local tbl2  = mtable "tbl2"  { "x", "y" }
  local tbl3  = mtable "tbl2"  { "x", "y" }

  tbl1:remcol(-1)
  assertNil(tbl1:getcol(1))

  tbl2:remcol(-2)
  assertNil(tbl2:getcol("x"))
  assertEquals(tbl2:getcol("y"), {})

  tbl3:remcol(-1)
  assertEquals(tbl3:getcol("x"), {})
  assertNil(tbl3:getcol("y"))
end

function TestMTable:testRemColIdx()
  local ref1, ref2, ref3 = getIdxTbl()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  for tbl,ref in pairs{[tbl1]=ref1, [tbl2]=ref2, [tbl3]=ref3} do
    tbl:remcol(1)
    assertVecEquals(tbl:getcol(1), ref:getcol(2))
    tbl:remcol(-1)
    assertVecEquals(tbl:getcol(-1), ref:getcol(-2))
  end
end

function TestMTable:testRemColIdxGen()
  local ref1, ref2, ref3 = getIdxTbl()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local col1 = \i -> i
  local col2 = \i -> i+1
  local col3 = \i -> i+2
  local col4 = \i -> i+3
  for tbl,ref in pairs{[tbl1]=ref1, [tbl2]=ref2, [tbl3]=ref3} do
    tbl:addcol("col1", col1); ref:addcol("col1", col1)
    tbl:addcol("col2", col2); ref:addcol("col2", col2)
    tbl:addcol("col3", col3); ref:addcol("col3", col3)
    tbl:addcol("col4", col4); ref:addcol("col4", col4)
    tbl:remcol(-3)
    assertVecEquals(tbl:getcol(-3), ref:getcol(-4))
    tbl:remcol(-1)
    assertVecEquals(tbl:getcol(-1), ref:getcol(-2))
  end
end

function TestMTable:testRemColName()
  local ref1, ref2, ref3 = getIdxTbl()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  for tbl,ref in pairs{[tbl1]=ref1, [tbl2]=ref2, [tbl3]=ref3} do
    tbl:remcol("x")
    assertNil(tbl:getcol("x"))
    tbl:remcol("z")
    assertNil(tbl:getcol("z"))
  end
end

function TestMTable:testRemColNameGen()
  local ref1, ref2, ref3 = getIdxTbl()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local col1 = \i -> i
  local col2 = \i -> i+1
  local col3 = \i -> i+2
  local col4 = \i -> i+3
  for tbl,ref in pairs{[tbl1]=ref1, [tbl2]=ref2, [tbl3]=ref3} do
    tbl:addcol("col1", col1); ref:addcol("col1", col1)
    tbl:addcol("col2", col2); ref:addcol("col2", col2)
    tbl:addcol("col3", col3); ref:addcol("col3", col3)
    tbl:addcol("col4", col4); ref:addcol("col4", col4)
    tbl:remcol("col2")
    assertNil(tbl:getcol("col2"))
    tbl:remcol("col4")
    assertNil(tbl:getcol("col4"))
  end
end

function TestMTable:testRemColDict()
  local _, tbl21, tbl31 = getIdxTbl()
  local _, tbl22, tbl32 = getIdxTbl()
  for _,tbl in pairs{tbl21, tbl31} do
    tbl:remcol("dict")
    assertErrorMsgContains(_msg[3], mtable.index_of, tbl, "name1")
  end
  for _,tbl in pairs{tbl22, tbl32} do
    tbl:remcol(2)
    tbl:check_index()
  end
end

function TestMTable:testRemColInvalid()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local msg = {
    "invalid argument #2 (valid column expected)",
  }
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    assertErrorMsgContains(msg[1], mtable.remcol, tbl, 6     )
    assertErrorMsgContains(msg[1], mtable.remcol, tbl,-6     )
    assertErrorMsgContains(msg[1], mtable.remcol, tbl, "none")
  end
end

function TestMTable:testInsColEmptyIdx()
  local tbl1, tbl2, tbl3 = getEmptyTables()
  local col = { }
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    tbl:inscol(1, "col1", col)
    tbl:inscol(2, "col2", col)
    local lst = (i == 1) and 6 or 7
    tbl:inscol(lst, "col3", col)
    assertNotNil(tbl:getcol("col1"))
    assertNotNil(tbl:getcol("col2"))
    assertNotNil(tbl:getcol("col3"))
  end
end

function TestMTable:testInsColEmptyIdxGen()
  local tbl1, tbl2, tbl3 = getEmptyTables()
  local col = \i -> i
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    local lst = (i == 1) and 4 or 5
    tbl:inscol(lst  , "col1", col)
    tbl:inscol(lst  , "col2", col)
    tbl:inscol(lst+2, "col3", col)
    tbl:inscol(lst+1, "col4", col)
    assertNotNil(tbl:getcol("col1"))
    assertNotNil(tbl:getcol("col2"))
    assertNotNil(tbl:getcol("col3"))
    assertNotNil(tbl:getcol("col4"))
  end
end

function TestMTable:testInsColIdxPositive()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local col1 = \i -> i
  local col2 = \i -> i+1
  local col3 = \i -> i+2
  local col4 = { 10  , 20  , 30  , 40   }
  local col5 = {}
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    local lst = (i == 1) and 5 or 6
    tbl:inscol(1  , "col1", col1)
    tbl:inscol(lst, "col2", col2)
    tbl:inscol(lst, "col3", col3)
    tbl:inscol(2  , "col4", col4)
    tbl:inscol(7  , "col5", col5)
    -- test value
    for i=1,4 do
      assertEquals(tbl:getcol("col1")[i], col1(i))
      assertEquals(tbl:getcol("col2")[i], col2(i))
      assertEquals(tbl:getcol("col3")[i], col3(i))
      assertEquals(tbl:getcol("col4")[i], col4[i])
      assertEquals(tbl:getcol("col5")[i], col5[i])
    end
    -- test order
    assertEquals(tbl:getcol("col1"), tbl:getcol(-3))
    assertEquals(tbl:getcol("col2"), tbl:getcol(-1))
    assertEquals(tbl:getcol("col3"), tbl:getcol(-2))
    assertEquals(tbl:getcol("col4"), tbl:getcol( 2))
    assertEquals(tbl:getcol("col5"), tbl:getcol(-4))
  end
end

function TestMTable:testInsColIdxNegative()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local col1 = \i -> i
  local col2 = \i -> i+1
  local col3 = \i -> i+2
  local col4 = { 10  , 20  , 30  , 40   }
  local col5 = {}
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    local lst = (i == 1) and 5 or 6
    tbl:inscol(-3  , "col2", col2)
    tbl:inscol(-2  , "col1", col1)
    tbl:inscol(-1  , "col3", col3)
    tbl:inscol(-lst, "col4", col4)
    tbl:inscol(-1  , "col5", col5)
    -- test value
    for i=1,4 do
      assertEquals(tbl:getcol("col1")[i], col1(i))
      assertEquals(tbl:getcol("col2")[i], col2(i))
      assertEquals(tbl:getcol("col3")[i], col3(i))
      assertEquals(tbl:getcol("col4")[i], col4[i])
      assertEquals(tbl:getcol("col5")[i], col5[i])
    end
    -- test order
    assertEquals(tbl:getcol("col1"), tbl:getcol(-3))
    assertEquals(tbl:getcol("col2"), tbl:getcol(-1))
    assertEquals(tbl:getcol("col3"), tbl:getcol(-2))
    assertEquals(tbl:getcol("col4"), tbl:getcol( 2))
    assertEquals(tbl:getcol("col5"), tbl:getcol(-4))
  end
end

function TestMTable:testInsColAdd()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local col = \i -> i
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    tbl:inscol("col", col)
    assertEquals(tbl:getcol("col"), tbl:getcol(-1))
  end
end

function TestMTable:testInsColName()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local col1 = \i -> i
  local col2 = { 10  , 20  , 30  , 40   }
  local col3 = \i -> i+1
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    local lst = (i == 1) and 5 or 6
    tbl:inscol("x"   , "col1", col1)
    tbl:inscol("x"   , "col2", col2)
    tbl:inscol("col2", "col3", col3)
    -- test value
    for i=1,4 do
      assertEquals(tbl:getcol("col1")[i], col1(i))
      assertEquals(tbl:getcol("col2")[i], col2[i])
      assertEquals(tbl:getcol("col3")[i], col3(i))
    end
    -- test order
    assertEquals(tbl:getcol("col1"), tbl:getcol(-1))
    assertEquals(tbl:getcol("col3"), tbl:getcol(-2))
  end
    -- test order
    assertEquals(tbl1:getcol("col2"), tbl1:getcol(1))
    assertEquals(tbl2:getcol("col2"), tbl2:getcol(2))
    assertEquals(tbl3:getcol("col2"), tbl3:getcol(1))
end

function TestMTable:testInsColNvec()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local col1 = {10  , "v2", nil , true }
  local col2 = {10  , 20  , 30  , 40   }
  local col3 = { "v1", "v2", "v3", "v4" }
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    tbl:inscol(1, "col1", col1, true )
    tbl:inscol(3, "col2", col2, true )
    tbl:inscol(4, "col3", col3, false)
    tbl:inscol(5, "col4", col2, false)
    for i=1,4 do
      assertEquals(tbl:getcol("col1")[i], col1[i])
      assertEquals(tbl:getcol("col2")[i], col2[i])
      assertEquals(tbl:getcol("col3")[i], col3[i])
      assertEquals(tbl:getcol("col4")[i], col2[i])
    end
    assertFalse(is_vector(tbl:getcol("col1")))
    assertFalse(is_vector(tbl:getcol("col2")))
    assertFalse(is_vector(tbl:getcol("col3")))
    assertTrue (is_vector(tbl:getcol("col4")))
  end
end

function TestMTable:testInsColNvecComplex()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local col1 = {10+10i, "v2"  , nil   , true  }
  local col2 = {10+10i, 20+20i, 30+30i, 40+40i}
  local col3 = { "v1" , "v2"  , "v3"  , "v4"  }
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    tbl:inscol(1, "col1", col1, true )
    tbl:inscol(3, "col2", col2, true )
    tbl:inscol(4, "col3", col3, false)
    tbl:inscol(5, "col4", col2, false)
    for i=1,4 do
      assertEquals(tbl:getcol("col1")[i], col1[i])
      assertEquals(tbl:getcol("col2")[i], col2[i])
      assertEquals(tbl:getcol("col3")[i], col3[i])
      assertEquals(tbl:getcol("col4")[i], col2[i])
    end
    assertFalse(is_cvector(tbl:getcol("col1")))
    assertFalse(is_cvector(tbl:getcol("col2")))
    assertFalse(is_cvector(tbl:getcol("col3")))
    assertTrue (is_cvector(tbl:getcol("col4")))
  end
end

function TestMTable:testInsColDict()
  local _, tbl2, tbl3 = getIdxTbl()
  local col1 = { 10, 20, 30, 40 }
  for _,tbl in pairs{tbl2, tbl3} do
    tbl:inscol(1, "col1", col1)
    tbl:check_index()
  end
end

function TestMTable:testInsColInvalid()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local msg = {
    "invalid argument #3 (column name 'col1' already in use)",
    "invalid argument #3 (column name 'col2' already in use)",
    "incompatible container size",
    "invalid insertion key (valid column expected)",
    "invalid argument #4 (callable or iterable expected)",
  }
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    tbl:addcol("col1", {}  )
    tbl:addcol("col2", \ ())
    assertErrorMsgContains(msg[1], mtable.inscol, tbl, 1     , "col1", {   })
    assertErrorMsgContains(msg[2], mtable.inscol, tbl, 1     , "col2", \ ( ))
    assertErrorMsgContains(msg[3], mtable.inscol, tbl, 1     , "col3", { 1 })
    assertErrorMsgContains(msg[4], mtable.inscol, tbl, 8     , "col3", {   })
    assertErrorMsgContains(msg[4], mtable.inscol, tbl,-8     , "col3", {   })
    assertErrorMsgContains(msg[4], mtable.inscol, tbl, "none", "col3", {   })
    assertErrorMsgContains(msg[5], mtable.inscol, tbl, 1     , "col3", "   ")
  end
end

function TestMTable:testSetColIdxPositive()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local col1 = { 11  , 21  , 31  , 41   }
  local col2 = \i -> i
  local col3 = { 13  , 23  , 33  , 43   }
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    local lst = (i == 1) and 3 or 4
    tbl:setcol(1  , col1)
    tbl:setcol(2  , col2)
    tbl:setcol(lst, col3)
    for i=1,4 do
      assertEquals(tbl:getcol(1  )[i], col1[i])
      assertEquals(tbl:getcol(2  )[i], col2(i))
      assertEquals(tbl:getcol(lst)[i], col3[i])
    end
  end
end

function TestMTable:testSetColIdxNegative()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local col1 = { 11  , 21  , 31  , 41   }
  local col2 = \i -> i
  local col3 = { 13  , 23  , 33  , 43   }
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    local lst = (i == 1) and 3 or 4
    tbl:setcol(-lst  , col1)
    tbl:setcol(-lst+1, col2)
    tbl:setcol(-1    , col3)
    for i=1,4 do
      assertEquals(tbl:getcol(-lst  )[i], col1[i])
      assertEquals(tbl:getcol(-lst+1)[i], col2(i))
      assertEquals(tbl:getcol(-1    )[i], col3[i])
    end
  end
end

function TestMTable:testSetColName()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local col1 = { 11  , 21  , 31  , 41   }
  local col2 = \i -> i
  local col3 = { 13  , 23  , 33  , 43   }
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    tbl:setcol("x"   , col1)
    tbl:setcol("y"   , col2)
    tbl:setcol("z"   , col3)
    for i=1,4 do
      assertEquals(tbl:getcol("x")[i], col1[i])
      assertEquals(tbl:getcol("y")[i], col2(i))
      assertEquals(tbl:getcol("z")[i], col3[i])
    end
  end
end

function TestMTable:testSetColGen()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local col1, col2 = \i->i, \i->i+1
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    tbl:addcol("col1"   , col1)
    tbl:setcol("col1"   , col2)
    for i=1,4 do assertEquals(tbl:getcol("col1")[i], col2(i)) end
  end
end

function TestMTable:testSetColDict()
  local _, tbl2, tbl3 = getIdxTbl()
  local col1 = { "n1", "n2", "n3", "n4" }
  for _,tbl in pairs{tbl2, tbl3} do
    tbl:setcol("dict", col1)
    tbl:check_index()
  end
end

function TestMTable:testSetColInvalid()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local msg = {
    "invalid argument #2 (callable expected)",
    "invalid argument #2 (valid column expected)",
    "invalid argument #3 (callable or iterable expected)",
  }
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    tbl:addcol("col1", {}  )
    tbl:addcol("col2", \ ())
    assertErrorMsgContains(msg[1], mtable.setcol, tbl, "col2", { })
    assertErrorMsgContains(msg[2], mtable.setcol, tbl, 8     , { })
    assertErrorMsgContains(msg[2], mtable.setcol, tbl,-8     , { })
    assertErrorMsgContains(msg[2], mtable.setcol, tbl, "none", { })
    assertErrorMsgContains(msg[3], mtable.setcol, tbl, 1     , "" )
  end
end

function TestMTable:testNRow()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local empty1, empty2, empty3 = getEmptyTables()
  assertEquals(empty1:nrow(), 0)
  assertEquals(empty2:nrow(), 0)
  assertEquals(empty3:nrow(), 0)
  assertEquals(tbl1:nrow(), 4)
  assertEquals(tbl2:nrow(), 4)
  assertEquals(tbl3:nrow(), 4)
end

function TestMTable:testNCol()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local empty1, empty2, empty3 = getEmptyTables()
  assertEquals(empty1:ncol(), 3)
  assertEquals(empty2:ncol(), 4)
  assertEquals(empty3:ncol(), 4)
  assertEquals(tbl1:ncol(), 3)
  assertEquals(tbl2:ncol(), 4)
  assertEquals(tbl3:ncol(), 4)
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    tbl:addcol("col1", { }    )
    tbl:addcol("col2", \i -> i)
  end
  assertEquals(tbl1:ncol(), 5)
  assertEquals(tbl2:ncol(), 6)
  assertEquals(tbl3:ncol(), 6)
end

function TestMTable:testNGen()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local empty1, empty2, empty3 = getEmptyTables()
  assertEquals(empty1:ngen(), 0)
  assertEquals(empty2:ngen(), 0)
  assertEquals(empty3:ngen(), 0)
  for i,tbl in ipairs{tbl1, tbl2, tbl3} do
    assertEquals(tbl:ngen(), 0)
    tbl:addcol("col1", { }    )
    tbl:addcol("col2", \i -> i)
    assertEquals(tbl:ngen(), 1)
  end
end

function TestMTable:testInsRowEmpty()
  local tbl1, tbl2, tbl3 = getEmptyTables()
  local row1, row2, row3 = getRows()
  tbl1:insrow(1, row1)
  tbl2:insrow(1, row2)
  tbl3:insrow(1, row3)
  assertEquals(tbl1:getrow(1, row1), row1)
  assertEquals(tbl2:getrow(1, row2), row2)
  assertEquals(tbl3:getrow(1, row3), row3)
end

function TestMTable:testInsRowIdxPositive()
  local tbl1 , tbl2 , tbl3  = getIdxTbl()
  local row11, row21, row31 = getRows(5)
  local row12, row22, row32 = getRows(6)
  local row13, row23, row33 = getRows(7)
  tbl1:insrow(1, row11)
  tbl2:insrow(1, row21)
  tbl3:insrow(1, row31)
  tbl1:insrow(3, row12)
  tbl2:insrow(3, row22)
  tbl3:insrow(3, row32)
  tbl1:insrow(5, row13)
  tbl2:insrow(5, row23)
  tbl3:insrow(5, row33)
  assertEquals(tbl1:getrow(1), row11)
  assertEquals(tbl2:getrow(1), row21)
  assertEquals(tbl3:getrow(1), row31)
  assertEquals(tbl1:getrow(3), row12)
  assertEquals(tbl2:getrow(3), row22)
  assertEquals(tbl3:getrow(3), row32)
  assertEquals(tbl1:getrow(5), row13)
  assertEquals(tbl2:getrow(5), row23)
  assertEquals(tbl3:getrow(5), row33)
end

function TestMTable:testInsRowIdxNegative()
  local tbl1 , tbl2 , tbl3  = getIdxTbl()
  local row11, row21, row31 = getRows(5)
  local row12, row22, row32 = getRows(6)
  tbl1:insrow(-4, row11)
  tbl2:insrow(-4, row21)
  tbl3:insrow(-4, row31)
  tbl1:insrow(-2, row12)
  tbl2:insrow(-2, row22)
  tbl3:insrow(-2, row32)
  assertEquals(tbl1:getrow(1), row11)
  assertEquals(tbl2:getrow(1), row21)
  assertEquals(tbl3:getrow(1), row31)
  assertEquals(tbl1:getrow(4), row12)
  assertEquals(tbl2:getrow(4), row22)
  assertEquals(tbl3:getrow(4), row32)
end

function TestMTable:testInsRowName()
  local _, tbl2, tbl3   = getIdxTbl()
  local _, row21, row31 = getRows(5)
  local _, row22, row32 = getRows(6)
  tbl2:insrow("name1", row21)
  tbl3:insrow("name1", row31)
  tbl2:insrow("name2", row22)
  tbl3:insrow("name2", row32)
  assertEquals(tbl2:getrow(1), row21)
  assertEquals(tbl3:getrow(1), row31)
  assertEquals(tbl2:getrow(3), row22)
  assertEquals(tbl3:getrow(3), row32)
end

function TestMTable:testInsRowNameRef()
  local _, tbl2, tbl3   = getIdxTbl()
  local _, row21, row31 = getRows(5)
  local _, row22, row32 = getRows(6)
  tbl2:insrow("name1{2}", row21, 2)
  tbl3:insrow("name1{2}", row31, 2)
  tbl2:insrow("name1[2]", row22)
  tbl3:insrow("name1[2]", row32)
  assertEquals(tbl2:getrow("name5"), tbl2:getrow(5))
  assertEquals(tbl3:getrow("name5"), tbl3:getrow(5))
  assertEquals(tbl2:getrow("name6"), tbl2:getrow(3))
  assertEquals(tbl3:getrow("name6"), tbl3:getrow(3))
end

function TestMTable:testInsRowNil()
  local tbl1, tbl2, tbl3 = getEmptyTables()

  assertErrorMsgContains(_msg[2], mtable.insrow, tbl2, 1, {  })
  assertErrorMsgContains(_msg[2], mtable.insrow, tbl3, 1, {  })
  tbl2:insrow(1, { "name1", nil, nil, nil     })
  tbl3:insrow(1, {     nil, nil, nil, "name1" })
  assertEquals(#tbl2, 1)
  assertEquals(#tbl3, 1)
  for j=1,3 do
    assertEquals(tbl2:get(1,j+1), nil)
    assertEquals(tbl3:get(1,j  ), nil)
  end
  tbl1:check_index()
  tbl2:check_index()
  tbl3:check_index()
end

function TestMTable:testInsRowInvalid()
  local tbl1, tbl2, tbl3 = getEmptyTables()
  local row1, row2, row3 = getRows(1)
  local msg = {
    "invalid argument #2 (valid row expected)",
  }
  tbl1:addrow(row1); tbl2:addrow(row2); tbl3:addrow(row3);

  assertErrorMsgContains(msg[1], mtable.insrow, tbl1, 5    , { })
  assertErrorMsgContains(msg[1], mtable.insrow, tbl2, 5    , { })
  assertErrorMsgContains(msg[1], mtable.insrow, tbl3, 5    , { })
  assertErrorMsgContains(msg[1], mtable.insrow, tbl1,-5    , { })
  assertErrorMsgContains(msg[1], mtable.insrow, tbl2,-5    , { })
  assertErrorMsgContains(msg[1], mtable.insrow, tbl3,-5    , { })
  assertErrorMsgContains(msg[1], mtable.insrow, tbl2,"none", { })
  assertErrorMsgContains(msg[1], mtable.insrow, tbl3,"none", { })
end

function TestMTable:testInsRowsByColName()
  local tbl1, tbl2, tbl3 = getEmptyTables()
  local row1 = { x = 1, y = 2, z = 3         }
  local row2 = { x = 1, y = 2, z = 3, dict = "name"}
  local row3 = { x = 1, y = 2, z = 3, dict = "name"}
  tbl1:insrow(1, row1)
  tbl2:insrow(1, row2)
  tbl3:insrow(1, row3)
  assertEquals(tbl1:getrow(1), { 1     , 2, 3         })
  assertEquals(tbl2:getrow(1), { "name", 1, 2, 3      })
  assertEquals(tbl3:getrow(1), { 1     , 2, 3, "name" })
end

function TestMTable:testSetRowIdxPositive()
  local tbl1 , tbl2 , tbl3  = getIdxTbl()
  local row11, row21, row31 = getRows(5)
  local row12, row22, row32 = getRows(6)
  local row13, row23, row33 = getRows(7)
  tbl1:setrow(1, row11)
  tbl2:setrow(1, row21)
  tbl3:setrow(1, row31)
  tbl1:setrow(3, row12)
  tbl2:setrow(3, row22)
  tbl3:setrow(3, row32)
  tbl1:setrow(4, row13)
  tbl2:setrow(4, row23)
  tbl3:setrow(4, row33)
  assertEquals(tbl1:getrow(1), row11)
  assertEquals(tbl2:getrow(1), row21)
  assertEquals(tbl3:getrow(1), row31)
  assertEquals(tbl1:getrow(3), row12)
  assertEquals(tbl2:getrow(3), row22)
  assertEquals(tbl3:getrow(3), row32)
  assertEquals(tbl1:getrow(4), row13)
  assertEquals(tbl2:getrow(4), row23)
  assertEquals(tbl3:getrow(4), row33)
end

function TestMTable:testSetRowIdxNegative()
  local tbl1 , tbl2 , tbl3  = getIdxTbl()
  local row11, row21, row31 = getRows(5)
  local row12, row22, row32 = getRows(6)
  local row13, row23, row33 = getRows(7)
  tbl1:setrow(-4, row11)
  tbl2:setrow(-4, row21)
  tbl3:setrow(-4, row31)
  tbl1:setrow(-2, row12)
  tbl2:setrow(-2, row22)
  tbl3:setrow(-2, row32)
  tbl1:setrow(-1, row13)
  tbl2:setrow(-1, row23)
  tbl3:setrow(-1, row33)
  assertEquals(tbl1:getrow(1), row11)
  assertEquals(tbl2:getrow(1), row21)
  assertEquals(tbl3:getrow(1), row31)
  assertEquals(tbl1:getrow(3), row12)
  assertEquals(tbl2:getrow(3), row22)
  assertEquals(tbl3:getrow(3), row32)
  assertEquals(tbl1:getrow(4), row13)
  assertEquals(tbl2:getrow(4), row23)
  assertEquals(tbl3:getrow(4), row33)
end

function TestMTable:testSetRowByName()
  local _, tbl2, tbl3   = getIdxTbl()
  local _, row21, row31 = getRows(5)
  local _, row22, row32 = getRows(6)
  tbl2:setrow("name1", row21)
  tbl3:setrow("name1", row31)
  tbl2:setrow("name2", row22)
  tbl3:setrow("name2", row32)
  assertEquals(tbl2:getrow(1), row21)
  assertEquals(tbl3:getrow(1), row31)
  assertEquals(tbl2:getrow(2), row22)
  assertEquals(tbl3:getrow(2), row32)
end

function TestMTable:testSetRowByNameRef()
  local _, tbl2, tbl3   = getIdxTbl()
  local _, row21, row31 = getRows(5)
  local _, row22, row32 = getRows(6)
  tbl2:setrow("name1{2}", row21, 2)
  tbl3:setrow("name1{2}", row31, 2)
  tbl2:setrow("name1[2]", row22)
  tbl3:setrow("name1[2]", row32)
  assertEquals(tbl2:getrow("name5"), tbl2:getrow(4))
  assertEquals(tbl3:getrow("name5"), tbl3:getrow(4))
  assertEquals(tbl2:getrow("name6"), tbl2:getrow(3))
  assertEquals(tbl3:getrow("name6"), tbl3:getrow(3))
  tbl2:check_index()
  tbl3:check_index()
end

function TestMTable:testSetRowNil()
  local tbl1, tbl2, tbl3 = getEmptyTables()
  local row1, row2, row3 = getRows(1)
  local msg = {
    "invalid reference index (key is nil)",
  }
  tbl1:addrow(row1); tbl2:addrow(row2); tbl3:addrow(row3);

  for _,tbl in ipairs{tbl2, tbl2, tbl3} do
    tbl:setrow(1, { })
    assertEquals(#tbl, 1)
    tbl:check_index()
  end
  assertEquals(tbl1:getrow(1), row1)
  assertEquals(tbl2:getrow(1), row2)
  assertEquals(tbl3:getrow(1), row3)
  tbl1:check_index()
  tbl2:check_index()
end

function TestMTable:testSetRowInvalid()
  local tbl1, tbl2, tbl3 = getEmptyTables()
  local row1, row2, row3 = getRows(1)
  local msg = {
    "invalid argument #2 (valid row expected)",
  }
  tbl1:addrow(row1); tbl2:addrow(row2); tbl3:addrow(row3);

  assertErrorMsgContains(msg[1], mtable.setrow, tbl1, 5     , { })
  assertErrorMsgContains(msg[1], mtable.setrow, tbl2, 5     , { })
  assertErrorMsgContains(msg[1], mtable.setrow, tbl3, 5     , { })
  assertErrorMsgContains(msg[1], mtable.setrow, tbl1,-5     , { })
  assertErrorMsgContains(msg[1], mtable.setrow, tbl2,-5     , { })
  assertErrorMsgContains(msg[1], mtable.setrow, tbl3,-5     , { })
  assertErrorMsgContains(msg[1], mtable.setrow, tbl2, "none", { })
  assertErrorMsgContains(msg[1], mtable.setrow, tbl3, "none", { })
end

function TestMTable:testSetRowsByColName()
  local tbl1, tbl2, tbl3 = getEmptyTables()
  local row1 = { x = 1, y = 2, z = 3         }
  local row2 = { x = 1, y = 2, z = 3, dict = "name"}
  local row3 = { x = 1, y = 2, z = 3, dict = "name"}
  tbl1:addrow{ }
  tbl2:addrow{dict = "test"}
  tbl3:addrow{dict = "test"}
  tbl1:setrow(1, row1)
  tbl2:setrow(1, row2)
  tbl3:setrow(1, row3)
  assertEquals(tbl1:getrow(1), { 1     , 2, 3         })
  assertEquals(tbl2:getrow(1), { "name", 1, 2, 3      })
  assertEquals(tbl3:getrow(1), { 1     , 2, 3, "name" })
end

function TestMTable:testClrRowIdx()
  local tbl1 , tbl2 , tbl3  = getIdxTbl()
  local row1 = { 0      , 0, 0         }
  local row2 = { "name1", 0, 0, 0      }
  local row3 = { 0      , 0, 0, "name1"}
  tbl1:clrrow( 1)
  tbl1:clrrow(-1)
  tbl2:clrrow( 1)
  tbl2:clrrow(-1)
  tbl3:clrrow( 1)
  tbl3:clrrow(-1)
  assertEquals(tbl1:getrow( 1), row1)
  assertEquals(tbl1:getrow(-1), row1)
  assertEquals(tbl2:getrow( 1), row2)
  assertEquals(tbl2:getrow(-1), row2)
  assertEquals(tbl3:getrow( 1), row3)
  assertEquals(tbl3:getrow(-1), row3)
end

function TestMTable:testClrRowName()
  local _, tbl2, tbl3   = getIdxTbl()
  tbl2:clrrow("name1")
  tbl2:clrrow("name2")
  tbl3:clrrow("name1")
  tbl3:clrrow("name2")
  assertEquals(tbl2:getrow(1), { "name1", 0, 0, 0      })
  assertEquals(tbl2:getrow(2), { "name2", 0, 0, 0      })
  assertEquals(tbl3:getrow(1), { 0      , 0, 0, "name1"})
  assertEquals(tbl3:getrow(2), { 0      , 0, 0, "name2"})
end

function TestMTable:testClrRowNameRef()
  local _, tbl2, tbl3   = getIdxTbl()
  local row2 = { "name1", 0, 0, 0      }
  local row3 = { 0      , 0, 0, "name1"}
  tbl2:clrrow("name1{2}", 2)
  tbl3:clrrow("name1{2}", 2)
  tbl2:clrrow("name1[2]")
  tbl3:clrrow("name1[2]")
  assertEquals(tbl2:getrow(4), row2)
  assertEquals(tbl2:getrow(3), row2)
  assertEquals(tbl3:getrow(4), row3)
  assertEquals(tbl3:getrow(3), row3)
end

function TestMTable:testClrRowNoVector()
  local tbl = mtable "tbl" { {"dict"}, "x", "y", "z", novector = true }
  local row1 = { "name1" }
  local _, row2 = getRows(1)

  for i=1,4 do tbl:addrow(row2) end
  tbl:clrrow(1)
  tbl:clrrow(-1)
  tbl:clrrow("name1[2]")
  tbl:clrrow("name1{2}",2)
  for i=1,4 do assertVecEquals(tbl:getrow(i), row1) end
end

function TestMTable:testClrComplex()
  local tbl = mtable "tbl" { {"dic"}, "x", "y", "z" }
  local row = { "name1", 1+1i, 2+2i, 3+3i }
  local res = { "name1", 0+0i, 0+0i, 0+0i }

  for i=1,4 do tbl:addrow(row) end
  tbl:clrrow(1)
  tbl:clrrow(-1)
  tbl:clrrow("name1[2]")
  tbl:clrrow("name1{2}",2)
  for i=1,4 do assertVecEquals(tbl:getrow(i), res) end
end

function TestMTable:testRemRowIdxPositive()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local row1, row2, row3 = getRows(2)
  tbl1:remrow(1)
  tbl2:remrow(1)
  tbl3:remrow(1)
  tbl1:remrow(2)
  tbl2:remrow(2)
  tbl3:remrow(2)
  tbl1:remrow(2)
  tbl2:remrow(2)
  tbl3:remrow(2)
  assertEquals(#tbl1, 1)
  assertEquals(#tbl2, 1)
  assertEquals(#tbl3, 1)
  assertEquals(tbl1:getrow(1), row1)
  assertEquals(tbl2:getrow(1), row2)
  assertEquals(tbl3:getrow(1), row3)
end

function TestMTable:testRemRowIdxNegative()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local row1, row2, row3 = getRows(2)
  tbl1:remrow(-4)
  tbl2:remrow(-4)
  tbl3:remrow(-4)
  tbl1:remrow(-2)
  tbl2:remrow(-2)
  tbl3:remrow(-2)
  tbl1:remrow(-1)
  tbl2:remrow(-1)
  tbl3:remrow(-1)
  assertEquals(#tbl1, 1)
  assertEquals(#tbl2, 1)
  assertEquals(#tbl3, 1)
  assertEquals(tbl1:getrow(1), row1)
  assertEquals(tbl2:getrow(1), row2)
  assertEquals(tbl3:getrow(1), row3)
end

function TestMTable:testRemRowName()
  local _, tbl2, tbl3 = getIdxTbl()
  local _, ref2, ref3 = getIdxTbl()
  tbl2:remrow("name1")
  tbl3:remrow("name1")
  tbl2:remrow("name2")
  tbl3:remrow("name2")
  assertEquals(#tbl2, 2)
  assertEquals(#tbl3, 2)
  assertEquals(tbl2:getrow(1), ref2:getrow(3))
  assertEquals(tbl3:getrow(1), ref3:getrow(3))
  assertEquals(tbl2:getrow(2), ref2:getrow(4))
  assertEquals(tbl3:getrow(2), ref3:getrow(4))
end

function TestMTable:testRemRowNameRef()
  local _, tbl2, tbl3 = getIdxTbl()
  local _, ref2, ref3 = getIdxTbl()
  tbl2:remrow("name1{2}", 2)
  tbl3:remrow("name1{2}", 2)
  tbl2:remrow("name1[2]")
  tbl3:remrow("name1[2]")
  assertEquals(#tbl2, 2)
  assertEquals(#tbl3, 2)
  assertEquals(tbl2:getrow(1), ref2:getrow(1))
  assertEquals(tbl3:getrow(1), ref3:getrow(1))
  assertEquals(tbl2:getrow(2), ref2:getrow(2))
  assertEquals(tbl3:getrow(2), ref3:getrow(2))
end

function TestMTable:testRemRowInvalid()
  local tbl1, tbl2, tbl3 = getEmptyTables()
  local row1, row2, row3 = getRows(1)
  local msg = {
    "invalid argument #2 (valid row expected)",
  }
  tbl1:addrow(row1); tbl2:addrow(row2); tbl3:addrow(row3);

  assertErrorMsgContains(msg[1], mtable.remrow, tbl1, 5)
  assertErrorMsgContains(msg[1], mtable.remrow, tbl2, 5)
  assertErrorMsgContains(msg[1], mtable.remrow, tbl3, 5)
  assertErrorMsgContains(msg[1], mtable.remrow, tbl1,-5)
  assertErrorMsgContains(msg[1], mtable.remrow, tbl2,-5)
  assertErrorMsgContains(msg[1], mtable.remrow, tbl3,-5)
  assertErrorMsgContains(msg[1], mtable.remrow, tbl2,"none")
  assertErrorMsgContains(msg[1], mtable.remrow, tbl3,"none")
end

function TestMTable:testSwpRowIdxPositive()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local ref1, ref2, ref3 = getIdxTbl()
  for tbl,ref in pairs{[tbl1]=ref1, [tbl2]=ref2, [tbl3]=ref3} do
    tbl:swprow(1, 4)
    tbl:swprow(2, 3)
    assertEquals(tbl:getrow(1), ref:getrow(4))
    assertEquals(tbl:getrow(4), ref:getrow(1))
    assertEquals(tbl:getrow(2), ref:getrow(3))
    assertEquals(tbl:getrow(3), ref:getrow(2))
  end
end

function TestMTable:testSwpRowIdxNegative()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local ref1, ref2, ref3 = getIdxTbl()
  for tbl,ref in pairs{[tbl1]=ref1, [tbl2]=ref2, [tbl3]=ref3} do
    tbl:swprow(-4, -1)
    tbl:swprow(-3, -2)
    assertEquals(tbl:getrow(1), ref:getrow(4))
    assertEquals(tbl:getrow(4), ref:getrow(1))
    assertEquals(tbl:getrow(2), ref:getrow(3))
    assertEquals(tbl:getrow(3), ref:getrow(2))
  end
end

function TestMTable:testSwpRowName()
  local _, tbl2, tbl3 = getIdxTbl()
  local _, ref2, ref3 = getIdxTbl()
  tbl2:swprow("name1", "name2")
  tbl3:swprow("name1", "name2")
  assertEquals(tbl2:getrow(1), ref2:getrow(2))
  assertEquals(tbl3:getrow(1), ref3:getrow(2))
  assertEquals(tbl2:getrow(2), ref2:getrow(1))
  assertEquals(tbl3:getrow(2), ref3:getrow(1))
end

function TestMTable:testSwpRowNameRef()
  local _, tbl2, tbl3 = getIdxTbl()
  local _, ref2, ref3 = getIdxTbl()
  tbl2:swprow("name1{1}", "name1{2}", 2)
  tbl3:swprow("name1{1}", "name1{2}", 2)
  tbl2:swprow("name1[1]", "name1[2]")
  tbl3:swprow("name1[1]", "name1[2]")
  assertEquals(tbl2:getrow(1), ref2:getrow(4))
  assertEquals(tbl3:getrow(1), ref3:getrow(4))
  assertEquals(tbl2:getrow(3), ref2:getrow(1))
  assertEquals(tbl3:getrow(3), ref3:getrow(1))
  assertEquals(tbl2:getrow(4), ref2:getrow(3))
  assertEquals(tbl3:getrow(4), ref3:getrow(3))
end

function TestMTable:testSwpRowInvalid()
  local tbl1, tbl2, tbl3 = getEmptyTables()
  local row1, row2, row3 = getRows(1)
  local msg = {
    "invalid argument #2 (valid row expected)",
    "invalid argument #3 (valid row expected)",
  }
  tbl1:addrow(row1); tbl2:addrow(row2); tbl3:addrow(row3);

  -- left
  assertErrorMsgContains(msg[1], mtable.swprow, tbl1, 5    , 1)
  assertErrorMsgContains(msg[1], mtable.swprow, tbl2, 5    , 1)
  assertErrorMsgContains(msg[1], mtable.swprow, tbl3, 5    , 1)
  assertErrorMsgContains(msg[1], mtable.swprow, tbl1,-5    , 1)
  assertErrorMsgContains(msg[1], mtable.swprow, tbl2,-5    , 1)
  assertErrorMsgContains(msg[1], mtable.swprow, tbl3,-5    , 1)
  assertErrorMsgContains(msg[1], mtable.swprow, tbl2,"none", 1)
  assertErrorMsgContains(msg[1], mtable.swprow, tbl3,"none", 1)
  -- right
  assertErrorMsgContains(msg[2], mtable.swprow, tbl1, 1, 5    )
  assertErrorMsgContains(msg[2], mtable.swprow, tbl2, 1, 5    )
  assertErrorMsgContains(msg[2], mtable.swprow, tbl3, 1, 5    )
  assertErrorMsgContains(msg[2], mtable.swprow, tbl1, 1,-5    )
  assertErrorMsgContains(msg[2], mtable.swprow, tbl2, 1,-5    )
  assertErrorMsgContains(msg[2], mtable.swprow, tbl3, 1,-5    )
  assertErrorMsgContains(msg[2], mtable.swprow, tbl2, 1,"none")
  assertErrorMsgContains(msg[2], mtable.swprow, tbl3, 1,"none")
end

function TestMTable:testRowsWithGenerators()
  local tbl = mtable "tbl" { "x" }
  for i=1,4 do tbl:addrow{i} end
  tbl:addcol("y", {11, 12, 13, 14})
  tbl:addcol("z", \i -> i + 100 )

  tbl:addrow{1.1, 2.2}
  assertEquals(tbl:getrow(5), {1.1, 2.2, 105})
  tbl:insrow(2, {3.3, 4.4})
  assertEquals(tbl:getrow(2), {3.3, 4.4, 102})
  tbl:swprow(1,3)
  assertEquals(tbl:getrow(1), {2, 12, 101})
  assertEquals(tbl:getrow(3), {1, 11, 103})
  tbl:setrow(2, {5.5, 6.6})
  assertEquals(tbl:getrow(2), {5.5, 6.6, 102})
end

function TestMTable:testBuildIndexIdx()
  local tbl = mtable "tbl" { "name1", "name2" , "id" }
  tbl:addrow{ "n1"   , "n2"   , 1}
  tbl:addrow{ "other", "other", 2}
  tbl:addrow{ "n1"   , "n2"   , 3}
  tbl:addrow{ "n1"   , "n2"   , 4}

  tbl:build_index(1)
  assertEquals(tbl:getrow("n1[1]"   ).id, 1)
  assertEquals(tbl:getrow("n1[3]"   ).id, 4)
  assertEquals(tbl:getrow("n1{2}", 2).id, 4)

  tbl:build_index(2)
  assertEquals(tbl:getrow("n2[1]"   ).id, 1)
  assertEquals(tbl:getrow("n2[3]"   ).id, 4)
  assertEquals(tbl:getrow("n2{2}", 2).id, 4)

  tbl:build_index(-3)
  assertEquals(tbl:getrow("n1[1]"   ).id, 1)
  assertEquals(tbl:getrow("n1[3]"   ).id, 4)
  assertEquals(tbl:getrow("n1{2}", 2).id, 4)

  tbl:build_index(-2)
  assertEquals(tbl:getrow("n2[1]"   ).id, 1)
  assertEquals(tbl:getrow("n2[3]"   ).id, 4)
  assertEquals(tbl:getrow("n2{2}", 2).id, 4)
end

function TestMTable:testBuildIndexName()
  local tbl = mtable "tbl" { "name1", "name2" , "id" }
  tbl:addrow{ "n1"   , "n2"   , 1}
  tbl:addrow{ "other", "other", 2}
  tbl:addrow{ "n1"   , "n2"   , 3}
  tbl:addrow{ "n1"   , "n2"   , 4}

  tbl:build_index("name1")
  assertEquals(tbl:getrow("n1[1]"   ).id, 1)
  assertEquals(tbl:getrow("n1[3]"   ).id, 4)
  assertEquals(tbl:getrow("n1{2}", 2).id, 4)

  tbl:build_index("name2")
  assertEquals(tbl:getrow("n2[1]"   ).id, 1)
  assertEquals(tbl:getrow("n2[3]"   ).id, 4)
  assertEquals(tbl:getrow("n2{2}", 2).id, 4)
end

function TestMTable:testBuildIndexNone()
  local tbl = mtable "tbl" { {"name1"}, "name2" , "id" }
  tbl:addrow{ "n1"   , "n2"   , 1}
  tbl:addrow{ "other", "other", 2}
  tbl:addrow{ "n1"   , "n2"   , 3}
  tbl:addrow{ "n1"   , "n2"   , 4}

  assertEquals(tbl:getrow("n1[1]"   ).id, 1)
  assertEquals(tbl:getrow("n1[3]"   ).id, 4)
  assertEquals(tbl:getrow("n1{2}", 2).id, 4)

  tbl:build_index("none")
  assertErrorMsgContains(_msg[3], mtable.getrow, tbl, "n1[1]"   )
  assertErrorMsgContains(_msg[3], mtable.getrow, tbl, "n1[3]"   )
  assertErrorMsgContains(_msg[3], mtable.getrow, tbl, "n1{2}", 2)
end

function TestMTable:testBuildIndexInvalid()
  local tbl = mtable "tbl" { {"name1"}, "name2" , "id" }
  tbl:addrow{ "n1"   , "n2"   , 1}
  tbl:addrow{ "other", "other", 2}
  tbl:addrow{ "n1"   , "n2"   , 3}
  tbl:addrow{ "n1"   , "n2"   , 4}
  local msg = {
    "invalid argument #2 (valid column expected)"
  }
  assertErrorMsgContains(msg[1], mtable.build_index, tbl, 5     )
  assertErrorMsgContains(msg[1], mtable.build_index, tbl,-5     )
  assertErrorMsgContains(msg[1], mtable.build_index, tbl, "nonecol")
end

function TestMTable:testWriteExtensions()
  local tbl = mtable "tbl1" { "x", "y", "z" }
  tbl.time, tbl.date, tbl.origin = "", "", ""
  testWrite(tbl, "tbl-name1.tfs", rundir("tbl-name1"    ))
  testWrite(tbl, "tbl-name2.tfs", rundir("tbl-name2.tfs"))
end

function TestMTable:testWriteDict()
  local _, tbl2, tbl3 = getIdxTbl()
  tbl2.time, tbl2.date, tbl2.origin = "", "", ""
  tbl3.time, tbl3.date, tbl3.origin = "", "", ""
  testWrite(tbl2, "tbl-dict1.tfs", rundir("tbl-dict1"))
  testWrite(tbl3, "tbl-dict2.tfs", rundir("tbl-dict2"))
end

function TestMTable:testWriteCol()
  local tbl1 = mtable "tbl1" { {"dict"}, "x", "y", "z" }
  local tbl2 = mtable "tbl2" { {"dict"}, "x", "y", "z", column = {"x", 3}}
  local row = { "v0", 1, 2, 3 }
  tbl1.time, tbl1.date, tbl1.origin = "", "", ""
  tbl2.time, tbl2.date, tbl2.origin = "", "", ""
  for i=1,4 do tbl1:addrow(row); tbl2:addrow(row) end
  testWrite(tbl1, "tbl-col1.tfs", rundir("tbl-col1")          )
  testWrite(tbl1, "tbl-col2.tfs", rundir("tbl-col2"), {"x", 3})
  testWrite(tbl2, "tbl-col2.tfs", rundir("tbl-col2")          )
end

function TestMTable:testWriteHeader()
  local tbl = mtable "tbl" {
    {"dict"}, "x", "y", "z",
    header1 = "MyHeader1", header2 = 42,
    header  = {"header1", "header2"}
  }
  local row = { "v0", 1, 2, 3 }
  tbl.time, tbl.date, tbl.origin = "", "", ""
  for i=1,4 do tbl:addrow(row) end
  testWrite(tbl, "tbl-header1.tfs", rundir("tbl-header1")
    , nil, { "title", "header1" })
  testWrite(tbl, "tbl-header2.tfs", rundir("tbl-header2"))
end

function TestMTable:testWriteNovector()
  local tbl1 = mtable "tbl1" {"x", "y", "z",
    header   = { "novector" },
    novector = true
  }
  local tbl2 = mtable "tbl2" {"x", "y", "z",
    header   = { "novector" },
    novector = { "x", "y" }
  }
  local row = { 1, 2, 3 }
  tbl1.time, tbl1.date, tbl1.origin = "", "", ""
  tbl2.time, tbl2.date, tbl2.origin = "", "", ""
  for i=1,4 do tbl1:addrow(row); tbl2:addrow(row) end
  testWrite(tbl1, "tbl-novector1.tfs", rundir("tbl-novector1"))
  testWrite(tbl2, "tbl-novector2.tfs", rundir("tbl-novector2"))
end

function TestMTable:testWriteValues()
  local tbl = mtable "tbl" {
    {"name"}, "w", "x", "y", "z",
    header1  = "header 'whith quote'",
    header2  = "header \"double quote\"",
    header3  = 42.5,
    header4  = true,
    header5  = false,
    header6  = nil,
    header7  = { "val", 3 },
    header8  = 1+1i,
    header9  = 7.3..-1.7..-1,
    novector = true,
    header   = {
      "header1", "header2", "header3", "header4", "header5",
      "header6", "header7", "header8","header9",
      "novector"
    },
  }
  tbl.time, tbl.date, tbl.origin = "", "", ""
  tbl:addrow{"name1", 1  , 2    , 3.15, 1+1i}
  tbl:addrow{"name2", nil, nil  , true, nil}
  tbl:addrow{"name1", 1  , false, 3.15, 7.3..-1.7..-1}
  tbl:addcol("gen"  , \i->i)
  tbl:addrow{"name1", "value 'whith quote'", "value \"double quote\"", 3}
  testWrite(tbl, "tbl-write.tfs", rundir("tbl-write"))
end

function TestMTable:testWriteStdout()
  local tbl    = mtable "tbl" { "x", "y", "z", var = 42 }
  local row    = { 1, 2, 3 }
  local fname  = "tbl-stdout.tfs"
  local stdout = io.stdout

  filesys.mkdir(rundir())
  tbl.time, tbl.date, tbl.origin = "", "", ""
  for i=1,4 do tbl:addrow(row) end
  io.stdout    = assert(io.open(rundir(fname), 'w'))

  testWrite(tbl, fname, {"x", "y"}, {"var", "type"})

  io.stdout    = stdout
end

function TestMTable:testWriteStream()
  filesys.mkdir(rundir())
  local tbl    = getIdxTbl()
  local fname  = "tbl-stream.tfs"
  local stream = assert(io.open(rundir(fname), 'w'))

  tbl.time, tbl.date, tbl.origin = "", "", ""
  testWrite(tbl, fname, stream, {"x", "y"})
end

function TestMTable:testWriteRightShift()
  local tbl = getIdxTbl()
  tbl.time, tbl.date, tbl.origin = "", "", ""
  tbl.var = 42
  tbl:addcol("gen"  , \i->i)
  tbl[2][0] = true
  tbl[4][0] = true
  testWrite(tbl, "tbl-rightshft1.tfs", rundir("tbl-rightshft1"), {"x"}, true)
  testWrite(tbl, "tbl-rightshft2.tfs", rundir("tbl-rightshft2"), true)
end

function TestMTable:testWriteNamedArgs()
  local tbl  = mtable "tbl" { "x", "y", "z", var = 42 }
  local args = { column = { "x", "y" }, header = { "var" }, selected = true }
  local args1, args2 = tblcpy(args), tblcpy(args)

  filesys.mkdir(rundir())
  args1.filename = rundir("tbl-namedargs1")
  args2.file     = assert(io.open(rundir("tbl-namedargs2.tfs"), "w"))
  tbl.time, tbl.date, tbl.origin = "", "", ""
  tbl.var = 42

  testWrite(tbl, "tbl-namedargs1.tfs", args1)
  testWrite(tbl, "tbl-namedargs2.tfs", args2)
end

function TestMTable:testPrint()
  local tbl    = mtable "tbl" { "x", "y", "z", var = 42 }
  local row    = { 1, 2, 3 }
  local fname  = "tbl-print.tfs"
  local stdout = io.stdout

  filesys.mkdir(rundir())
  tbl.time, tbl.date, tbl.origin = "", "", ""
  for i=1,4 do tbl:addrow(row) end
  io.stdout    = assert(io.open(rundir(fname), 'w'))

  tbl:print({"x", "y"}, {"var", "type"})
  assertFiles(fname)

  io.stdout    = stdout
end

function TestMTable:testReadExtensions()
  local tbl1 = mtable:read(refdir("tbl-name1"))
  local tbl2 = mtable:read(refdir("tbl-name2.tfs"))
  for i,col in ipairs{"x", "y", "z"} do
    assertNotNil(tbl1:getcol(col))
    assertNotNil(tbl2:getcol(col))
  end
end

function TestMTable:testReadDict()
  local tbl1 = mtable:read(refdir("tbl-dict1"))
  local tbl2 = mtable:read(refdir("tbl-dict2"))
  for i,tbl in ipairs{tbl1, tbl2} do
    assertEquals(tbl:get("name1", 2   ), -1)
    assertEquals(tbl:get("name1", 2, 3), -4)
  end
  tbl1:check_index()
  tbl2:check_index()
end

function TestMTable:testReadNovector()
  local tbl1 = mtable:read(refdir("tbl-novector1"))
  local tbl2 = mtable:read(refdir("tbl-novector2"))
  assertTrue(tbl1.novector)
  assertEquals(tbl2.novector, {"x", "y"})
  assertFalse(is_vector(tbl1:getcol(1)))
  assertFalse(is_vector(tbl1:getcol(2)))
  assertFalse(is_vector(tbl1:getcol(3)))
  assertFalse(is_vector(tbl2:getcol(1)))
  assertFalse(is_vector(tbl2:getcol(2)))
  assertTrue (is_vector(tbl2:getcol(3)))
end

function TestMTable:testReadValues()
  local tbl = mtable:read(refdir("tbl-write"))
  local col1 = { "name1", "name2", "name1"      , "name1"                  }
  local col2 = { 1      , nil    , 1            , "value 'whith quote'"    }
  local col3 = { 2      , nil    , false        , "value \"double quote\"" }
  local col4 = { 3.15   , true   , 3.15         , 3                        }
  local col5 = { 1+1i   , nil    , 7.3..-1.7..-1, nil                      }
  local col6 = { 1      , 2      , 3            , 4                        }
  assertEquals(tbl.header1, "header 'whith quote'"   )
  assertEquals(tbl.header2, "header \"double quote\"")
  assertEquals(tbl.header3, 42.5                     )
  assertEquals(tbl.header4, true                     )
  assertEquals(tbl.header5, false                    )
  assertEquals(tbl.header6, nil                      )
  assertEquals(tbl.header7, {"val", 3}               )
  assertEquals(tbl.header8, 1+1i                     )
  assertEquals(tbl.header9, 7.3..-1.7..-1            )
  assertVecEquals(tbl:getcol(1), col1)
  assertVecEquals(tbl:getcol(2), col2)
  assertVecEquals(tbl:getcol(3), col3)
  assertVecEquals(tbl:getcol(4), col4)
  assertVecEquals(tbl:getcol(5), col5)
  assertVecEquals(tbl:getcol(6), col6)
end

function TestMTable:testReadinheritance()
  local parent = mtable "parent" { var = 42 }
  local tbl    = parent:read(refdir("tbl-name1"))
  assertEquals(tbl.var, 42)
end

function TestMTable:testReadStdin()
  local stdin = io.stdin
  io.stdin    = assert(io.open(refdir("tbl-stdout.tfs"), 'r'))
  local tbl   = mtable:read()
  assertEquals(tbl.var, 42)
  assertVecEquals(tbl:getcol(1), {1, 1, 1, 1})
  assertVecEquals(tbl:getcol(2), {2, 2, 2, 2})
  io.stdin = stdin
end

function TestMTable:testReadStream()
  local stream = assert(io.open(refdir("tbl-stream.tfs"), 'r'))
  local tbl    = mtable:read(refdir("tbl-stream.tfs"))
  local ref    = getIdxTbl()

  for i=1,2 do assertEquals(tbl:getcol(i), ref:getcol(i)) end
end

function TestMTable:testReadInvalid()
  local msg = {
    "invalid header format (4 columns expected, line",
    "invalid header format (missing number, line",
    "invalid header format (missing boolean, line",
    "invalid header format (unmatched string length, line",
    "invalid header format (unmatched table length, line",
    "invalid header field type: ",
    "invalid row format ("
  }

  assertErrorMsgContains(msg[1], mtable.read, mtable, refdir("tbl-invalid1"))
  assertErrorMsgContains(msg[2], mtable.read, mtable, refdir("tbl-invalid2"))
  assertErrorMsgContains(msg[3], mtable.read, mtable, refdir("tbl-invalid3"))
  assertErrorMsgContains(msg[4], mtable.read, mtable, refdir("tbl-invalid4"))
  assertErrorMsgContains(msg[5], mtable.read, mtable, refdir("tbl-invalid5"))
  assertErrorMsgContains(msg[6], mtable.read, mtable, refdir("tbl-invalid6"))
  assertErrorMsgContains(msg[7], mtable.read, mtable, refdir("tbl-invalid7"))
end

function TestMTable:testIterEmpty()
  local tbl1, tbl2, tbl3 = getEmptyTables()
  local i = 0
  for _,row in tbl1:iter() do i = i + 1 end
  for _,row in tbl2:iter() do i = i + 1 end
  for _,row in tbl3:iter() do i = i + 1 end
  assertEquals(i, 0)
end

function TestMTable:testIterOne()
  local tbl1, tbl2, tbl3 = getEmptyTables()
  local row1, row2, row3 = getRows(1)
  tbl1:addrow(row1); tbl2:addrow(row2); tbl3:addrow(row3)
  for _,row in tbl1:iter() do assertEquals(row, row1) end
  for _,row in tbl2:iter() do assertEquals(row, row2) end
  for _,row in tbl3:iter() do assertEquals(row, row3) end
end

function TestMTable:testIter()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local i
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    i = 1
    for j,row in tbl:iter() do
      assertEquals(row, tbl:getrow(j))
      assertEquals(i, j)
      i = i + 1
    end
    assertEquals(i, 5)
  end
end

function TestMTable:testIterRangeTableIdx()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local i
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    -- first/last iterator
    i = 1
    for j,row in tbl:iter{1,-1} do
      assertEquals(row, tbl:getrow(j))
      assertEquals(i, j)
      i = i + 1
    end
    assertEquals(i, 5)

    -- 2nd/3rd iterator
    i = 2
    for j,row in tbl:iter{2,-2} do
      assertEquals(row, tbl:getrow(j))
      assertEquals(i, j)
      i = i + 1
    end
    assertEquals(i, 4)
  end
end

function TestMTable:testIterRangeStringIdx()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local i
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    -- first/last iterator
    i = 1
    for j,row in tbl:iter("1/-1") do
      assertEquals(row, tbl:getrow(j))
      assertEquals(i, j)
      i = i + 1
    end
    assertEquals(i, 5)

    -- 2nd/3rd iterator
    i = 2
    for j,row in tbl:iter("2/-2") do
      assertEquals(row, tbl:getrow(j))
      assertEquals(i, j)
      i = i + 1
    end
    assertEquals(i, 4)
  end
end

function TestMTable:testIterRangeRangeIdx()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local i
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    -- first/last iterator
    i = 1
    for j,row in tbl:iter(1..-1) do
      assertEquals(row, tbl:getrow(j))
      assertEquals(i, j)
      i = i + 1
    end
    assertEquals(i, 5)

    -- 2nd/3rd iterator
    i = 2
    for j,row in tbl:iter(2..-2) do
      assertEquals(row, tbl:getrow(j))
      assertEquals(i, j)
      i = i + 1
    end
    assertEquals(i, 4)
  end
end

function TestMTable:testIterRangeName()
  local _, tbl2, tbl3 = getIdxTbl()
  local i
  for _,tbl in ipairs{tbl2, tbl3} do
    -- first/last iterator
    i = 1
    for j,row in tbl:iter("name1[1]/name1[3]") do
      assertEquals(row, tbl:getrow(j))
      assertEquals(i, j)
      i = i + 1
    end
    assertEquals(i, 5)

    -- 2nd/3rd iterator
    i = 2
    for j,row in tbl:iter{"name2", "name1{1}", 2} do
      assertEquals(row, tbl:getrow(j))
      assertEquals(i, j)
      i = i + 1
    end
    assertEquals(i, 4)
  end
end

function TestMTable:testIterRangeSingle()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local i
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    i = 2
    for j,row in tbl:iter{2,2} do
      assertEquals(row, tbl:getrow(j))
      assertEquals(i, j)
      i = i + 1
    end
    assertEquals(i, 3)
  end
end

function TestMTable:testIterCycle()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local idx = {3, 4, 1, 2}
  local i
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    i = 1
    for j,row in tbl:iter{3,2} do
      assertEquals(row, tbl:getrow(j))
      assertEquals(idx[i], j)
      i = i + 1
    end
    assertEquals(i, 5)
  end
end

function TestMTable:testIterNturn()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local i
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    i = 0
    for j,row in tbl:iter(nil,4)  do
      assertEquals(row, tbl:getrow(j))
      assertEquals(i%4 + 1, j)
      i = i + 1
    end
    assertEquals(i, 16)
  end

  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    i = 2
    for j,row in tbl:iter({3,2},4)  do
      assertEquals(row, tbl:getrow(j))
      assertEquals(i%4 + 1, j)
      i = i + 1
    end
    assertEquals(i, 18)
  end
end

function TestMTable:testIterDir()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local idx = { 2, 1, 4, 3 }
  local i
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    -- last/first iterator decreasing
    i = 4
    for j,row in tbl:iter(nil, nil, -1) do
      assertEquals(row, tbl:getrow(j))
      assertEquals(i, j)
      i = i - 1
    end
    assertEquals(i, 0)

    -- 2nd/3rd iterator decreasing
    i = 1
    for j,row in tbl:iter({2, 3}, nil, -1) do
      assertEquals(row, tbl:getrow(j))
      assertEquals(idx[i], j)
      i = i + 1
    end
    assertEquals(i, 5)
  end
end

function TestMTable:testColIterIPairs()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    for i,row in tbl:iter() do
      for j,v in ipairs(row) do
        assertEquals(tbl:get(i, j), v)
        assertTrue(is_number(j))
      end
    end
  end
end

function TestMTable:testColIterPairs()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    for i,row in tbl:iter() do
      for j,v in pairs(row) do
        assertEquals(tbl:get(i, j), v)
        assertTrue(is_number(j))
      end
    end
  end
end

function TestMTable:testCntIter()
  local _, tbl2, tbl3 = getIdxTbl()
  local idx = { 1, 3, 4 }
  for _,tbl in ipairs{tbl2, tbl3} do
    for i,row in ipairs(tbl.name1) do
      assertEquals(row, tbl:getrow(idx[i]))
    end
  end
end

function TestMTable:testCntProxy()
  local _, tbl2, tbl3 = getIdxTbl()
  for _,tbl in ipairs{tbl2, tbl3} do
    assertEquals(tbl.name1[1][2], -1)
    assertEquals(tbl.name2   [2], -2)
    assertEquals(tbl.name1[2][2], -3)
    assertEquals(tbl.name1[3][2], -4)
  end
end

function TestMTable:testCycleIdx()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local idx = { 2, 3, 4, 1 }
  local i
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    i = 1
    tbl:cycle(2)
    for j,row in tbl:iter() do
      assertEquals(row, tbl:getrow(j))
      assertEquals(idx[i], j)
      i = i + 1
    end
    assertEquals(i, 5)

    i = 1
    tbl:cycle(-3)
    for j,row in tbl:iter() do
      assertEquals(row, tbl:getrow(j))
      assertEquals(idx[i], j)
      i = i + 1
    end
    assertEquals(i, 5)
  end
end

function TestMTable:testCycleName()
  local _, tbl2, tbl3 = getIdxTbl()
  local idx1 = { 2, 3, 4, 1 }
  local idx2 = { 3, 4, 1, 2 }
  local i
  for _,tbl in ipairs{tbl2, tbl3} do
    i = 1
    tbl:cycle("name2")
    for j,row in tbl:iter() do
      assertEquals(row, tbl:getrow(j))
      assertEquals(idx1[i], j)
      i = i + 1
    end
    assertEquals(i, 5)

    i = 1
    tbl:cycle("name1[2]")
    for j,row in tbl:iter() do
      assertEquals(row, tbl:getrow(j))
      assertEquals(idx2[i], j)
      i = i + 1
    end
    assertEquals(i, 5)
  end
end

function TestMTable:testCycleInvalid()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local msg = {
    "invalid argument #2 (reference expected)",
  }
  assertErrorMsgContains(msg[1], mtable.cycle, tbl1, 5     )
  assertErrorMsgContains(msg[1], mtable.cycle, tbl2, 5     )
  assertErrorMsgContains(msg[1], mtable.cycle, tbl3, 5     )
  assertErrorMsgContains(msg[1], mtable.cycle, tbl1,-5     )
  assertErrorMsgContains(msg[1], mtable.cycle, tbl2,-5     )
  assertErrorMsgContains(msg[1], mtable.cycle, tbl3,-5     )
  assertErrorMsgContains(msg[1], mtable.cycle, tbl2, "none")
  assertErrorMsgContains(msg[1], mtable.cycle, tbl3, "none")
end

function TestMTable:testForeachEmpty()
  local tbl1, tbl2, tbl3 = getEmptyTables()
  local i = 1
  tbl1:foreach\=> i = i+1 end
  tbl2:foreach\=> i = i+1 end
  tbl3:foreach\=> i = i+1 end
  assertEquals(i, 1)
end

function TestMTable:testForeach()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local i = 1
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    i = 1
    local act = \row,idx =>
      assertEquals(row, tbl:getrow(i))
      assertEquals(idx, i)
      i = i + 1
    end
    tbl:foreach(act)
    assertEquals(i, 5)
  end
end

function TestMTable:testForeachNot()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local i = 1
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    local act = \=> i=i+1 end
    tbl:foreach(act, nil, nil, true)
    assertEquals(i, 1)
  end
end

function TestMTable:testForeachRangeIdx()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local i = 1
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    local act = \row,idx =>
      assertEquals(row, tbl:getrow(i))
      assertEquals(idx, i)
      i = i + 1
    end

    i = 2
    tbl:foreach(act, {2, 4})
    assertEquals(i, 5)

    i = 2
    tbl:foreach(act, {-3,-1})
    assertEquals(i, 5)

    i = 2
    tbl:foreach(act, { 2, 4}, nil, nil, true)
    assertEquals(i, 5)

    i = 2
    tbl:foreach(act, {-3,-1}, nil, nil, true)
    assertEquals(i, 5)
  end
end

function TestMTable:testForeachRangeName()
  local _, tbl2, tbl3 = getIdxTbl()
  local i = 1
  for _,tbl in ipairs{tbl2, tbl3} do
    local act = \row,idx =>
      assertEquals(row, tbl:getrow(i))
      assertEquals(idx, i)
      i = i + 1
    end

    i = 2
    tbl:foreach(act, {"name2", "name1[3]"})
    assertEquals(i, 5)

    i = 2
    tbl:foreach(act, "name2/name1[3]")
    assertEquals(i, 5)

    i = 2
    tbl:foreach(act, {"name2", "name1{2}", 2})
    assertEquals(i, 5)
  end
end

function TestMTable:testForeachSelect()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local i = 1
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    local act = \row,idx =>
      assertEquals(row, tbl:getrow(i))
      assertEquals(idx, i)
      i = i + 1
    end

    i = 2
    tbl:foreach(act, {2, 4}, \r,i -> i < 4)
    assertEquals(i, 4)

    i = 2
    tbl:foreach(act, {2, 4}, \r,i -> r[2] ~= -4)
    assertEquals(i, 4)

    i = 2
    for i=1,3 do tbl[i][0] = true end
    tbl:foreach(act, {2, 4}, true)
    assertEquals(i, 4)
  end
end

function TestMTable:testForeachPattern()
  local _, tbl2, tbl3 = getIdxTbl()
  local idxs = {1, 3, 4}
  local i = 1
  for _,tbl in ipairs{tbl2, tbl3} do
    local act = \row,idx =>
      assertEquals(row, tbl:getrow(idxs[i]))
      assertEquals(idx, idxs[i])
      i = i + 1
    end

    i = 1
    tbl:foreach(act, nil, "name1")
    assertEquals(i, 4)
  end
end

function TestMTable:testForeachTableEmpty()
  local tbl1, tbl2, tbl3 = getEmptyTables()
  local i = 1
  tbl1:foreach{action=\=> i = i+1 end}
  tbl2:foreach{action=\=> i = i+1 end}
  tbl3:foreach{action=\=> i = i+1 end}
  assertEquals(i, 1)
end

function TestMTable:testForeachTable()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local i = 1
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    i = 1
    local act = \row,idx =>
      assertEquals(row, tbl:getrow(i))
      assertEquals(idx, i)
      i = i + 1
    end
    tbl:foreach{action=act}
    assertEquals(i, 5)
  end
end

function TestMTable:testForeachTableNot()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local i = 1
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    local act = \=> i=i+1 end
    tbl:foreach{action=act, default=true  }
    tbl:foreach{action=act, default="none"}
    assertEquals(i, 1)
  end
end

function TestMTable:testForeachTableRangeIdx()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local i = 1
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    local act = \row,idx =>
      assertEquals(row, tbl:getrow(i))
      assertEquals(idx, i)
      i = i + 1
    end

    i = 2
    tbl:foreach{action=act, range={2, 4}}
    assertEquals(i, 5)

    i = 2
    tbl:foreach{action=act, range={-3, -1}}
    assertEquals(i, 5)

    i = 2
    tbl:foreach{action=act, range={2, 4}, default=true}
    assertEquals(i, 5)

    i = 2
    tbl:foreach{action=act, range={-3, -1}, default=true}
    assertEquals(i, 5)

    i = 2
    tbl:foreach{action=act, range={2, 4}, default="none"}
    assertEquals(i, 5)

    i = 2
    tbl:foreach{action=act, range={-3, -1}, default="none"}
    assertEquals(i, 5)
  end
end

function TestMTable:testForeachTableRangeName()
  local _, tbl2, tbl3 = getIdxTbl()
  local i = 1
  for _,tbl in ipairs{tbl2, tbl3} do
    local act = \row,idx =>
      assertEquals(row, tbl:getrow(i))
      assertEquals(idx, i)
      i = i + 1
    end

    i = 2
    tbl:foreach{action=act, range={"name2", "name1[3]"}}
    assertEquals(i, 5)

    i = 2
    tbl:foreach{action=act, range="name2/name1[3]"}
    assertEquals(i, 5)

    i = 2
    tbl:foreach{action=act, range={"name2", "name1{2}", 2}}
    assertEquals(i, 5)
  end
end

function TestMTable:testForeachTableSelect()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local i = 1
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    local act = \row,idx =>
      assertEquals(row, tbl:getrow(i))
      assertEquals(idx, i)
      i = i + 1
    end

    i = 2
    tbl:foreach{action=act, range={2, 4}, select=\r,i -> i < 4}
    assertEquals(i, 4)

    i = 2
    tbl:foreach{action=act, range={2, 4}, select=\r,i -> r[2] ~= -4}
    assertEquals(i, 4)
  end
end

function TestMTable:testForeachTableSelected()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local i = 1
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    local act = \row,idx =>
      assertEquals(row, tbl:getrow(i))
      assertEquals(idx, i)
      i = i + 1
    end
    tbl[1][0] = true; tbl[2][0] = true

    i = 1
    tbl:foreach{action=act, selected=true}
    assertEquals(i, 3)
  end
end

function TestMTable:testForeachTablePattern()
  local _, tbl2, tbl3 = getIdxTbl()
  local idxs = {1, 3, 4}
  local i = 1
  for _,tbl in ipairs{tbl2, tbl3} do
    local act = \row,idx =>
      assertEquals(row, tbl:getrow(idxs[i]))
      assertEquals(idx, idxs[i])
      i = i + 1
    end

    i = 1
    tbl:foreach{action=act, pattern="name1"}
    assertEquals(i, 4)
  end
end

function TestMTable:testForeachTableKind()
  local _, tbl2, tbl3 = getIdxTbl()
  local kinds = { "kind1", "kind2", "kind1", "kind1" }
  local idxs  = { 1, 3, 4 }
  local i = 1
  for _,tbl in ipairs{tbl2, tbl3} do
    local act = \row,idx =>
      assertEquals(row, tbl:getrow(idxs[i]))
      assertEquals(idx, idxs[i])
      i = i + 1
    end
    tbl:addcol("kind", kinds)

    i = 1
    tbl:foreach{action=act, kind="kind1"}
    assertEquals(i, 4)
  end
end

function TestMTable:testForeachAndedSelection()
  local tbl = mtable "tbl" { {"name"}, "kind", "x" }

  local assertTest = \r,i => assertEquals(r.x, 2); assertEquals(i, 2) end

  tbl:addrow{ "name1", "kind1", 1 } -- ruled out by "selected"
  tbl:addrow{ "name1", "kind1", 2 }
  tbl:addrow{ "name1", "kind2", 3 } -- ruled out by "kind"
  tbl:addrow{ "name2", "kind1", 4 } -- ruled out by "pattern"
  tbl:addrow{ "name1", "kind1", 5 } -- ruled out by "select"
  tbl:addrow{ "name1", "kind1", 6 } -- ruled out by "range"

  for i=2,6 do tbl[i][0] = true end

  -- test the "and" of the different selections
  tbl:foreach{
    action   = assertTest,
    range    = {1,5},
    select   = \r,i -> i~=5,
    pattern  = "name1",
    kind     = "kind1",
    selected = true,
  }
end

function TestMTable:testSelect()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local assertSelect = \tbl,min,max =>
    for i=1,#tbl do
      if min <= i and i < max
      then assertTrue(tbl[i][0])
      else assertNil (tbl[i][0])
      end
    end
    for i=1,#tbl do tbl[i][0] = nil end
  end

  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    assertSelect(tbl:select()                              , 1, 5)
    assertSelect(tbl:select(nil  , nil, true)              , 1, 1)
    assertSelect(tbl:select({2,4})                         , 2, 5)
    assertSelect(tbl:select({2,4}, nil, true)              , 2, 5)
    assertSelect(tbl:select(nil,   \r,i -> 2 < i and i < 4), 3, 4)
    assertSelect(tbl:select({1,3}, \r,i -> 1 < i and i < 4), 2, 4)
  end
end

function TestMTable:testSelectTable()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local assertSelect = \tbl,min,max =>
    for i=1,#tbl do
      if min <= i and i < max
      then assertTrue(tbl[i][0])
      else assertNil (tbl[i][0])
      end
    end
    for i=1,#tbl do tbl[i][0] = nil end
  end

  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    assertSelect(tbl:select{ }                                        , 1, 5)
    assertSelect(tbl:select{ default=true }                           , 1, 1)
    assertSelect(tbl:select{ default="none" }                         , 1, 1)
    assertSelect(tbl:select{ range={2,4} }                            , 2, 5)
    assertSelect(tbl:select{ range={2,4}, default=true }              , 2, 5)
    assertSelect(tbl:select{ range={2,4}, default="none" }            , 2, 5)
    assertSelect(tbl:select{ select=\r,i -> 2 < i and i < 4 }         , 3, 4)
    assertSelect(tbl:select{ range={1,3}, select=\r,i -> 1<i and i<4 }, 2, 4)
  end
end

function TestMTable:testSelectTableDict()
  local _, tbl2, tbl3 = getIdxTbl()
  local kinds = { "kind1", "kind2", "kind1", "kind1" }
  local test = { true, false, true, true }
  local assertSelect = \tbl =>
    for i=1,#tbl do
      if test[i]
      then assertTrue(tbl[i][0])
      else assertNil (tbl[i][0])
      end
    end
    for i=1,#tbl do tbl[i][0] = nil end
  end

  for _,tbl in ipairs{tbl2, tbl3} do
    tbl:addcol("kind", kinds)
    assertSelect(tbl:select{ pattern = "name1" })
    assertSelect(tbl:select{ kind    = "kind1" })
    assertSelect(tbl:select( nil,      "name1" ))
  end
end

function TestMTable:testDeselect()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local assertDeselect = \tbl,min,max =>
    for i=1,#tbl do
      if min <= i and i < max
      then assertNil (tbl[i][0])
      else assertTrue(tbl[i][0])
      end
    end
    for i=1,#tbl do tbl[i][0] = true end
  end

  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    -- select all
    for i=1,#tbl do tbl[i][0] = true end
    assertDeselect(tbl:deselect()                              , 1, 5)
    assertDeselect(tbl:deselect(nil  , nil, true)              , 1, 1)
    assertDeselect(tbl:deselect({2,4})                         , 2, 5)
    assertDeselect(tbl:deselect({2,4}, nil, true)              , 2, 5)
    assertDeselect(tbl:deselect(nil,   \r,i -> 2 < i and i < 4), 3, 4)
    assertDeselect(tbl:deselect({1,3}, \r,i -> 1 < i and i < 4), 2, 4)
  end
end

function TestMTable:testDeselectTable()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local assertDeselect = \tbl,min,max =>
    for i=1,#tbl do
      if min <= i and i < max
      then assertNil (tbl[i][0])
      else assertTrue(tbl[i][0])
      end
    end
    for i=1,#tbl do tbl[i][0] = true end
  end

  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    -- select all
    for i=1,#tbl do tbl[i][0] = true end
    assertDeselect(tbl:deselect{ }                                        , 1, 5)
    assertDeselect(tbl:deselect{ default=true }                           , 1, 1)
    assertDeselect(tbl:deselect{ default="none" }                         , 1, 1)
    assertDeselect(tbl:deselect{ range={2,4} }                            , 2, 5)
    assertDeselect(tbl:deselect{ range={2,4}, default=true }              , 2, 5)
    assertDeselect(tbl:deselect{ range={2,4}, default="none" }            , 2, 5)
    assertDeselect(tbl:deselect{ select=\r,i -> 2 < i and i < 4 }         , 3, 4)
    assertDeselect(tbl:deselect{ range={1,3}, select=\r,i -> 1<i and i<4 }, 2, 4)
  end
end

function TestMTable:testDeselectTableDict()
  local _, tbl2, tbl3 = getIdxTbl()
  local kinds = { "kind1", "kind2", "kind1", "kind1" }
  local test = { true, false, true, true }
  local assertDeselect = \tbl =>
    for i=1,#tbl do
      if test[i]
      then assertNil (tbl[i][0])
      else assertTrue(tbl[i][0])
      end
    end
    for i=1,#tbl do tbl[i][0] = true end
  end

  for _,tbl in ipairs{tbl2, tbl3} do
    -- select all
    for i=1,#tbl do tbl[i][0] = true end
    tbl:addcol("kind", kinds)
    assertDeselect(tbl:deselect{ pattern = "name1" })
    assertDeselect(tbl:deselect{ kind    = "kind1" })
    assertDeselect(tbl:deselect( nil,      "name1" ))
  end
end

function TestMTable:testFilter()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local assertFilter = \idx,min,max =>
    local j = 1
    for i=min,max-1 do
      assertEquals(idx[j], i)
      j = j + 1
    end
  end

  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    assertFilter(tbl:filter()                              , 1, 5)
    assertFilter(tbl:filter(nil  , nil, true)              , 1, 1)
    assertFilter(tbl:filter({2,4})                         , 2, 5)
    assertFilter(tbl:filter({2,4}, nil, true)              , 2, 5)
    assertFilter(tbl:filter(nil,   \r,i -> 2 < i and i < 4), 3, 4)
    assertFilter(tbl:filter({1,3}, \r,i -> 1 < i and i < 4), 2, 4)
  end
end

function TestMTable:testFilterTable()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local assertFilter = \idx,min,max =>
    local j = 1
    for i=min,max-1 do
      assertEquals(idx[j], i)
      j = j + 1
    end
  end

  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    assertFilter(tbl:filter{ }                                        , 1, 5)
    assertFilter(tbl:filter{ default=true }                           , 1, 1)
    assertFilter(tbl:filter{ default="none" }                         , 1, 1)
    assertFilter(tbl:filter{ range={2,4} }                            , 2, 5)
    assertFilter(tbl:filter{ range={2,4}, default=true }              , 2, 5)
    assertFilter(tbl:filter{ range={2,4}, default="none" }            , 2, 5)
    assertFilter(tbl:filter{ select=\r,i -> 2 < i and i < 4 }         , 3, 4)
    assertFilter(tbl:filter{ range={1,3}, select=\r,i -> 1<i and i<4 }, 2, 4)
  end
end

function TestMTable:testFilterTableDict()
  local _, tbl2, tbl3 = getIdxTbl()
  local kinds = { "kind1", "kind2", "kind1", "kind1" }
  local test = { 1, 3, 4 }
  local assertFilter = \idx =>
    for i,v in ipairs(test) do
      assertEquals(idx[i], v)
    end
  end

  for _,tbl in ipairs{tbl2, tbl3} do
    tbl:addcol("kind", kinds)
    assertFilter(tbl:filter{ pattern = "name1" })
    assertFilter(tbl:filter{ kind    = "kind1" })
  end
end

function TestMTable:testSortEmpty()
  local tbl1, tbl2, tbl3 = getEmptyTables()
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    tbl:sort(\ ())
  end
end

function TestMTable:testSort1Row()
  local tbl1, tbl2, tbl3 = getEmptyTables()
  local row1, row2, row3= getRows()
  local lt    = \r1,r2 -> r1[1] < r2[1]
  tbl1:addrow(row1); tbl2:addrow(row2); tbl3:addrow(row3)
  tbl1:sort(lt)
  tbl2:sort(lt)
  tbl3:sort(lt)
end

function TestMTable:testSortIncreasing()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local sorted = { -4, -3, -2, -1 }
  local lt     = \r1,r2 -> r1[2] < r2[2]
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    tbl:sort(lt)
    assertVecEquals(tbl:getcol(2), sorted)
  end
end

function TestMTable:testSortDecreasing()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local sorted = { -1, -2, -3, -4 }
  local gt     = \r1,r2 -> r1[2] > r2[2]
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    tbl:sort(gt)
    assertVecEquals(tbl:getcol(2), sorted)
  end
end

function TestMTable:testSortRange()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local sorted = { -1, -3, -2, -4 }
  local lt     = \r1,r2 -> r1[2] < r2[2]
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    tbl:sort(lt, {2,3})
    assertVecEquals(tbl:getcol(2), sorted)
  end
end

function TestMTable:testSortSelect()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local sorted = { -1, -3, -2, -4 }
  local lt     = \r1,r2 -> r1[2] < r2[2]
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    tbl:sort(lt, {2,4}, \r,i -> i < 4)
    assertVecEquals(tbl:getcol(2), sorted)
  end
end

function TestMTable:testSortSelectNonContinuous()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local sorted = { -1, -4, -3, -2 }
  local lt     = \r1,r2 -> r1[2] < r2[2]
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    tbl:sort(lt, {1,4}, \r,i -> i%2==0)
    assertVecEquals(tbl:getcol(2), sorted)
  end
end

function TestMTable:testCopy()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local gen1 = \i -> i
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    tbl:addcol("gen1", gen1)
    local cpy = tbl:copy()
    assertEquals(cpy:ncol(), tbl:ncol())
    assertEquals(cpy:nrow(), tbl:nrow())
    assertEquals(cpy:ngen(), 0)
    for i=1,4 do
      assertEquals(cpy:getrow(i), tbl:getrow(i))
    end
    assertTrue(cpy:is_owner())
  end
end

function TestMTable:testCopyView()
  local tbl = mtable "tbl" {
    var1 = 42,
    var2 = "test",
    var3 = true,
    var4 = false,
  }
  local cpy = tbl:copy()
  assertEquals(cpy.var1, 42    )
  assertEquals(cpy.var2, "test")
  assertEquals(cpy.var3, true  )
  assertEquals(cpy.var4, false )
  assertTrue(tbl:is_view())
end

function TestMTable:testCopyViewName()
  local tbl = mtable "tbl" { }
  local cpy1 = tbl:copy()
  local cpy2 = tbl:copy("tbl2")
  assertEquals(cpy1.name, "tbl" )
  assertEquals(cpy2.name, "tbl2")
end

function TestMTable:testCopyViewOwner()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    local view = tbl "view" { }
    local cpy1 = view:copy()
    local cpy2 = view:copy(nil, true)
    local cpy3 = view:copy(true)      -- shift right
    for _,cpy in ipairs{cpy1, cpy2, cpy3} do
      assertEquals(cpy:ncol(), tbl:ncol())
      assertEquals(cpy:nrow(), tbl:nrow())
      assertEquals(cpy:ngen(), 0)
      for i=1,4 do
        assertEquals(cpy:getrow(i), tbl:getrow(i))
      end
    end
    assertTrue(cpy1:is_view())
    assertTrue(cpy2:is_owner())
    assertTrue(cpy3:is_owner())
  end
end

function TestMTable:testCopyDict()
  local _, tbl2, tbl3 = getIdxTbl()
  for _,tbl in ipairs{tbl2, tbl3} do
    local cpy = tbl:copy()
    cpy:check_index()
    assertEquals(cpy.refcol, "dict")
    assertEquals(cpy:getrow("name1")   , tbl:getrow("name1")   )
    assertEquals(cpy:getrow("name1[3]"), tbl:getrow("name1[3]"))
  end
end

function TestMTable:testCopyNoVector()
  local tbl1 = mtable "tbl" { "x", "y", "z", novector = true}
  local tbl2 = mtable "tbl" { "x", "y", "z", novector = {"x", "y"}}
  local row = { 1, 2, 3 }
  for i=1,4 do tbl1:addrow(row); tbl2:addrow(row) end
  local cpy1 = tbl1:copy()
  local cpy2 = tbl2:copy()
  assertFalse(is_vector(cpy1:getcol(1)))
  assertFalse(is_vector(cpy1:getcol(2)))
  assertFalse(is_vector(cpy1:getcol(3)))
  assertFalse(is_vector(cpy2:getcol(1)))
  assertFalse(is_vector(cpy2:getcol(2)))
  assertTrue (is_vector(cpy2:getcol(3)))
  assertEquals(cpy1.novector, tbl1.novector)
  assertEquals(cpy2.novector, tbl2.novector)
end

function TestMTable:testCopyNoVectorComplex()
  local tbl1 = mtable "tbl" { "x", "y", "z", novector = true}
  local tbl2 = mtable "tbl" { "x", "y", "z", novector = {"x", "y"}}
  local row = { 1+1i, 2+2i, 3+3i }
  for i=1,4 do tbl1:addrow(row); tbl2:addrow(row) end
  local cpy1 = tbl1:copy()
  local cpy2 = tbl2:copy()
  assertFalse(is_cvector(cpy1:getcol(1)))
  assertFalse(is_cvector(cpy1:getcol(2)))
  assertFalse(is_cvector(cpy1:getcol(3)))
  assertFalse(is_cvector(cpy2:getcol(1)))
  assertFalse(is_cvector(cpy2:getcol(2)))
  assertTrue (is_cvector(cpy2:getcol(3)))
  assertEquals(cpy1.novector, tbl1.novector)
  assertEquals(cpy2.novector, tbl2.novector)
end

function TestMTable:testCopyAllocatedVector()
  local tbl = mtable "tbl" { "x", "y", "z" }
  local row = { 1, 2, 3 }
  for i=1,4 do tbl:addrow(row) end
  local cpy = tbl:copy()

  cpy:addrow(row)
  for i=1,5 do assertEquals(cpy:getrow(i), row) end
  assertEquals(#cpy, 5)

  for i=1,4 do cpy:addrow(row) end
  for i=1,9 do assertEquals(cpy:getrow(i), row) end
  assertEquals(#cpy, 9)
end

function TestMTable:testCopyAllocatedVectorComplex()
  local tbl = mtable "tbl" { "x", "y", "z" }
  local row = { 1+1i, 2+2i, 3+3i }
  for i=1,4 do tbl:addrow(row) end
  local cpy = tbl:copy()

  cpy:addrow(row)
  for i=1,5 do assertEquals(cpy:getrow(i), row) end
  assertEquals(#cpy, 5)

  for i=1,4 do cpy:addrow(row) end
  for i=1,9 do assertEquals(cpy:getrow(i), row) end
  assertEquals(#cpy, 9)
end

function TestMTable:testCopyReadOnly()
  local tbl = mtable "tbl" { "name", "x", "y", "z" }
  local row = { "name", 1, 2, 3 }
  for i=1,4 do tbl:addrow(row) end
  local cpy = tbl:set_readonly():copy()
  assertTrue(tbl:is_readonly())
  assertFalse(cpy:is_readonly())
  cpy:set_readonly(true)
  cpy:set_readonly(false)
  for i=1,4 do
    assertEquals(cpy:getrow(i), tbl:getrow(i))
  end
end

function TestMTable:testRemoveNothing()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    tbl:remove()
    assertEquals(#tbl, 4)
  end
end

function TestMTable:testRemoveInt()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local ref1, ref2, ref3 = getIdxTbl()
  for tbl,ref in pairs{[tbl1]=ref1, [tbl2]=ref2, [tbl3]=ref3} do
    tbl:remove(1)
    for i=1,3 do assertEquals(tbl:getrow(i), ref:getrow(i+1)) end
    assertEquals(#tbl, 3)
  end
end

function TestMTable:testRemoveRange()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local ref1, ref2, ref3 = getIdxTbl()
  for tbl,ref in pairs{[tbl1]=ref1, [tbl2]=ref2, [tbl3]=ref3} do
    tbl:remove({2,3})
    assertEquals(tbl:getrow(1), ref:getrow(1))
    assertEquals(tbl:getrow(2), ref:getrow(4))
    assertEquals(#tbl, 2)
  end
end

function TestMTable:testRemoveSelect()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  local ref1, ref2, ref3 = getIdxTbl()
  for tbl,ref in pairs{[tbl1]=ref1, [tbl2]=ref2, [tbl3]=ref3} do
    tbl:remove(nil, \r,i -> 1 < i and i < 4)
    assertEquals(tbl:getrow(1), ref:getrow(1))
    assertEquals(tbl:getrow(2), ref:getrow(4))
    assertEquals(#tbl, 2)
  end
end

function TestMTable:testRemoveDict()
  local _, tbl2, tbl3   = getIdxTbl()
  local _, row21, row31 = getRows(1)
  local _, row24, row34 = getRows(4)
  row24[1], row34[4] = "name1", "name1"
  tbl2:remove{2,3}
  tbl3:remove{2,3}
  tbl2:check_index()
  tbl3:check_index()
  assertEquals(tbl2:getrow("name1")   , row21)
  assertEquals(tbl2:getrow("name1[2]"), row24)
  assertEquals(tbl3:getrow("name1")   , row31)
  assertEquals(tbl3:getrow("name1[2]"), row34)
end

function TestMTable:testViewRow()
  local tbl  = mtable "tbl"  { "x", "y", "z" }
  local view = tbl    "view" { }
  local row1 = { 1, 2, 3 }
  local row2 = { 4, 5, 6 }
  local row3 = { 7, 8, 9 }

  view:addrow(row1)
  assertEquals(view:getrow(1), tbl:getrow(1))

  view:addrow(row1)
  view:insrow(1, row2)
  assertEquals(view:getrow(1), tbl:getrow(1))
  assertEquals(view:getrow(2), tbl:getrow(2))

  view:swprow(1, 2)
  assertEquals(view:getrow(1), tbl:getrow(1))
  assertEquals(view:getrow(2), tbl:getrow(2))

  view:setrow(3, row3)
  assertEquals(view:getrow(3), tbl:getrow(3))

  view:set(3, 2, 9)
  assertEquals(view:get(3,2), tbl:get(3,2))

  view:remrow(2)
  assertEquals(#view, 2)
  assertEquals(#tbl, 2)
  assertEquals(view:nrow(), 2)
  assertEquals(tbl:nrow(), 2)
end

function TestMTable:testViewCol()
  local tbl  = mtable "tbl"  { "x" }
  local view = tbl    "view" { }

  view:addrow{1}
  assertEquals(view:getcol("x"), tbl:getcol("x"))

  view:addcol("col", { 42 })
  assertEquals(view:getcol("col"), tbl:getcol("col"))
  assertVecEquals(view:getcol("col"), {42})

  view:setcol("col", { 43 })
  assertEquals(view:getcol("col"), tbl:getcol("col"))
  assertVecEquals(view:getcol("col"), {43})

  view:inscol(2, "col2", { 44 })
  assertEquals(view:getcol("col2"), tbl:getcol(2))
  assertVecEquals(view:getcol("col2"), {44})

  view:remcol(2)
  assertEquals(view:ncol(), 2)
  assertEquals(tbl :ncol(), 2)

  view:addcol("col3", \i -> i)
  assertEquals(view:ngen(), 1)
  assertEquals(tbl :ngen(), 1)
end

function TestMTable:testSetReadOnlyOwner()
  local tbl = mtable "tbl" { {"dict"}, "x", "y", "z"}
  local row = {"name", 1, 2, 3}
  local col = {1, 2}
  local msg = {
    "forbidden write access to 'tbl.start_at' (readonly object, method or variable)"
  }
  tbl:addrow(row)
  tbl:addrow(row)

  tbl:set_readonly()
  assertErrorMsgContains(_msg[1], mtable.addrow     , tbl, row              )
  assertErrorMsgContains(_msg[1], mtable.remrow     , tbl, 1                )
  assertErrorMsgContains(_msg[1], mtable.insrow     , tbl, 1    , row       )
  assertErrorMsgContains(_msg[1], mtable.setrow     , tbl, 1                )
  assertErrorMsgContains(_msg[1], mtable.setrow     , tbl, 1    , row       )
  assertErrorMsgContains(_msg[1], mtable.swprow     , tbl, 1    , 2         )
  assertErrorMsgContains(_msg[1], mtable.addcol     , tbl, "col", col       )
  assertErrorMsgContains(_msg[1], mtable.inscol     , tbl, 1    , "col", col)
  assertErrorMsgContains(_msg[1], mtable.setcol     , tbl, "x"  , col       )
  assertErrorMsgContains(_msg[1], mtable.set        , tbl, 1    , 1    , 2  )
  assertErrorMsgContains(_msg[1], mtable.build_index, tbl, "x"              )
  assertErrorMsgContains(_msg[1], mtable.sort       , tbl, \ ()             )
  assertErrorMsgContains(_msg[1], mtable.remove     , tbl                   )
  assertErrorMsgContains(_msg[1], mtable.insert     , tbl                   )
  assertErrorMsgContains( msg[1], mtable.cycle      , tbl, 2                )
end

function TestMTable:testSetReadOnlyView()
  local tbl  = mtable "tbl"  { {"dict"}, "x", "y", "z"}
  local view = tbl "view" { }
  local row = {"name", 1, 2, 3}
  local col = {1, 2}
  local msg = {
    "forbidden write access to 'view.start_at' (readonly object, method or variable)"
  }
  view:addrow(row)
  view:addrow(row)

  view:set_readonly()
  assertErrorMsgContains(_msg[1], mtable.addrow     , view, row              )
  assertErrorMsgContains(_msg[1], mtable.remrow     , view, 1                )
  assertErrorMsgContains(_msg[1], mtable.insrow     , view, 1    , row       )
  assertErrorMsgContains(_msg[1], mtable.setrow     , view, 1    , row       )
  assertErrorMsgContains(_msg[1], mtable.setrow     , view, 1                )
  assertErrorMsgContains(_msg[1], mtable.swprow     , view, 1    , 2         )
  assertErrorMsgContains(_msg[1], mtable.addcol     , view, "col", col       )
  assertErrorMsgContains(_msg[1], mtable.inscol     , view, 1    , "col", col)
  assertErrorMsgContains(_msg[1], mtable.setcol     , view, "x"  , col       )
  assertErrorMsgContains(_msg[1], mtable.set        , view, 1    , 1    , 2  )
  assertErrorMsgContains(_msg[1], mtable.build_index, view, "x"              )
  assertErrorMsgContains(_msg[1], mtable.sort       , view, \ ()             )
  assertErrorMsgContains(_msg[1], mtable.remove     , view                   )
  assertErrorMsgContains(_msg[1], mtable.insert     , view                   )
  assertErrorMsgContains( msg[1], mtable.cycle      , view, 2                )
end

function TestMTable:testSetReadOnlyOwnerView()
  local tbl  = mtable "tbl"  { {"dict"}, "x", "y", "z"}
  local view = tbl "view" { }
  local row = {"name", 1, 2, 3}
  local col = {1, 2}
  view:addrow(row)
  view:addrow(row)

  tbl:set_readonly()
  assertErrorMsgContains(_msg[1], mtable.addrow     , view, row              )
  assertErrorMsgContains(_msg[1], mtable.remrow     , view, 1                )
  assertErrorMsgContains(_msg[1], mtable.insrow     , view, 1    , row       )
  assertErrorMsgContains(_msg[1], mtable.setrow     , view, 1    , row       )
  assertErrorMsgContains(_msg[1], mtable.setrow     , view, 1                )
  assertErrorMsgContains(_msg[1], mtable.swprow     , view, 1    , 2         )
  assertErrorMsgContains(_msg[1], mtable.addcol     , view, "col", col       )
  assertErrorMsgContains(_msg[1], mtable.inscol     , view, 1    , "col", col)
  assertErrorMsgContains(_msg[1], mtable.setcol     , view, "x"  , col       )
  assertErrorMsgContains(_msg[1], mtable.set        , view, 1    , 1    , 2  )
  assertErrorMsgContains(_msg[1], mtable.build_index, view, "x"              )
  assertErrorMsgContains(_msg[1], mtable.sort       , view, \ ()             )
  assertErrorMsgContains(_msg[1], mtable.remove     , view                   )
  assertErrorMsgContains(_msg[1], mtable.insert     , view                   )
  view:cycle(2)
end

function TestMTable:testDebug()
  local debug = MAD.option.debug
  MAD.option.debug = 3
  local tbl = mtable "tbl"  { "dict", "x", "y", "z" }
  tbl:addrow{"name1", 1, 2, 3}
  tbl:build_index("dict")
  MAD.option.debug = debug
end

function TestMTable:testSetReadOnlyProxy()
  local tbl    = mtable "tbl" { {"dict"}, "x", "y", "z"}
  local assign1 = \tbl,a,b     => tbl[a]       = b end
  local assign2 = \tbl,a,b,c   => tbl[a][b]    = c end
  local assign3 = \tbl,a,b,c,d => tbl[a][b][c] = d end
  local row1 = {"name1", 1, 2, 3}
  local row2 = {"name2", 1, 2, 3}
  tbl:addrow(row1); tbl:addrow(row2); tbl:addrow(row1)
  tbl:set_readonly()
  local msg = {
    "attempt to write to constant location",
    "invalid use of object <mtable readonly column:",
    "invalid use of object <mtable count:",
  }

  assertErrorMsgContains( msg[1], assign1, tbl:getcol("x"), 1, 42  )
  assertErrorMsgContains(_msg[1], assign2, tbl, "name2", "x", 42   )
  assertErrorMsgContains(_msg[1], assign3, tbl, "name1", 2, "x", 42)
end

function TestMTable:testSetUnsetReadOnly()
  local tbl = mtable "tbl" { {"dict"}, "x", "y", "z"}
  local row = {"name1", 1, 2, 3}
  tbl:addrow(row)
  tbl:addrow(row)

  tbl:set_readonly(true)
  tbl:set_readonly(false)

  tbl.dict[1] = "name2"
  tbl.x   [1] = 42
  tbl.y   [1] = 43
  tbl.z   [1] = 44
  assertEquals(tbl.name2, {"name2", 42, 43, 44})
end

function TestMTable:testReadOnlyColProxy()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    tbl:set_readonly()
    for j=1,tbl:ncol() do
      local col = tbl:getcol(j)
      for i,v in ipairs(col) do
        assertEquals(tbl:get(i,j), v)
        assertEquals(tbl:get(i,j), col[i])
        assertEquals(#tbl, #col)
      end
    end
  end
end

function TestMTable:testReadOnlyRowProxy()
  local tbl1, tbl2, tbl3 = getIdxTbl()
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    tbl:set_readonly()
    for i,row in ipairs(tbl) do
      for j=1,tbl:ncol() do
        assertEquals(tbl:get(i,j), row[j])
      end
      assertEquals(#row, tbl:ncol())
    end
  end
end

function TestMTable:testRefColProxy()
  local _, tbl2, tbl3 = getIdxTbl()
  local assign = \tbl,a,b => tbl.dict[a] = b end
  local msg    = {
    "row index out of bounds",
    "invalid argument #3 (valid reference key expected)",
  }
  for _,tbl in ipairs{tbl2, tbl3} do
    assertEquals(#tbl.dict, 4)
    assertEquals(tbl.dict[1], "name1")
    assertEquals(tbl.dict[2], "name2")
    assertErrorMsgContains(msg[1], assign, tbl, 5     )
    assertErrorMsgContains(msg[1], assign, tbl,-5     )
    assertErrorMsgContains(msg[2], assign, tbl, 1, nil)
    tbl.dict[2] = "name3"
    assertEquals(tbl.name3, tbl:getrow(2))
    tbl:check_index()
  end
end

function TestMTable:testRowProxy()
  local _, tbl2, tbl3 = getIdxTbl()
  local assign = \tbl,a,b => tbl[a] = b end
  local msg    = {
    "invalid column in row write access",
    "invalid argument #3 (valid reference key expected)",
  }
  for _,tbl in ipairs{tbl2, tbl3} do
    for i=1,4 do
      assertEquals(#tbl[i], 4)
      assertEquals(tbl[i][ 1], tbl:get(i, 1  ))
      assertEquals(tbl[i][-2], tbl:get(i,-2  ))
      assertEquals(tbl[i].y  , tbl:get(i, "y"))
      assertEquals(tbl[i].y  , tbl:get(i, "y"))
      assertErrorMsgContains(msg[1], assign, tbl[i], 5     )
      assertErrorMsgContains(msg[1], assign, tbl[i],-6     )
      assertErrorMsgContains(msg[1], assign, tbl[i], "none")
      assertErrorMsgContains(msg[2], assign, tbl[i], "dict", nil)
      local name  = tbl.name .. i
      tbl[i].dict = name
      assertEquals(tbl:get(name, 2), tbl:get(i, 2))
    end
    tbl:check_index()
  end
end

function TestMTable:testInsertEmptySingle()
  local tbl11, tbl21, tbl31 = getEmptyTables()
  local rows1, rows2, rows3 = getRows(1,1)
  tbl11:insert(rows1, 1)
  tbl21:insert(rows2, 1)
  tbl31:insert(rows3, 1)
  assertEquals(tbl11:getrow(1), rows1[1])
  assertEquals(tbl21:getrow(1), rows2[1])
  assertEquals(tbl31:getrow(1), rows3[1])
end

function TestMTable:testInsertEmptyMulti()
  local tbl11, tbl21, tbl31 = getEmptyTables()
  local rows1, rows2, rows3 = getRows(1, 4)

  tbl11:insert(rows1, 1)
  tbl21:insert(rows2, 1)
  tbl31:insert(rows3, 1)
  for i=1,4 do
    assertEquals(tbl11:getrow(i), rows1[i])
    assertEquals(tbl21:getrow(i), rows2[i])
    assertEquals(tbl31:getrow(i), rows3[i])
  end
end

function TestMTable:testInsert1Row1Idx()
  local tbl1 , tbl2 , tbl3  = getIdxTbl()
  local rows1, rows2, rows3 = getRows(5,1)
  tbl1:insert(rows1, 1)
  tbl2:insert(rows2, 1)
  tbl3:insert(rows3, 1)
  assertEquals(tbl1:getrow(1), rows1[1])
  assertEquals(tbl2:getrow(1), rows2[1])
  assertEquals(tbl3:getrow(1), rows3[1])

  tbl1:insert(rows1, 3)
  tbl2:insert(rows2, 3)
  tbl3:insert(rows3, 3)
  assertEquals(tbl1:getrow(3), rows1[1])
  assertEquals(tbl2:getrow(3), rows2[1])
  assertEquals(tbl3:getrow(3), rows3[1])

  tbl1:insert(rows1, 7)
  tbl2:insert(rows2, 7)
  tbl3:insert(rows3, 7)
  assertEquals(tbl1:getrow(7), rows1[1])
  assertEquals(tbl2:getrow(7), rows2[1])
  assertEquals(tbl3:getrow(7), rows3[1])
end

function TestMTable:testInsertNRow1IdxBegin()
  local tbl1  , tbl2  , tbl3   = getIdxTbl()
  local rows11, rows21, rows31 = getRows(5,4)

  tbl1:insert(rows11, 1)
  tbl2:insert(rows21, 1)
  tbl3:insert(rows31, 1)
  for i=1,4 do
    assertEquals(tbl1:getrow(i), rows11[i])
    assertEquals(tbl2:getrow(i), rows21[i])
    assertEquals(tbl3:getrow(i), rows31[i])
  end
end

function TestMTable:testInsertNRow1IdxInside()
  local tbl1 , tbl2 , tbl3  = getIdxTbl()
  local rows1, rows2, rows3 = getRows(5,4)

  tbl1:insert(rows1, 2)
  tbl2:insert(rows2, 2)
  tbl3:insert(rows3, 2)
  for i=2,5 do
    assertEquals(tbl1:getrow(i), rows1[i-1])
    assertEquals(tbl2:getrow(i), rows2[i-1])
    assertEquals(tbl3:getrow(i), rows3[i-1])
  end
end

function TestMTable:testInsertNRow1IdxEnd()
  local tbl1  , tbl2  , tbl3   = getIdxTbl()
  local rows11, rows21, rows31 = getRows(5,4)
  local rows12, rows22, rows32 = getRows(9,4)

  tbl1:insert(rows11, 4, {where="after"})
  tbl2:insert(rows21, 4, {where="after"})
  tbl3:insert(rows31, 4, {where="after"})
  for i=5,8 do
    assertEquals(tbl1:getrow(i), rows11[i-4])
    assertEquals(tbl2:getrow(i), rows21[i-4])
    assertEquals(tbl3:getrow(i), rows31[i-4])
  end

  tbl1:insert(rows12, 9)
  tbl2:insert(rows22, 9)
  tbl3:insert(rows32, 9)
  for i=9,12 do
    assertEquals(tbl1:getrow(i), rows12[i-8])
    assertEquals(tbl2:getrow(i), rows22[i-8])
    assertEquals(tbl3:getrow(i), rows32[i-8])
  end
end

function TestMTable:testInsert1RowNIdxBefore()
  local tbl1 , tbl2 , tbl3  = getIdxTbl()
  local rows1, rows2, rows3 = getRows(5,1)

  tbl1:insert(rows1, {1,4})
  tbl2:insert(rows2, {1,4})
  tbl3:insert(rows3, {1,4})
  for i=1,7,2 do
    assertEquals(tbl1:getrow(i), rows1[1])
    assertEquals(tbl2:getrow(i), rows2[1])
    assertEquals(tbl3:getrow(i), rows3[1])
  end
end

function TestMTable:testInsert1RowNIdxAfter()
  local tbl1 , tbl2 , tbl3  = getIdxTbl()
  local rows1, rows2, rows3 = getRows(5,1)

  tbl1:insert(rows1, {1,4}, {where="after"})
  tbl2:insert(rows2, {1,4}, {where="after"})
  tbl3:insert(rows3, {1,4}, {where="after"})
  for i=2,8,2 do
    assertEquals(tbl1:getrow(i), rows1[1])
    assertEquals(tbl2:getrow(i), rows2[1])
    assertEquals(tbl3:getrow(i), rows3[1])
  end
end

function TestMTable:testInsertNRowNIdxBefore()
  local tbl1 , tbl2 , tbl3  = getIdxTbl()
  local rows1, rows2, rows3 = getRows(5,4)

  tbl1:insert(rows1, {1,4})
  tbl2:insert(rows2, {1,4})
  tbl3:insert(rows3, {1,4})
  for i=1,7,2 do
    assertEquals(tbl1:getrow(i), rows1[(1+i)/2])
    assertEquals(tbl2:getrow(i), rows2[(1+i)/2])
    assertEquals(tbl3:getrow(i), rows3[(1+i)/2])
  end
end

function TestMTable:testInsertNRowNIdxAfter()
  local tbl1 , tbl2 , tbl3  = getIdxTbl()
  local rows1, rows2, rows3 = getRows(5,4)

  tbl1:insert(rows1, {1,4}, {where="after"})
  tbl2:insert(rows2, {1,4}, {where="after"})
  tbl3:insert(rows3, {1,4}, {where="after"})
  for i=2,8,2 do
    assertEquals(tbl1:getrow(i), rows1[i/2])
    assertEquals(tbl2:getrow(i), rows2[i/2])
    assertEquals(tbl3:getrow(i), rows3[i/2])
  end
end

function TestMTable:testInsertNRowMIdxAfter()
  local tbl11 , tbl21 , tbl31  = getIdxTbl()
  local tbl12 , tbl22 , tbl32  = getIdxTbl()
  local rows11, rows21, rows31 = getRows(5,6)
  local rows12, rows22, rows32 = getRows(11,2)

  -- N > M
  tbl11:insert(rows11, {1,4})
  tbl21:insert(rows21, {1,4})
  tbl31:insert(rows31, {1,4})
  for i=1,7,2 do
    assertEquals(tbl11:getrow(i), rows11[(i+1)/2])
    assertEquals(tbl21:getrow(i), rows21[(i+1)/2])
    assertEquals(tbl31:getrow(i), rows31[(i+1)/2])
  end
  assertNil(tbl21.name9 )
  assertNil(tbl31.name9 )
  assertNil(tbl21.name10)
  assertNil(tbl31.name10)

  -- N < M
  tbl12:insert(rows12, {1,4})
  tbl22:insert(rows22, {1,4})
  tbl32:insert(rows32, {1,4})
  for i=1,3,2 do
    assertEquals(tbl12:getrow(i), rows12[(i+1)/2])
    assertEquals(tbl22:getrow(i), rows22[(i+1)/2])
    assertEquals(tbl32:getrow(i), rows32[(i+1)/2])
  end
  assertEquals(#tbl12, 6)
  assertEquals(#tbl22, 6)
  assertEquals(#tbl32, 6)
end

function TestMTable:testInsertSel()
  local tbl1 , tbl2 , tbl3  = getIdxTbl()
  local rows1, rows2, rows3 = getRows(5,6)

  for tbl,rows in pairs{[tbl1]=rows1, [tbl2]=rows2, [tbl3]=rows3} do
    tbl:insert(rows, {range={2,4}, select=\r,i -> i<4})
    assertEquals(tbl:getrow(2), rows[1])
    assertEquals(tbl:getrow(4), rows[2])
  end
end

function TestMTable:testKpairsTbl()
  local tbl1, tbl2, tbl3  = getIdxTbl()
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    check_kpairs(tbl)
  end
end

function TestMTable:testKpairsCol()
  local tbl1, tbl2, tbl3  = getIdxTbl()
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    tbl:addcol("gen", \i -> i)
    for i=0,tbl:ncol() do check_kpairs(tbl:getcol(i)) end
  end
end

function TestMTable:testKpairsRow()
  local tbl1, tbl2, tbl3  = getIdxTbl()
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    tbl:addcol("gen", \i -> i)
    for i=1,tbl:nrow() do check_kpairs(tbl:getrow(i)) end
  end
end

function TestMTable:testKpairsCnt()
  local _, tbl2, tbl3  = getIdxTbl()
  for _,tbl in ipairs{tbl2, tbl3} do
    tbl:addcol("gen", \i -> i)
    check_kpairs(tbl.name1)
  end
end

function TestMTable:testKpairsReadOnlyCol()
  local tbl1, tbl2, tbl3  = getIdxTbl()
  for _,tbl in ipairs{tbl1, tbl2, tbl3} do
    tbl:addcol("gen", \i -> i)
    tbl:set_readonly()
    for i=0,tbl:ncol() do check_kpairs(tbl:getcol(i)) end
  end
end

-- performance test suite -----------------------------------------------------o

Test_MTable = {}

function Test_MTable:testInsertVsAddRow()
  local tbl1 = mtable "tbl" { {"name"}, "x", "y", "z" }
  local tbl2 = mtable "tbl" { {"name"}, "x", "y", "z" }
  local size = 5e5
  local rows = table.new(size,0)
  for i=1,size do rows[i] = newrow(i) end

  local t0 = os.clock()
  for i=1,size do tbl1:addrow(rows[i]) end
  local dt1 = os.clock() - t0

  local t1 = os.clock()
  tbl2:insert(rows, 1)
  local dt2 = os.clock() - t1

  assertAlmostEquals( dt1 , 0.4, 0.8 )
  assertAlmostEquals( dt2 , 0.2, 0.4 )

  assertEquals(#tbl1, #tbl2)
  for i=1,size do assertVecEquals(tbl1:getrow(i), tbl2:getrow(i)) end
end

function Test_MTable:testRemoveVsRemRow()
  local size, start, stop = 1e4, 1e3, 2e3
  local tbl1 = newtbl(size)
  local tbl2 = newtbl(size)

  local t0 = os.clock()
  for i=stop,start,-1 do tbl1:remrow(i) end
  local dt1 = os.clock() - t0

  local t1 = os.clock()
  tbl2:remove{start, stop}
  local dt2 = os.clock() - t1

  assertAlmostEquals( dt1 , 0.5, 1 )
  assertAlmostEquals( dt2 , 0.1, 1 )

  assertEquals(#tbl1, #tbl2)
  for i=1,#tbl1 do assertVecEquals(tbl1:getrow(i), tbl2:getrow(i)) end
end

-- end ------------------------------------------------------------------------o
